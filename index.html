<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>ä¹–ä¹–åŠ è½½ä¸­...</title>
  <link rel="icon" type="image/png" sizes="96x96" href="me.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
  <link rel="preload" href="mao3.webp" as="image">
  <link rel="preload" href="mao1.webp" as="image">
  <link rel="preload" href="font/iconfont.css" as="style">
  <link rel="preload" href="css/style.css" as="style">
  <link rel="preload" href="mao.webp" as="image">
  <link rel="preload" href="aimao.mp4" as="video">
  <link rel="preload" href="cat1.webp" as="image">
  <link rel="preload" href="js/index.js" as="script">
  <link rel="preload" href="run.gif" as="image">
  <link rel="preload" href="kaa.mp3" as="audio">
  <link rel="preload" href="Sukidakara.mp3" as="audio">
  <link rel="preload" href="mao2.mp4" as="video">
  <link rel="preload" href="mao2.webp" as="image">

  <style>
/* æ·»åŠ å±å¹•è¿‡æ¸¡åŠ¨ç”» */
@keyframes rotateToPortrait {
  0% { transform: rotateY(90deg) scale(0.8); opacity: 0; }
  50% { transform: rotateY(0deg) scale(1.05); opacity: 1; }
  100% { transform: rotateY(0deg) scale(1); opacity: 1; }
}

.rotate-transition {
  animation: rotateToPortrait 0.7s ease-in-out forwards;
}

@media (orientation: landscape) {
  #display-area,
  #card-stack-area {
    max-width: 90vw;  /* å¢åŠ æœ€å¤§å®½åº¦ */
    width: 90vw;
  }

  #display-area {
    min-height: 140px; /* å¯æ ¹æ®éœ€è¦å¢åŠ é«˜åº¦ä»¥æ›´çªå‡ºæ˜¾ç¤ºåŒºåŸŸ */
  }

  #card-stack-area {
    height: 75vh;  /* æ›´é«˜ä¸€ç‚¹ï¼Œä½¿å¾—æ¯”ä¾‹æ›´åè°ƒ */
  }
}
#risk-modal .modal-content {
  animation: risk-modal-in 0.3s ease-out;
  min-width: 280px;
  max-width: 90%;
  width: auto;
  transition: all 0.3s ease;
}

#risk-modal .modal-content[data-type="info"] {
  background: #f0f9ff;
  border-color: #3b82f6;
}

#risk-modal .modal-content[data-type="risk"] {
  background: #fff3f3;
  border-color: #dc2626;
}

#risk-modal .modal-content[data-type="warning"] {
  background: #fefce8;
  border-color: #ca8a04;
}

#risk-modal button {
  padding: 8px 20px;
  font-size: 1rem;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-family: 'ZCOOL KuaiLe', cursive;
  background: white;
}

#risk-modal button:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

#risk-modal p {
  margin: 0 0 20px 0;
  line-height: 1.5;
}

/* æ·»åŠ ä¸åŒç±»å‹æŒ‰é’®çš„æ ·å¼ */
#risk-modal[data-type="info"] button {
  border-color: #3b82f6;
  color: #1d4ed8;
}

#risk-modal[data-type="risk"] button {
  border-color: #dc2626;
  color: #991b1b;
}

#risk-modal[data-type="warning"] button {
  border-color: #ca8a04;
  color: #854d0e;
}

    @keyframes card-vanish {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      50% {
        transform: scale(1.1) rotate(5deg);
        opacity: 0.8;
      }
      100% {
        transform: scale(0.1) rotate(15deg) translateY(50px);
        opacity: 0;
      }
    }
    .temp-card.vanishing {
      position: relative; /* ç¡®ä¿ z-index ç”Ÿæ•ˆ */
      z-index: 10;
      animation: card-vanish 0.5s ease-out forwards;
    }

    /* åŸæœ‰çš„ card-disappear åŠ¨ç”»ä¸å†ä½¿ç”¨ï¼Œå¯ä»¥å®‰å…¨ç§»é™¤æˆ–ä¿ç•™ */
    @keyframes card-disappear {
        from {
            opacity: 1;
            transform: scale(1) rotate(0deg);
        }
        to {
            opacity: 0;
            transform: scale(0.4) rotate(20deg);
        }
    }
    .temp-card.disappearing {
        animation: card-disappear 0.3s ease-out forwards;
    }

    /* å…¶ä»–æ ·å¼ä¿æŒä¸å˜ */
    @keyframes card-float-out {
      0% {
        opacity: 0;
        transform: translateY(40px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .card-floating-in {
        animation: card-float-out 0.5s ease-out forwards;
    }

    @keyframes lid-open {
        0% {
            transform: rotateX(0deg);
            opacity: 1;
        }
        70% {
            transform: rotateX(80deg);
            opacity: 1;
        }
        100% {
            transform: rotateX(90deg);
            opacity: 0;
            visibility: hidden;
        }
    }

    @keyframes slot-flash {
        0% { background-color: #fdf5e6; box-shadow: inset 0 1px 4px rgba(0,0,0,0.05); }
        50% { background-color: #fff8dc; box-shadow: inset 0 0 10px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.5); }
        100% { background-color: #fdf5e6; box-shadow: inset 0 1px 4px rgba(0,0,0,0.05); }
    }
    .temp-slot.clearing {
        animation: slot-flash 0.4s ease-out;
    }

    @keyframes pulse-scale {
      0%, 100% { transform: scale(1); opacity: 0.8; }
      50% { transform: scale(1.05); opacity: 1; }
    }
    @keyframes text-progress {
      0% { content: "."; }
      33% { content: ".."; }
      66% { content: "..."; }
      100% { content: "."; }
    }
    @keyframes wave {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-10px) rotate(2deg); }
      75% { transform: translateY(5px) rotate(-1deg); }
    }
    @keyframes show-card-property {
      0% { opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes fade-in-out-scale {
      0% { opacity: 0; transform: scale(0.8); }
      50% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.9); }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0) rotate(0deg); }
      10%, 30%, 50%, 70%, 90% { transform: translateX(-3px) rotate(-1deg); }
      20%, 40%, 60%, 80% { transform: translateX(3px) rotate(1deg); }
    }

    @keyframes score-pop {
      0% { opacity: 0; transform: translateY(0) scale(0.8); }
      20% { opacity: 1; transform: translateY(-15px) scale(1.1); }
      80% { opacity: 1; transform: translateY(-30px) scale(1); }
      100% { opacity: 0; transform: translateY(-40px) scale(0.7); }
    }
    .score-animation {
      position: absolute;
      font-size: 1.5rem;
      font-weight: bold;
      color: #4CAF50;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      pointer-events: none;
      animation: score-pop 1s ease-out forwards;
      z-index: 2000;
    }

    /* å¸å…¥åŠ¨ç”» (æºæ–‡ä»¶æ•ˆæœ) */
@keyframes swirlIn {
  0% {
    transform: scale(1);
    opacity: 1;
  }
  100% {
    transform: scale(0.2);
    opacity: 0.5;
    /* åŠ¨ç”»ç»ˆç‚¹æ˜¯çˆ¶å®¹å™¨çš„ä¸­å¿ƒ */
    left: 50%;
    top: 50%;
  }
}

/* å–·å‡ºåŠ¨ç”» (æºæ–‡ä»¶æ•ˆæœï¼Œè™½ç„¶æ´—ç‰Œæ²¡ç”¨ä¸Šï¼Œä½†æœ€å¥½ä¿ç•™) */
@keyframes swirlOut {
  0% {
    transform: scale(0.2) rotate(720deg);
    opacity: 0.5;
    left: 50%;
    top: 50%;
  }
  100% {
    transform: scale(1) rotate(0deg);
    opacity: 1;
    left: var(--final-left);
    top: var(--final-top);
  }
}

/* åº”ç”¨åŠ¨ç”»çš„ç±»å */
.card.swirl-in {
  animation: swirlIn 0.6s ease-in forwards;
  z-index: 10;
}

.card.swirl-out {
  animation: swirlOut 0.6s ease-out forwards;
  z-index: 10;
}

    @keyframes fade-in-out-heart {
      0% { opacity: 0; transform: scale(0.5); }
      50% { opacity: 1; transform: scale(1.2); }
      100% { opacity: 0; transform: scale(0.8); }
    }
    .heart-animation {
      position: absolute;
      font-size: 30px;
      color: #ff69b4;
      pointer-events: none;
      animation: fade-in-out-heart 2.5s ease-out infinite alternate;
      z-index: 1000;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }
    
    .confetti-container {
        position: absolute;
        top: -30vh;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 9999;
    }
    .confetti-piece {
        position: absolute;
        width: 8px;
        height: 16px;
        background: #f00;
        top: -20px;
        opacity: 0;
        animation: fall linear forwards;
    }
    @keyframes fall {
        0% {
            transform: translateY(0) rotateZ(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(110vh) rotateZ(720deg);
            opacity: 0;
        }
    }

    @keyframes button-scale-pulse {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      50% {
        transform: scale(1.08);
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      }
    }

    @keyframes button-scale-fade-pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 0.8;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      50% {
        transform: scale(1.08);
        opacity: 1;
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
      }
    }
    .animated-scale-fade {
        animation: button-scale-fade-pulse 1.8s infinite ease-in-out;
    }

    @keyframes cloud-pass {
      from {
        transform: translateX(-250px);
      }
      to {
        transform: translateX(100vw);
      }
    }

    body {
      margin: 0;
      min-height: 100vh;
      overflow-x: hidden;
      font-family: 'ZCOOL KuaiLe', 'HanyiSentyLotus', 'FangSong', cursive, sans-serif;
      color: #3e2723;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-base) url('cat1.webp') no-repeat center center;
      background-size: cover;
      z-index: -2;
    }
    body::after {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: white;
      opacity: 0.3;
      z-index: -1;
    }
    body.no-scroll {
      overflow: hidden;
    }

    #game-container {
      max-width: 650px;
      margin: 30px auto;
      background: rgba(255, 255, 255, 0.7);
      background: var(--panel-bg);
      border-radius: 25px;
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
      padding: 0 0 20px 0;
      position: relative;
      min-height: 880px;
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 3px solid var(--panel-border);
    }
    @media (max-width: 700px) {
      #game-container {
        max-width: 100vw;
        margin: 0;
        box-shadow: none;
        border-radius: 0;
        min-height: 100vh;
        border: none;
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
    }
    @media (min-width: 701px) {
      #game-container {
        max-width: 900px;
        min-height: 90vh;
        margin: 5vh auto;
      }
    }

    #header-bar {
      width: 100%;
      padding: 15px 25px 0 25px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--panel-bg);
      border-top-left-radius: 22px;
      border-top-right-radius: 22px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    #progress-info {
      font-size: 1.55rem;
      font-weight: bold;
      display: flex;
      gap: 15px;
      align-items: center;
    }
    #progress-info, .score-display, .target-display {
      color: var(--text-primary);
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.7);
    }
    #music-toggle {
      background: none;
      border: none;
      outline: none;
      font-size: 1.8rem;
      cursor: pointer;
      color: #6d4c41;
      transition: transform 0.2s ease-in-out;
    }
    #music-toggle:hover {
      transform: scale(1.1);
    }
    .score-display, .target-display {
        font-size: 1.2rem;
        font-weight: bold;
    }

    #main-area {
      flex:1;
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      padding-top: 10px;
    }

    #display-area {
        margin-top: 20px;
        width: 90%;
        max-width: 580px;
        min-height: 100px;
        background: rgba(240, 230, 210, 0.6);
        border-radius: 15px;
        box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        border: 2px dashed #b8860b;
        padding: 10px;
        box-sizing: border-box;
        gap: 10px;
    }
    @media (max-width: 650px) {
      #display-area {
        width: 96vw;
        min-width: unset;
        min-height: 80px;
      }
    }

    .display-group {
        display: flex;
        gap: 5px;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 8px;
        padding: 5px 10px;
        border: 1px solid #d4a762;
    }

    .display-card {
        background: #fffdf7;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        border: 2px solid #a0522d;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        opacity: 1;
        transition: opacity 0.3s ease-out;
    }
    .display-card.matched-display {
        opacity: 0;
    }

    #curtain {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.95);
        z-index: 1050;
        display: none;
        border-radius: 15px;
        transition: opacity 0.5s ease-in-out;
        overflow: hidden;
        opacity: 1;
    }

    #curtain::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #f7f0e8, #e0d8cf);
        opacity: 0.9;
    }

    #curtain.open {
        opacity: 0;
        pointer-events: none;
    }

    #curtain.closed {
        opacity: 1;
        pointer-events: all;
    }

    #cat-path {
        position: absolute;
        width: 100%;
        height: 20px;
        left: 0;
        z-index: 1060;
        pointer-events: none;
        overflow: visible;
    }

        @keyframes cat-walk {
        0% { left: 0; transform: scaleX(1); }
        49% { transform: scaleX(1); }
        50% { left: calc(100% - 95px); transform: scaleX(-1); }
        99% { transform: scaleX(-1); }
        100% { left: 0; transform: scaleX(1); }
    }

    #walking-cat {
        position: absolute;
        width: 95px;
        height: 71px;
        display: flex;
        z-index: 10;
        align-items: center;
        justify-content: center;
        top: -30px;
        animation: cat-walk 15s linear infinite;
        --cat-width: 95px;
    }

    #walking-cat img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }

    .path-decoration {
        position: absolute;
        bottom: -5px;
        font-size: 23px;
        transition: transform 0.2s ease-in-out;
        z-index: 9;
    }
    .path-decoration.shaking {
        animation: gentle-shake 0.5s ease-in-out infinite alternate;
    }
    @keyframes gentle-shake {
        0% { transform: rotate(-2deg) scale(1.05); }
        100% { transform: rotate(2deg) scale(1); }
    }

    .wiggling-cat-instance {
        position: absolute;
        width: 29px;
        height: 29px;
        font-size: 29px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #5d4037;
        transform: translateX(-50%);
        animation: shake 1.8s ease-in-out infinite alternate;
        z-index: 10;
        pointer-events: none;
        display: none;
    }

    #card-stack-area {
      margin-top: 20px;
      max-width: 580px;
      aspect-ratio: 4 / 5;       /* å®½:é«˜ = 4:5ï¼Œå¯è‡ªè¡Œä¿®æ”¹ */
      max-height: 90vh;          /* é¿å…è¿‡é«˜ç›–ä½å·¥å…·æ  */
      position: relative;
      background: rgba(240, 230, 210, 0.6);
      border-radius: 15px;
      box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
      overflow: visible;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px dashed #b8860b;
      perspective: 1500px;
    }
    @media (max-width: 650px) {
      #card-stack-area {
        width: 96vw;
        min-width: unset;
        height: 60vh;
        max-height: 420px;
        margin-top: 15px;
        margin-bottom: 15px;
      }
    }
    @media (min-width: 701px) {
      #card-stack-area {
        height: 600px;
        max-height: 60vh;
      }
    }
    #blinking-cat {
      position: absolute;
      bottom: 10px;
      right: 10px;
      font-size: 1.2rem;
      z-index: 1000;
      pointer-events: none;
      color: #ff69b4;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
      opacity: 0;
      transform: scale(1);
      transition: opacity 0.3s ease;
    }

    @keyframes blink-cat {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    #card-stack-lid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7e9d7;
        border: 2px dashed #b8860b;
        border-radius: 15px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-around;
        padding: 20px;
        box-sizing: border-box;
        color: #6e352f;
        transform-origin: top center;
        font-family: 'ZCOOL KuaiLe', cursive;
    }
    #card-stack-lid .lid-text-top {
        font-size: 2rem;
        font-weight: bold;
    }
    #card-stack-lid .lid-emoji {
        font-size: 10rem;
        line-height: 1;
    }
    #card-stack-lid .lid-footer {
        font-size: 0.9rem;
    }

    #card-stack-area.level-starting #card-stack-lid {
        display: flex;
        animation: lid-open 4s ease-in-out forwards;
    }
    #card-stack-area.level-starting .card {
        visibility: hidden;
    }

    .card {
      background: var(--card-bg);
      border-radius: 10px;
      box-shadow: var(--card-shadow, 0 4px 10px rgba(0,0,0,0.1));
      border: var(--card-border);
      position: absolute;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
      transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.2s, border-color 0.15s;
      z-index: 1;
      overflow: hidden;
      color: var(--text-primary);
    }
	.card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.15), 0 0 5px rgba(180, 150, 180, 0.35);
    }
    .hint-animation {
      animation: show-card-property 2s forwards;
    }
    .card.selected {
      border: 3.5px solid #a0522d;
      box-shadow: 0 4px 20px rgba(160, 82, 45, 0.4), 0 0 25px rgba(255,255,0,0.5);
      z-index: 100 !important;
      transform: scale(1.01) rotate(-4deg);
    }
    .card.disabled {
      pointer-events: none;
      position: absolute;
      opacity: 1;
    }
    .card.disabled::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(128, 128, 128, 0.5);
      border-radius: 8px;
      z-index: 2;
      transition: background 0.5s ease;
    }
    .card.disabled > *:not(.disabled::before) {
        opacity: 0.5;
    }
    .card:not(.disabled):not(.matched):hover {
      transform: translateY(-5px) scale(1.05) rotate(2deg);
      box-shadow: 0 8px 20px rgba(0,0,0,0.15), inset 0 0 0 1px rgba(255,255,255,0.5);
      transition: transform 0.08s ease-out, box-shadow 0.05s ease-out;
      z-index: 2;
    }
    .card.matched {
      opacity: 0.05;
      transition: opacity 0.1s;
      pointer-events: none;
    }
    .card .mini {
      font-size: 1.2rem;
      position: absolute;
      bottom: 7px;
      right: 9px;
      opacity: 0.5;
      user-select: none;
    }
    
    .card.napping {
        pointer-events: none !important;
    }
    .card.napping::after {
        content: 'ğŸ’¤';
        position: absolute;
        top: -10px;
        right: -5px;
        font-size: 1.5rem;
        animation: wave 1.5s infinite ease-in-out;
        z-index: 5;
    }
    .card.napping::before {
        background: rgba(100, 100, 150, 0.3) !important;
    }

    #temp-area {
      margin: 20px auto 0 auto;
      display: flex;
      justify-content: space-evenly;
      align-items: center;
      min-height: 80px;
      width: 90%;
      max-width: 500px;
      border-radius: 12px;
      background: #fffcf0;
      border: 2px dashed #b8860b;
      padding: 8px 0;
      box-sizing: border-box;
      box-shadow: inset 0 1px 5px rgba(0,0,0,0.08);
    }
    .temp-slot {
      margin: 0;
      background: #fdf5e6;
      border-radius: 9px;
      border: 2px dashed #d4a762;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #92776c;
      box-shadow: inset 0 1px 4px rgba(0,0,0,0.05);
      position: relative;
      overflow: hidden;
      flex-shrink: 0;
    }
    .temp-card {
      width: 100%;
      height: 100%;
      background: var(--card-bg);
      border-radius: 9px;
      border: 2px solid var(--card-border);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(160, 82, 45, 0.3);
      cursor: default;
      position: absolute;
      transition: opacity 0.2s, border-color 0.2s, box-shadow 0.2s;
      box-sizing: border-box;
      color: var(--text-primary);;
    }
    .temp-card.matched {
      opacity: 0.05;
    }

    .flying-card {
      background: var(--card-bg);
      box-shadow: 0 4px 15px rgba(0,0,0,0.1), inset 0 0 0 1px rgba(255,255,255,0.5);
      border: var(--card-border);
      position: fixed;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      z-index: 10000;
      transition-property: top, left, transform;
      transition-timing-function: ease-out;
      overflow: hidden;
      color: var(--text-primary);
    }

    /* ... å…¶ä»–æ‰€æœ‰CSSæ ·å¼ä¿æŒä¸å˜ ... */
    #tools-bar {
      margin: 20px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 18px;
      width: 90%;
      max-width: 500px;
      flex-wrap: wrap;
    }
    #tools-bar button {
      padding: 9px 18px;
      background: var(--btn-bg);
      border: 2px solid #b8860b;
      border-radius: 10px;
      border-color: var(--btn-border);
      font-size: 1.05rem;
      color: var(--text-accent);
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      outline: none;
      position: relative;
      min-width: 75px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      font-family: 'ZCOOL KuaiLe', cursive;
    }
    #tools-bar button:hover {
      background: var(--btn-hover-bg);
      transform: translateY(-1px);
    }
    #tools-bar button:disabled {
      background: #f0f0f0;
      color: #b0b0b0;
      border-color: #d0d0d0;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    #restart-btn {
      background: #ffe0b3;
      border-color: #ffcc80;
      color: #96602c;
    }
    #restart-btn:hover {
      background: #ffd599;
    }

    #code-bar {
      margin: 15px auto 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 90%;
      max-width: 450px;
    }
    #code-bar input {
      flex-grow: 1;
      max-width: 180px;
      padding: 7px 10px;
      border-radius: 8px;
      border: 2px solid #b8860b;
      outline: none;
      font-size: 1.05rem;
      color: #5d4037;
      background: #fffdf7;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      font-family: 'ZCOOL KuaiLe', cursive;
    }
    #code-bar input::placeholder {
      color: #a0a0a0;
    }
    #code-bar button {
      padding: 7px 12px;
      font-size: 1.05rem;
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 9px;
      cursor: pointer;
      color: #3e5a2b;
      font-weight: bold;
      transition: background 0.15s;
      min-width: 65px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.1);
      font-family: 'ZCOOL KuaiLe', cursive;
    }
    #code-bar button:hover {
      background: #d2e5bb;
    }

    #message-bar {
      margin: 15px auto 0 auto;
      text-align: center;
      font-size: 1.1rem;
      color: #c0392b;
      min-height: 28px;
      font-weight: bold;
      letter-spacing: 1.2px;
    }

    #event-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2200;
        pointer-events: none;
    }
    #event-message-box {
        background: rgba(255, 253, 247, 0.9);
        padding: 20px 30px;
        border-radius: 15px;
        border: 3px solid #b8860b;
        box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        text-align: center;
        animation: fade-in-out-scale 3.5s forwards;
    }
    #event-message-box p {
        font-size: 1.3rem;
        color: #6e352f;
        margin: 0;
        font-weight: bold;
        text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
    }
    #event-message-box .event-icon {
        font-size: 2rem;
        margin-bottom: 10px;
    }

    #start-screen, #game-over, #level-finish {
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      z-index: 1100;
      background: rgba(255,255,255,0.98);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 1.1rem;
      border-radius: 25px;
      text-align: center;
    }
    #level-finish {
      justify-content: flex-start;
    }
    #level-finish > * {
      margin-top: 30%;
    }
    #start-screen {
      padding-top: 10vh;
      overflow: hidden;
      box-sizing: border-box;
    }
    
    #start-screen-video {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        z-index: -1;
        opacity: 0.99;
        object-fit: cover; 
    }

    #start-screen::before {
      content: "";
      position: absolute;
      left: 0; right: 0; top: 0; bottom: 0;
      background-image: url('mao.webp');
      background-size: cover;
      background-position: center;
      opacity: 0.5;
      z-index: -2;
    }
    #start-screen h1 {
      font-size: clamp(3rem, 12vw, 5rem);
      margin: 0 0 25px 0;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
      display: inline-block;
    }
    #start-screen h1 span {
      display: inline-block;
      animation: wave 2s infinite ease-in-out;
    }
    #start-screen h1 span:nth-child(1) { animation-delay: -0.4s; }
    #start-screen h1 span:nth-child(2) { animation-delay: -0.2s; }
    #start-screen h1 span:nth-child(3) { animation-delay: 0s; }
    #start-screen h1 span:nth-child(4) { animation-delay: 0.2s; }
    #start-screen h1 span:nth-child(5) { animation-delay: 0.4s; }
    #start-screen .start-btn {
      margin-top: 30px;
      padding: 15px 50px;
      font-size: 1.4rem;
      background: linear-gradient(90deg, #a0c388, #88b368);
      border: none;
      border-radius: 15px;
      color: #3e5a2b;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(160, 195, 136, 0.5);
      animation: pulse-scale 1.5s infinite ease-in-out;
      transition: background 0.2s, transform 0.1s;
      font-family: 'ZCOOL KuaiLe', cursive;
    }
    #start-screen .start-btn:hover {
      background: linear-gradient(90deg, #88b368, #a0c388);
      transform: translateY(-2px);
    }
    #start-screen p {
        color: #5d4037;
        line-height: 1.6;
        margin: 0 40px 15px;
        margin-top: 15vh;
    }
    #start-screen span {
        color: #c0392b;
        font-weight: bold;
    }

    .loading-footer {
        color: #795548;
        font-size: 0.85rem;
        position: absolute;
        bottom: 30px;
        left: 0;
        right: 0;
        text-align: center;
        letter-spacing: 1.5px;
        text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
    }

    #level-finish, #game-over {
      font-size: 1.8rem;
      color: #5d4037;
      background: rgba(255,243,245,0.99);
      border-radius: 25px;
      position: absolute;
      overflow: hidden;
      border: 3px solid #8B4513;
      box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
    }
    
    #game-over {
      overflow: hidden;
    }
    #game-over-content {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: -30%;
      animation: wave 2s infinite;
    }
    .cloud-layer {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .cloud-layer::before,
    .cloud-layer::after {
      content: 'ğŸŒ§ï¸';
      position: absolute;
      opacity: 0.88;
      color: #888;
      animation-name: cloud-pass;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }
    .cloud-layer::before {
      font-size: 120px;
      top: 10%;
      animation-duration: 20s;
      animation-delay: -5s;
    }
    .cloud-layer::after {
      font-size: 80px;
      top: 25%;
      animation-duration: 15s;
    }
    #game-over > * {
      position: relative;
      z-index: 1;
    }

    #level-finish::before, #game-over::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background-image: url('mao1.webp');
      background-size: cover;
      background-position: center;
      opacity: 0.4;
      z-index: -1;
    }
    #level-finish button, #game-over button {
      margin-top: 20px;
      padding: 12px 35px;
      font-size: 1.25rem;
      background: #e6f6d3;
      border: 2px solid #a0c388;
      border-radius: 12px;
      color: #3e5a2b;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      font-family: 'ZCOOL KuaiLe', cursive;
    }
    #level-finish button:hover, #game-over button:hover {
      background: #d2e5bb;
      transform: translateY(-1px);
    }
    #retry-btn {
      margin-top: 18px;
      padding: 10px 30px;
      font-size: 1.15rem;
      background: #f7e9d7;
      border: 2px solid #d4a762;
      border-radius: 10px;
      color: #6e352f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      display: inline-block;
      box-shadow: 0 1px 5px rgba(0,0,0,0.1);
    }
    #retry-btn:hover {
      background: #f0e1d0;
      transform: translateY(-1px);
    }

    #retry-btn2,
    #next-btn {
       animation: button-scale-pulse 1.5s infinite ease-in-out;
    }

    #footer {
      margin: 20px auto 20px auto;22:31 2025/8/3
      width: 100%;
      text-align: center;
      font-size: 1rem;
      color: #8B4513;
      letter-spacing: 1.5px;
      text-shadow: 0.5px 0.5px 0 rgba(255,255,255,0.5);
    }

    .hinted-shake {
      animation: shake 0.5s ease-in-out 4;
    }

    .modal-overlay {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 2500;
        display: none;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background: #fffdf7;
        padding: 30px 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        border: 3px solid #d4a762;
    }
    .modal-content p {
        font-size: 1.2rem;
        color: #5d4037;
        margin: 0 0 25px 0;
        font-weight: bold;
    }
    .modal-content button {
        padding: 9px 25px;
        background: #f7e9d7;
        border: 2px solid #b8860b;
        border-radius: 10px;
        font-size: 1.05rem;
        color: #6e352f;
        font-weight: bold;
        cursor: pointer;
        margin: 0 10px;
        transition: background 0.15s, transform 0.1s;
        font-family: 'ZCOOL KuaiLe', cursive;
    }
    #confirm-yes {
        background: #e6f6d3;
        border-color: #a0c388;
        color: #3e5a2b;
    }
    #confirm-yes:hover {
        background: #d2e5bb;
    }
    #confirm-no:hover {
        background: #e9d9c6;
    }

    #level-finish-text {
      color: #3e2723;
      font-size: 1.2em;
      text-align: center;
      margin-top: 20px;
      margin-bottom: 0px;
    }

    #loading-screen {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: 1199;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #f7f0e8;
      background-size: cover;
      transition: opacity 0.5s ease-out;
      border-radius: 25px;
      overflow: hidden;
    }
    #loading-screen::before {
      content: '';
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background-image: url('mao3.webp');
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      opacity: 0.6;
    }
    .loading-content {
      position: relative;
      z-index: 1001;
      text-align: center;
      width: 80%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      height: 100%;
      align-items: center;
      justify-content: flex-start;
      padding-top: 10vh;
      box-sizing: border-box;
    }
    .loading-title {
      font-size: 2.8rem;
      margin: 0 0 40px 0;
      color: #3e2723;
      letter-spacing: 3px;
      text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
      animation: pulse-scale 1.5s infinite ease-in-out;
    }
    .loading-title::after {
      content: ".";
      animation: text-progress 2s infinite;
    }
    .progress-bar-container {
      width: 100%;
      height: 30px;
      background: rgba(184, 134, 11, 0.2);
      border-radius: 10px;
      border: 2px solid #b8860b;
      overflow: hidden;
      margin-bottom: 15px;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
      margin-top: 30vh;
      z-index: 1004;
    }
    #progress-bar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #a0c388, #88b368);
      border-radius: 8px;
      transition: width 0.3s ease-out;
    }
    #loading-text {
      font-size: 1.1rem;
      color: #5d4037;
      margin-bottom: 40px;
      min-height: 20px;
      text-align: center;
    }

    .responsive-video-container {
        position: relative;
        width: 100%;
        max-width: 660px;
        padding-bottom: 68.1818%;
        height: 0;
        overflow: hidden;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .responsive-video-container iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 0;
        border-radius: 10px;
    }

    #level2-outro-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 25px;
        overflow: hidden;
    }

    #level2-outro-screen video,
    #level2-outro-screen img {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        object-fit: cover;
        border-radius: 0;
        box-shadow: none;
    }
    #level2-outro-screen .loading-text {
        color: white;
        font-size: 1.5rem;
        margin-top: 20px;
    }

    #skip-outro-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 8px;
        font-size: 1rem;
        color: #333;
        cursor: pointer;
        z-index: 2001;
        transition: background 0.2s, transform 0.2s;
    }
    #skip-outro-btn:hover {
        background: rgba(255, 255, 255, 0.9);
        transform: scale(1.05);
    }

    @media (max-width: 500px) {
      #card-stack-area, #temp-area, #tools-bar, #code-bar { width: 98vw; }
      #tools-bar button {
          min-width: unset;
          width: 30%;
          margin-bottom: 8px;
          padding: 8px 10px;
          font-size: 0.95rem;
      }
      #tools-bar {
          gap: 6px;
      }
      #temp-area {
        width: 98vw;
        margin: 15px auto 0 auto;
      }
      #code-bar input {
        width: 50%;
      }
      #display-area {
        width: 96vw;
        padding: 5px;
      }
      #level-finish, #game-over {
        font-size: 1.2rem;
        padding: 20px;
        box-sizing: border-box;
      }

      #level-finish button, #game-over button, #retry-btn {
          font-size: 1rem;
          padding: 10px 20px;
      }

      #level-finish-text {
          font-size: 1em;
      }
    }
:root {
  /* é€šç”¨ */
  --bg-base: #f7f0e8;
  --panel-bg: rgba(240,230,210,0.6);
  --panel-border: #b8860b;
  --card-bg: #fffdf7;
  --card-border: #d4a762;
  --text-primary: #3e2723;
  --text-accent: #6e352f;
  --btn-bg: #f7e9d7;
  --btn-border: #b8860b;
  --btn-hover-bg: #e9d9c6;
}

.theme-starry-night {
  /* èƒŒæ™¯é‡‡ç”¨æ˜Ÿå¤œç”»å¸ƒè´¨æ„Ÿè‰²è°ƒï¼šæ·±è“å’Œç‚¹ç¼€é»„ */
  --bg-base: radial-gradient(circle at 30% 30%, #1f2a3b, #0e1830); /* æ—‹æ¶¡åº•è‰² */
  
  /* åŠé€æ˜é¢æ¿ï¼Œå¦‚ç”»å¸ƒä¸Šçš„å…‰æ™•æ˜Ÿçƒ */
  --panel-bg: rgba(32, 48, 77, 0.65);
  --panel-border: #f4d35e; /* æ˜äº®æ˜Ÿå…‰è¾¹æ¡† */

  /* å¡ç‰‡è®¾ä¸ºæ²¹ç”»è´¨æ„Ÿæ·±è“ï¼Œæ­é…æŸ”é»„çš„å…‰å½±æŠ•å½± */
  --card-bg: #273e60; 
  --card-border: transparent; /* å–æ¶ˆå®ä½“è¾¹æ¡†ï¼Œä½¿ç”¨é˜´å½±æ›¿ä»£ */
  --card-shadow: 0 6px 14px rgba(244, 211, 94, 0.35);

  /* æ–‡æœ¬è‰²ä¸ºæŸ”ç™½ä¸æ˜Ÿå…‰é»„å½¢æˆå¯¹æ¯” */
  --text-primary: #fffaf3;
  --text-accent: #f4d35e;

  /* æŒ‰é’®ä¸ºäº®è“åº•ï¼Œhoverå‘ˆç°æ·¡é»„äº®æ™• */
  --btn-bg: #3a5f9b;
  --btn-border: transparent;
  --btn-hover-bg: #4b6fa9;

  /* é¢å¤–ç‚¹ç¼€ï¼šå¯åœ¨å¡ç‰‡ hover æ—¶åŠ å…¥è½»å¾®æ—‹æ¶¡åŠ¨ç”»æˆ–æ™•æŸ“æ•ˆæœ */
}

.theme-renaissance {
  --bg-base: linear-gradient(135deg, #fdf7f3, #f9f3eb);          /* ç±³ç™½èƒŒæ™¯ */
  --panel-bg: rgba(250, 240, 230, 0.6);                          /* é¢æ¿åŠé€ */
  --panel-border: #d4b8a8;                                       /* ç±³æ£•è¾¹æ¡† */
  --card-shadow: 0 6px 14px rgba(250, 180, 190, 0.35);         /* ç²‰çº¢æ¸å±‚ */
  --card-shadow: 0 6px 14px rgba(250, 180, 190, 0.35);           /* ç²‰å…‰æ™• */
  --text-primary: #5f4b57;
  --text-accent: #c98596;
  --btn-bg: #f8e8ea;
  --btn-hover-bg: #f0d8dc;
  --grad-aurora: linear-gradient(135deg, #fbf5ef, #f6ede9, #f0e6d6);
}


/* å¦‚æœä½ å¸Œæœ› display-area å’Œ temp-area çš„æ¸å˜è¾¹æ¡†ä¹Ÿæ›´â€œç´«â€ä¸€äº›ï¼Œä¿ç•™åŸç»“æ„ï¼Œä»…ç”±å˜é‡æ‰˜åº•å³å¯ */
.theme-renaissance #display-area,
.theme-renaissance #temp-area {
  /* ä¿æŒåŸæœ‰å†™æ³•ï¼Œå˜é‡å·²ç”Ÿæ•ˆ */
}

/* å…³å¡å®Œæˆå±‚æœ¬å°±å¼•ç”¨äº† --grad-auroraï¼Œæ— éœ€æ”¹ç»“æ„ */
.theme-renaissance #level-finish {
  /* èƒŒæ™¯ä»ä½¿ç”¨ var(--grad-aurora) */
}
/* å®¹å™¨ï¼šé›¾é¢ç»ç’ƒ + æ¸å˜è¾¹æ¡†ï¼ˆè¦†ç›–åŸ dashedï¼‰ */
.theme-renaissance #temp-area {
  background:
    linear-gradient(0deg, rgba(255,255,255,.45), rgba(255,255,255,.25)) padding-box,
    var(--grad-aurora) border-box;
  border: 1.5px solid transparent;     /* ç”¨èƒŒæ™¯æ¨¡æ‹Ÿå½©è‰²è¾¹æ¡† */
  border-radius: 16px;
  box-shadow: var(--shadow-soft);
  backdrop-filter: blur(10px) saturate(1.05);
}

/* æ§½ä½ï¼šä¸ç»¸å¾®å…‰ + æ¸å˜è¾¹æ¡† */
.theme-renaissance #temp-area .temp-slot {
  background:
    linear-gradient(0deg, rgba(255,255,255,.60), rgba(255,255,255,.35)) padding-box,
    linear-gradient(120deg, #f6e6e9, #d9efe6) border-box;
  border: 1px solid transparent;       /* è¦†ç›– dashedï¼Œä¸ºå…‰æ»‘è¾¹æ¡† */
  box-shadow: inset 0 1px 4px rgba(0,0,0,0.05);
  transition: transform var(--t-fast) var(--ease), box-shadow var(--t-fast) var(--ease);
}
.theme-renaissance #temp-area .temp-slot:hover {
  transform: translateY(-1px);
  box-shadow: inset 0 1px 6px rgba(0,0,0,0.07), 0 6px 12px rgba(90,74,83,.12);
}

/* æ¸…ç©ºé—ªå…‰ï¼ˆå¤ç”¨ä½ å·²æœ‰çš„ .clearing åŠ¨ç”»åï¼‰ */
.theme-renaissance .temp-slot.clearing {
  animation: slot-flash 0.45s ease-out;
}

/* ç‰Œï¼šæ¸©æš–çº¸å¼  + æŸ”å½± */
.theme-renaissance #temp-area .temp-card {
  background: var(--card-bg)
  border: 2px solid var(--card-border);
  color: var(--text-primary);
  box-shadow: 0 4px 12px rgba(160,82,45,.25);
}

/* ä¸‰æ¶ˆåæ¶ˆé€€ï¼ˆæ²¿ç”¨ä½ çš„ .vanishingï¼‰ */
.theme-renaissance .temp-card.vanishing {
  animation: card-vanish 0.55s ease-out forwards;
}
/* å®¹å™¨ï¼šæŸ”å½©ç”»å¸ƒ + æ¸å˜è¾¹æ¡†ï¼ˆè¦†ç›–åŸ dashedï¼‰ */
.theme-renaissance #card-stack-area {
  background:
    linear-gradient(180deg, rgba(236,228,241,0.58), rgba(236,228,241,0.38)) padding-box;
  border: 1px solid transparent;
  border-radius: 18px;
  box-shadow: 0 8px 18px rgba(90,74,83,0.18);
  backdrop-filter: blur(8px) saturate(1.05);
}

/* ç›–å­ï¼šä¸ç»¸æ¸å˜ + å…‰æ³½è¾¹æ¡† */
.theme-renaissance #card-stack-lid {
  background:
    linear-gradient(180deg, rgba(255,255,255,.6), rgba(255,255,255,.35)) padding-box,
    linear-gradient(135deg, #f6e6e9, #d9efe6, #fff3e6) border-box;
  border: 2px solid transparent;
  color: var(--text-primary);
  text-shadow: 0 1px 0 rgba(255,255,255,.4);
}
/* å¡ç‰‡æ•´ä½“ï¼šæŸ”é›¾æ¸å±‚ + æŠ½è±¡çº¸æ„Ÿçº¹ç† */
.theme-renaissance .card {
  background:
    linear-gradient(180deg, #fdfcf9, #f7f1e8),
    repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.07) 0 2px, transparent 2px 6px),
    repeating-linear-gradient(-45deg, rgba(240, 220, 230, 0.06) 0 3px, transparent 3px 6px);
  box-shadow: 0 4px 10px rgba(190, 160, 180, 0.18);
  border-radius: 10px;
  border: none;
  transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
}
.theme-renaissance .card:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 0 10px 20px rgba(190, 160, 180, 0.2);
}
.theme-renaissance .card.matched {
  opacity: 0.08;
  transform: scale(0.95);
}
.theme-renaissance .temp-card,
.theme-renaissance .flying-card {
  background:
    linear-gradient(180deg, #fdfcf9, #f7f1e8),
    repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.07) 0 2px, transparent 2px 6px),
    repeating-linear-gradient(-45deg, rgba(240, 220, 230, 0.06) 0 3px, transparent 3px 6px);
  box-shadow: 0 4px 10px rgba(190, 160, 180, 0.18);
  border-radius: 10px;
  border: none;
}

/* æ‚¬åœæµ®èµ·ï¼šæ— è¾¹æ¡†ï¼Œä»…è½»æŸ”æµ®åŠ¨ä¸å…‰æ™• */
.theme-renaissance .card:not(.disabled):not(.matched):hover {
  transform: translateY(-6px) scale(1.04) rotate(1.5deg);
  box-shadow: 0 12px 24px rgba(90, 74, 83, 0.2), 0 0 12px rgba(255, 228, 202, 0.3);
}

/* é€‰ä¸­æ€ï¼šé‡‘ç²‰å…‰æ™•ã€å¾®æŠ¬å‡ï¼Œä¸æ¢å¤è¾¹æ¡† */
.theme-renaissance .card.selected {
  box-shadow: 0 0 0 4px rgba(210, 160, 120, 0.35), 0 12px 24px rgba(90, 74, 83, 0.22);
  transform: scale(1.02) rotate(-2.5deg);
}

/* æ‰“ç›¹æ€é®ç½©ä¼˜åŒ–ï¼šæŸ”é›¾ç½©å±‚ */
.theme-renaissance .card.napping::before {
  background: rgba(90, 74, 83, 0.18) !important;
}

.theme-renaissance .card.napping::after {
  filter: drop-shadow(0 2px 4px rgba(0,0,0,.15));
}
/* èƒŒæ™¯ï¼šæå…‰æ¸å˜ + è½»å¾®è‰²ç›¸æµåŠ¨ */
@keyframes lfHue {
  0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(18deg); }
}
.theme-renaissance #level-finish {
  background:
    radial-gradient(120% 100% at 50% 10%, rgba(255,255,255,.35), transparent 60%),
    var(--grad-aurora);
  border: 2px solid transparent;
  background-clip: padding-box, border-box;
  animation: lfHue 10s linear infinite;
  color: var(--text-primary);
  box-shadow: 0 14px 28px rgba(90,74,83,.22), 0 2px 6px rgba(90,74,83,.12);
}

/* å åŠ ä¸€å±‚è–„çº±ï¼Œä¸è¦†ç›–ä½ å·²æœ‰çš„ ::before å›¾ç‰‡å±‚ */
.theme-renaissance #level-finish::after {
  content: "";
  position: absolute; inset: 0;
  pointer-events: none;
  background:
    radial-gradient(circle at 20% 30%, rgba(255,255,255,.22), transparent 40%),
    radial-gradient(circle at 80% 20%, rgba(255,255,255,.16), transparent 45%),
    repeating-linear-gradient(45deg, rgba(255,255,255,.05) 0 2px, transparent 2px 6px);
  mix-blend-mode: screen;
}

/* æ ‡é¢˜ï¼šæµå…‰æ–‡å­—ï¼ˆä¸æ”¹å˜ä½ çš„ç»“æ„ï¼Œç›´æ¥ç¾åŒ– #level-finish-textï¼‰ */
@keyframes textShimmer {
  0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
}
.theme-renaissance #level-finish-text {
  font-weight: 700;
  letter-spacing: .4px;
  background: linear-gradient(90deg, #5f4b57, #c98596, #5f4b57);
  -webkit-background-clip: text; background-clip: text; color: transparent;
  background-size: 200% 100%;
  animation: textShimmer 3s ease-in-out infinite;
  text-shadow: none;
}

/* æŒ‰é’®ï¼šä¸ç¼æ¸å˜ + è½»æµ®åŠ¨ */
.theme-renaissance #level-finish button {
  background:
    linear-gradient(0deg, rgba(255,255,255,.7), rgba(255,255,255,.45)) padding-box,
    linear-gradient(120deg, #f6e6e9, #d9cbe8, #d9efe6) border-box;
  border: 1px solid transparent;
  color: var(--text-primary);
  box-shadow: 0 6px 14px rgba(90,74,83,.18);
  transition: transform var(--t-fast) var(--ease), box-shadow var(--t-fast) var(--ease);
}
.theme-renaissance #level-finish button:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 18px rgba(90,74,83,.22);
}

/* ç¤¼èŠ±ï¼šæ›´ç»†è…»çš„å½©ç‰‡ï¼ˆä¿ç•™ä½ çš„ç”Ÿæˆé€»è¾‘ï¼Œä»…ç¾åŒ–å¤–è§‚ï¼‰ */
.theme-renaissance .confetti-piece {
  width: 7px; height: 14px; border-radius: 2px;
  box-shadow: 0 0 8px rgba(255,255,255,.35);
  opacity: .95;
}
/* å¯é€‰ï¼šdisplay-area ä¹Ÿèµ°ç»ç’ƒä¸æ¸å˜è¾¹æ¡†ï¼Œä¿æŒæ•´ä½“ä¸€è‡´ */
.theme-renaissance #display-area {
  background:
    linear-gradient(0deg, rgba(255,255,255,.45), rgba(255,255,255,.25)) padding-box,
    var(--grad-aurora) border-box;
  border: 1.5px solid transparent;
  border-radius: 15px;
  box-shadow: var(--shadow-soft);
  backdrop-filter: blur(8px) saturate(1.03);
}
.theme-renaissance #display-area .display-group {
  background: rgba(255,255,255,.55);
  border: 1px solid rgba(177,154,132,.35);
}
.theme-renaissance #display-area .display-card {
  background:
    radial-gradient(120% 100% at 10% 0%, rgba(255,255,255,.7), transparent 60%),
    linear-gradient(180deg, #fffdf7, #f7efe7);
  border: 2px solid var(--card-border);
  color: var(--text-primary);
  box-shadow: 0 4px 10px rgba(0,0,0,.12);
}
@media (prefers-reduced-motion: reduce) {
  .theme-renaissance #level-finish,
  .theme-renaissance #level-finish-text,
  .theme-renaissance .confetti-piece {
    animation: none !important;
  }
  .theme-renaissance #card-stack-area .card,
  .theme-renaissance #temp-area,
  .theme-renaissance #temp-area .temp-slot {
    transition: none !important;
  }
}


  </style>
  <link rel="stylesheet" href="font/iconfont.css">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
<!-- HTML ç»“æ„ä¿æŒä¸å˜ -->
<div id="game-container">
  <div id="loading-screen">
    <div class="loading-content">
      <h1 class="loading-title">å–µå–µåŠ è½½ä¸­.</h1>
      <div class="progress-bar-container">
        <div id="progress-bar"></div>
      </div>
      <p id="loading-text">æ­£åœ¨åˆæ¬¡åŠ è½½èµ„æºï¼Œè¯·ç­‰å¾…...</p>
      <small class="loading-footer">è¶…çº§å–µå–µ &copy; 2025 | Designed by å¼€å…ƒ</small>
    </div>
  </div>

  <div id="header-bar">
    <div id="progress-info">
        <span id="level-info">å…³å¡: 1 / 2</span>
        <span class="score-display">åˆ†æ•°: <span id="current-score">0</span></span>
        <span class="target-display">ç›®æ ‡: <span id="target-score">0</span></span>
    </div>
    <button id="music-toggle" title="éŸ³ä¹å¼€å…³">ğŸ¼</button>
  </div>
  <div id="main-area">
    <div id="display-area">
        </div>
    <div id="curtain"></div>
    <div id="cat-path">
        <div id="walking-cat"><img src="run.gif" alt="Walking Cat"></div>
        <span class="path-decoration" style="left: 20%;">ğŸ’Œ</span>
        <span class="path-decoration" style="left: 40%;">ğŸŒ¿</span>
        <span class="path-decoration" style="left: 60%;">â˜˜ï¸</span>
        <span class="path-decoration" style="left: 80%;">ğŸŒ¼</span>
    </div>
    <div id="card-stack-area"></div>
    <div id="wiggling-cat-1" class="wiggling-cat-instance">ğŸ¥³</div>
    <div id="wiggling-cat-4" class="wiggling-cat-instance">ğŸ‰</div>
    <div id="wiggling-cat-7" class="wiggling-cat-instance">ğŸ€</div>
	<div id="blinking-cat">ğŸ˜º</div>

    <div id="temp-area">
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
      <div class="temp-slot"></div>
    </div>
    <div id="tools-bar">
      <button id="undo-btn" disabled title="æ’¤é”€(éœ€å…‘æ¢ç )">â†©ï¸ æ’¤é”€ (<span id="undo-count">0</span>)</button>
      <button id="hint-btn" disabled title="æç¤º(éœ€å…‘æ¢ç )"> æç¤ºğŸ’¡ (<span id="hint-count">0</span>)</button>
      <button id="shuffle-btn" disabled title="æ´—ç‰Œ(éœ€å…‘æ¢ç )"> æ´—ç‰ŒğŸ”€ (<span id="shuffle-count">0</span>)</button>
      <button id="revive-btn" disabled title="å¤æ´»(éœ€å…‘æ¢ç )">ğŸ’– å¤æ´» (<span id="revive-count">0</span>)</button>
      <button id="restart-btn" title="é‡æ–°å¼€å§‹å½“å‰å…³å¡"> ğŸ”„é‡æ–°å¼€å§‹</button>
      <button id="auto-collect-btn" title="è‡ªåŠ¨æ”¶é›†(éœ€å…‘æ¢ç )" disabled> è‡ªåŠ¨ğŸª½ (<span id="auto-collect-count">0</span>)</button>
    </div>
    <div id="code-bar">
      <input type="text" id="code-input" placeholder="å…‘æ¢ç " maxlength="12">
      <button id="code-btn">å…‘æ¢</button>
    </div>
    <div id="message-bar"></div>
  </div>
  <div id="footer">
    <p>è¶…çº§å–µå–µ &copy; 2025 | Designed by å¼€å…ƒ</p>
  </div>

  <div id="event-overlay">
      <div id="event-message-box">
          <div class="event-icon"></div>
          <p class="event-text"></p>
      </div>
  </div>

  <div id="start-screen">
    <video id="start-screen-video" autoplay loop muted playsinline>
      <source src="mao.webm" type="video/webm">
      <source src="aimao.mp4" type="video/mp4">
      <img src="mao.webp" alt="èƒŒæ™¯å›¾">
    </video>
    <h1><span>è¶…</span><span>çº§</span><span>å–µ</span><span>å–µ</span><span>ğŸ§¶</span></h1>
    <p> </p> <p>
      <button class="start-btn" id="start-btn">å¼€å§‹æ¸¸æˆ</button>
    </p>
    <p>æ”¶é›†å¡ç‰Œè·å¾—åˆ†æ•°ã€å…¨éƒ¨æ¸…ç©ºè¿‡å…³<br>
    <span style="color:#c0392b;">ç¬¬äºŒå…³éš¾åº¦ç•¥æœ‰å‡çº§<br></span>å¯ä½¿ç”¨å…‘æ¢ç è§£é”é“å…·</p>
    <small class="loading-footer">è¶…çº§å–µå–µ &copy; 2025 | Designed by å¼€å…ƒ</small>
  </div>

  <div id="level2-outro-screen" style="display:none;">
    <video id="outro-video" playsinline muted>
        <source src="mao2.mp4" type="video/mp4">
        æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘æ’­æ”¾ã€‚
    </video>
    <img id="outro-image" src="mao2.webp" alt="Level 2 Outro Image" style="display:none;">
    <div class="loading-text" style="display:none;">æ­£åœ¨åŠ è½½...</div>
    <button id="skip-outro-btn" style="display:none;">è·³è¿‡åŠ¨ç”»</button>
  </div>

  <div id="level-finish" style="display:none;">
    <div id="netease-player" class="responsive-video-container" style="display:none;">
      <iframe allow="encrypted-media *; fullscreen *; clipboard-write" frameborder="0" height="450" style="width:100%;max-width:660px;overflow:hidden;border-radius:10px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation" src="https://player.bilibili.com/player.html?isOutside=true&aid=114878413148199&bvid=BV1X9uQz6E6v&cid=31143166462&p=1"></iframe>
    </div>
    <div id="player" style="display:none;">
        <div id="player-content1">
            <div class="music-name"></div>
            <div class="artist-name"></div>
            <div class="time">
                <div class="current-time"></div>
                <div class="total-time"></div>
            </div>
            <div id="s-area">
                <div id="ins-time"></div>
                <div id="s-hover"></div>
                <div id="seek-bar"></div>
            </div>
        </div>
        <div id="player-content2">
            <div class="music-imgs">
                <div class="img"></div>
                <div id="buffer-box">ç¼“å†²,ç¨ç­‰...</div>
            </div>
            <div class="player-controls">
                <div class="btn prev iconfont">î˜ƒ</div>
                <div class="btn play-pause icon-jiediankaishi iconfont"></div>
                <div class="btn next iconfont">î˜‚</div>
            </div>
        </div>
    </div>
    <div id="level-finish-text"></div>
    <button id="next-btn">ä¸‹ä¸€å…³</button>
    <button id="retry-btn" style="margin-left:10px;">é‡ç©</button>
    <button id="gobang-btn" style="margin-left:10px; display:none;">äº”å­æ£‹å¯¹å¼ˆ</button>
    <button id="restart-game-btn" style="margin-left:10px; display:none;">é‡å¼€æ¸¸æˆ</button>
    <button id="close-game-btn-level" style="margin-left:10px;">å…³é—­æ¸¸æˆ</button>
  </div>

  <div id="game-over" style="display:none;">
    <div class="cloud-layer"></div>
    <div id="game-over-content">
        <div id="game-over-text"></div>
        <button id="retry-btn2">é‡è¯•</button>
        <button id="revive-btn-gameover" style="margin-left:10px; display:none;">ğŸ’– å¤æ´»</button>
        <button id="close-game-btn-gameover" style="margin-left:10px;">å…³é—­æ¸¸æˆ</button>
    </div>
  </div>
</div>

<div id="confirm-modal" class="modal-overlay">
  <div class="modal-content">
    <p id="confirm-msg">ä½ ç¡®å®šå—ï¼Ÿ</p>
    <div class="modal-buttons">
        <button id="confirm-yes">ç¡®å®š</button>
        <button id="confirm-no">å–æ¶ˆ</button>
    </div>
  </div>
</div>

<audio id="bgm" loop preload="auto">
  æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘å…ƒç´ ã€‚
</audio>

<script src="js/jquery-3.4.1.min.js"></script>
<script src="js/index.js"></script>
<script>
// æ¸¸æˆé…ç½®å’Œé€»è¾‘éƒ¨åˆ†ä¿æŒä¸å˜
const CARD_ICONS = [
  "ğŸˆ", "ğŸ’", "ğŸ‘’", "ğŸµï¸", "ğŸ§¸", "ğŸ”®", "ğŸ¡", "ğŸˆâ€â¬›", "ğŸª­",
  "ğŸ–", "ğŸ§¶", "ğŸŒ»", "ğŸ’", "ğŸŒˆ", "ğŸ‚", "ğŸª·"
];
const LEVELS = [
  // Level 1 now has more cards to ensure a visible heart shape can be formed.
  {num: 1, visible: 15, total: 36, stack: 1, rows: 3, cols: 5, overlap: 20, targetScore: 25, totalDisplaySets: 12},
  {num: 2, visible: 15, total: 123, stack: 2, rows: 3, cols: 5, overlap: 20, targetScore: 100, totalDisplaySets: 30}
];
const TEMP_LIMIT = 7;
const DISPLAY_CARD_MATCH_SCORE = 5;
const INITIAL_DISPLAY_SETS_VISIBLE = 2;
const FLYING_SPEED_PPS = 1000;

const REDEMPTION_CODES = {
  "haogege": { undo: 20, hint: 20, shuffle: 20, autoCollect: 20 },
  "å…‘æ¢ç ": { undo: 5, hint: 5, shuffle: 5 },
  "æˆ–è€…å»é—®ä»–": { undo: 50, hint: 50, shuffle: 50, autoCollect: 40 },
  "kaiyuan": { autoCollect: 20 },
  "å¼€å…ƒ": { undo: 10, hint: 10, shuffle: 10 },
  "é€šå…³": { type: "skip_level" },
  "xianshi": { type: "curtain_off" },
  "shuaige": { revive: 3 }
};

// DOM å…ƒç´ è·å–éƒ¨åˆ†ä¿æŒä¸å˜
const bgm = document.getElementById('bgm');
const confirmModal = document.getElementById('confirm-modal');
const confirmMsg = document.getElementById('confirm-msg');
const confirmYes = document.getElementById('confirm-yes');
const confirmNo = document.getElementById('confirm-no');
const footer = document.getElementById('footer');
const musicToggleBtn = document.getElementById('music-toggle');
const startBtn = document.getElementById('start-btn');
const nextBtn = document.getElementById('next-btn');
const retryBtnLevelFinish = document.getElementById('retry-btn');
const retryBtnGameOver = document.getElementById('retry-btn2');
const gobangBtn = document.getElementById('gobang-btn');
const restartGameBtn = document.getElementById('restart-game-btn');
const closeGameBtnLevel = document.getElementById('close-game-btn-level');
const closeGameBtnGameOver = document.getElementById('close-game-btn-gameover');
const undoBtn = document.getElementById('undo-btn');
const hintBtn = document.getElementById('hint-btn');
const shuffleBtn = document.getElementById('shuffle-btn');
const reviveBtn = document.getElementById('revive-btn');
const reviveBtnGameOver = document.getElementById('revive-btn-gameover');
const restartCurrentLevelBtn = document.getElementById('restart-btn');
const codeInput = document.getElementById('code-input');
const codeBtn = document.getElementById('code-btn');
const levelFinishTextElement = document.getElementById('level-finish-text');
const neteasePlayerDiv = document.getElementById('netease-player');
const playerDiv = document.getElementById('player');
const currentScoreElement = document.getElementById('current-score');
const targetScoreElement = document.getElementById('target-score');
const levelInfoElement = document.getElementById('level-info');
const displayArea = document.getElementById('display-area');
const cardStackArea = document.getElementById('card-stack-area');
const catPath = document.getElementById('cat-path');
const walkingCat = document.getElementById('walking-cat');
const curtainElement = document.getElementById('curtain');
const wigglingCat1 = document.getElementById('wiggling-cat-1');
const wigglingCat4 = document.getElementById('wiggling-cat-4');
const wigglingCat7 = document.getElementById('wiggling-cat-7');
const level2OutroScreen = document.getElementById('level2-outro-screen');
const outroVideo = document.getElementById('outro-video');
const outroImage = document.getElementById('outro-image');
const outroLoadingText = level2OutroScreen.querySelector('.loading-text');
const skipOutroBtn = document.getElementById('skip-outro-btn');
const eventOverlay = document.getElementById('event-overlay');
const eventMessageBox = document.getElementById('event-message-box');
const eventIconEl = eventMessageBox.querySelector('.event-icon');
const eventTextEl = eventMessageBox.querySelector('.event-text');
const autoCollectBtn = document.getElementById('auto-collect-btn');
const autoCollectCountEl = document.getElementById('auto-collect-count');

// æ¸¸æˆçŠ¶æ€å’Œå·¥å…·å‡½æ•°ä¿æŒä¸å˜
let autoCollectCount = 0;
let autoCollectActive = false;
let autoCollectPaused = false; // æ ‡è®°è‡ªåŠ¨æ”¶é›†æ˜¯å¦è¢«ç©å®¶æ‰‹åŠ¨æš‚åœ
let autoCollectTimer = null;
let confirmCallback = null;
let outroVideoTimeout = null;
let decorationInterval = null;
let randomEventTimer = null;
let curtainTimer = null;
let isLandscape = false; 
let hasShownLandscapeMessage = false;
let lastShakeTime = 0;
let lastManualClickTime = 0;
let autoCollectIdleWatcher = null;

let audioContext;
let clickSoundBuffer;
let clickAudioFailed = false;

let game = {
  level: 1,
  levelStartTime: 0,
  cards: [],
  board: [],
  temp: [],
  matched: [],
  usedIcons: [],
  toolUses: {undo: 0, hint: 0, shuffle: 0, revive: 0},
  score: 0,
  targetScore: 0,
  displayCards: [],
  totalDisplaySetsGenerated: 0,
  progress: 0,
  stepStack: [],
  bgmOn: true,
  isNewLevel: false,
  lock: false,
  flyingCardCount: 0,
  cardDimensions: { width: 0, height: 0, fontSize: 0, borderRadius: 0, borderWidth: 0 },
  layout: { areaWidth: 0, areaHeight: 0 },
  autoCollectEnabled: false, 
  noShuffleCodePromptShown: false, // æ–°å¢ï¼šæœ¬å…³å·²æ˜¾ç¤ºè¿‡â€œå…‘æ¢ç è·å–æ´—ç‰Œæ¬¡æ•°â€çš„æç¤º
  isCurtainEnabled: true
};

function randArr(arr) { return arr.slice().sort(() => Math.random() - 0.5); }
function shuffle(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function randBetween(a, b) { return a + Math.random() * (b - a); }

async function initAudio() {
    try {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        if (!clickSoundBuffer) {
            const response = await fetch('kaa.mp3');
            const arrayBuffer = await response.arrayBuffer();
            clickSoundBuffer = await audioContext.decodeAudioData(arrayBuffer);
        }
    } catch (e) {
        console.error("Web Audio API failed for click sound (kaa.mp3). Falling back to HTML5 Audio.", e);
        clickAudioFailed = true;
    }
}
function toggleAutoCollect() {
  if (autoCollectActive) {
    // å¦‚æœæ­£åœ¨è¿è¡Œï¼Œåˆ™æš‚åœ
    autoCollectActive = false;
    autoCollectPaused = true;
    if (autoCollectTimer) {
      clearTimeout(autoCollectTimer);
      autoCollectTimer = null;
    }
    showMessage('è‡ªåŠ¨æ”¶é›†å·²æš‚åœ');
  } else {
    // å¦‚æœæœªè¿è¡Œï¼Œåˆ™å¼€å§‹
    if (autoCollectCount <= 0) {
      showMessage('è‡ªåŠ¨æ”¶é›†æ¬¡æ•°ä¸è¶³');
      return;
    }
    autoCollectActive = true;
    autoCollectPaused = false;
    showMessage('è‡ªåŠ¨æ”¶é›†å·²å¯åŠ¨', '#3e5a2b');
    autoCollectStep();
	startAutoCollectIdleWatcher(); // âœ… ç¡®ä¿è¿™ä¸€è¡Œå­˜åœ¨
  }
  updateAutoCollectStatus();
}
function stopAutoCollect() {
  autoCollectActive = false;
  autoCollectPaused = false;
  if (autoCollectTimer) {
    clearTimeout(autoCollectTimer);
    autoCollectTimer = null;
  }
  updateAutoCollectStatus();
}

function playBgm(on) {
  const bgmElement = document.getElementById('bgm');
  if (on) {
    if (bgmElement.src.indexOf('Sukidakara.mp3') === -1) {
      bgmElement.src = 'Sukidakara.mp3';
    }
    bgmElement.volume = 0.2; 
    const playPromise = bgmElement.play();
    if (playPromise !== undefined) {
      playPromise.catch(error => {
        console.log("BGM play failed, most likely due to browser autoplay policy.", error);
      });
    }
  } else {
    bgmElement.pause();
  }
}

function playClickSound() {
    if (!game.bgmOn) return;
    if (clickAudioFailed) {
        const clickAudio = new Audio('kaa.mp3');
        clickAudio.play().catch(e => console.error("HTML5 Audio fallback for click sound failed:", e));
    } else {
        if (!clickSoundBuffer || !audioContext) return;
        try {
            const source = audioContext.createBufferSource();
            source.buffer = clickSoundBuffer;
            source.connect(audioContext.destination);
            source.start(0);
        } catch (e) {
            console.error("Failed to play click sound via Web Audio API:", e);
        }
    }
}

function triggerMatchFeedback() {
    if (navigator.vibrate) {
        navigator.vibrate(100);
    }
    playClickSound();
}

function showConfirm(msg, callback) {
  confirmMsg.innerHTML = msg;
  confirmCallback = callback;
  confirmModal.style.display = 'flex';
}

function hideConfirm() {
  confirmModal.style.display = 'none';
  confirmCallback = null;
}

confirmYes.onclick = () => {
  const callback = confirmCallback;
  hideConfirm();
  if (callback) {
    setTimeout(callback, 20);
  }
};
confirmNo.onclick = hideConfirm;

function generateDisplayCardSet(excludeIcons = []) {
    let chosenIcon = null;
    const visibleLayeredCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board) && c.stack >= 0 && c.stack <= 3);
    const visibleLayeredIconCounts = {};
    visibleLayeredCards.forEach(c => visibleLayeredIconCounts[c.icon] = (visibleLayeredIconCounts[c.icon] || 0) + 1);
    let potentialVisibleLayeredIcons = Object.keys(visibleLayeredIconCounts).filter(icon => !excludeIcons.includes(icon) && visibleLayeredIconCounts[icon] >= 3);
    if (potentialVisibleLayeredIcons.length > 0) {
        chosenIcon = potentialVisibleLayeredIcons[Math.floor(Math.random() * potentialVisibleLayeredIcons.length)];
    } else {
        const allClickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
        const combinedClickableIcons = [...allClickableBoardCards.map(c => c.icon), ...game.temp.map(c => c.icon)];
        const combinedClickableIconCounts = {};
        combinedClickableIcons.forEach(icon => combinedClickableIconCounts[icon] = (combinedClickableIconCounts[icon] || 0) + 1);
        let potentialCombinedIcons = Object.keys(combinedClickableIconCounts).filter(icon => !excludeIcons.includes(icon) && combinedClickableIconCounts[icon] >= 3);
        if (potentialCombinedIcons.length > 0) {
            chosenIcon = potentialCombinedIcons[Math.floor(Math.random() * potentialCombinedIcons.length)];
        } else {
            const allIconsInGame = game.cards.map(c => c.icon);
            const allIconCounts = {};
            allIconsInGame.forEach(icon => allIconCounts[icon] = (allIconCounts[icon] || 0) + 1);
            const anyTripletIcons = Object.keys(allIconCounts).filter(icon => !excludeIcons.includes(icon) && allIconCounts[icon] >= 3);
            if (anyTripletIcons.length > 0) {
                chosenIcon = anyTripletIcons[Math.floor(Math.random() * anyTripletIcons.length)];
            } else {
                const availableIconsWithoutExclusion = allIconsInGame.filter(icon => !excludeIcons.includes(icon));
                if (availableIconsWithoutExclusion.length > 0) {
                    chosenIcon = availableIconsWithoutExclusion[Math.floor(Math.random() * availableIconsWithoutExclusion.length)];
                } else if (allIconsInGame.length > 0) {
                    chosenIcon = allIconsInGame[Math.floor(Math.random() * allIconsInGame.length)];
                } else {
                    return null;
                }
            }
        }
    }
    if (chosenIcon) {
        return [{ icon: chosenIcon, id: Date.now() + 1 }, { icon: chosenIcon, id: Date.now() + 2 }, { icon: chosenIcon, id: Date.now() + 3 }];
    } else {
        return null;
    }
}
const STACK_RATIO = 5 / 4; 
function calculateResponsiveSizes() {
    const areaW = cardStackArea.offsetWidth;
    const areaH = cardStackArea.offsetHeight;

    /* è‹¥æµè§ˆå™¨ä¸è®¤ aspect-ratio æˆ–è¢«å¤–å±‚çº¦æŸæ‰­æ›²ï¼Œè¿™é‡Œå¼ºåˆ¶ä¿®æ­£é«˜åº¦ */
    const expectedH = areaW * STACK_RATIO;
    // è‹¥ä¸ºæ¨ªå±ï¼Œå¯é€‚å½“æ”¾å¤§é«˜åº¦
    const isLandscape = window.matchMedia("(orientation: landscape)").matches;
    const adjustedH = isLandscape ? expectedH * 1.2 : expectedH;
    if (Math.abs(areaH - expectedH) > 1) {          // è¯¯å·® 1px ä»¥å†…å¿½ç•¥
        cardStackArea.style.height = `${expectedH}px`;
    }
    const lv = LEVELS[game.level - 1];
    // Make cards slightly smaller to fit more complex shapes
    const baseCardWidth = areaW / (lv.cols + 3); 
    const clampedCardWidth = Math.max(35, Math.min(baseCardWidth, 75));
    const cardAspectRatio = 65 / 85;
    const finalCardW = clampedCardWidth;
    const finalCardH = finalCardW / cardAspectRatio;
    game.cardDimensions = {
        width: finalCardW,
        height: finalCardH,
        fontSize: finalCardW * 0.45,
        borderRadius: finalCardW * 0.15,
        borderWidth: Math.max(2, finalCardW * 0.04)
    };
}

// =================================================================================
// START OF MODIFICATION: Refined heart shape layout logic for centering and consistency.
// =================================================================================
/**
 * (æºæ–‡ä»¶ç®—æ³•) ç”Ÿæˆä¸€ä¸ªå¤šå±‚çš„ã€å±…ä¸­çš„å¿ƒå½¢å¡ç‰‡å¸ƒå±€ã€‚
 * è¯¥å‡½æ•°ä¼šåœ¨åº•éƒ¨åˆ›å»ºä¸€ä¸ªéšæœºçš„â€œå‘â€ï¼Œç„¶åå°†å‰©ä½™çš„å¡ç‰‡ä»¥å¿ƒå½¢æ’åˆ—åœ¨ä¸Šé¢ã€‚
 * @param {Array} cardsToPlace - è¦æ”¾ç½®çš„å¡ç‰‡å¯¹è±¡æ•°ç»„ã€‚
 * @param {Object} levelConfig - å½“å‰å…³å¡çš„é…ç½®ã€‚
 * @returns {Array} åŒ…å«å¿ƒå½¢å¸ƒå±€ä½ç½®çš„æ–°boardæ•°ç»„ã€‚
 */
function repositionCardsAndLayout(cardsToPlace, levelConfig) {
    const areaW = cardStackArea.offsetWidth;
    const areaH = cardStackArea.offsetHeight;
    calculateResponsiveSizes(); // æ ¹æ®åŒºåŸŸå®½åº¦ç¡®å®šå¡ç‰‡å°ºå¯¸
    const cardW = game.cardDimensions.width;
    const cardH = game.cardDimensions.height;

    let finalBoard = [];
    let mutableCardsToPlace = [...cardsToPlace];
    shuffle(mutableCardsToPlace);
    let zCounter = 0;

    // --- 1. åœ¨åº•éƒ¨æ”¾ç½®ä¸€ä¸ªâ€œå‘â€ä»¥å¢åŠ éš¾åº¦ ---
    const pitRatio = game.level === 1 ? 0.25 : 0.4;
    const pitCardCount = Math.floor(mutableCardsToPlace.length * pitRatio);
    const pitCards = mutableCardsToPlace.splice(0, pitCardCount);
    for (let i = 0; i < pitCards.length; i++) {
        const card = pitCards[i];
        const x = randBetween(cardW * 1.5, areaW - cardW * 2.5);
        const y = randBetween(cardH * 1.5, areaH - cardH * 2.5);
        finalBoard.push({
            ...card,
            x: x,
            y: y,
            z: zCounter++,
            stack: 0 // â€œå‘â€çš„å±‚çº§ä¸º0
        });
    }

    // --- 2. ç”Ÿæˆå¿ƒå½¢çš„ç‚¹ ---
    const heartPoints = [];
    const heartPointStep = 0.25; 
    for (let t = 0; t < 2 * Math.PI; t += heartPointStep) { 
        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
        heartPoints.push({ x, y });
    }

    // --- 3. æ ‡å‡†åŒ–å¹¶ç¼©æ”¾çˆ±å¿ƒä»¥é€‚åº”åŒºåŸŸ ---
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    heartPoints.forEach(p => {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
    });

    const heartWidth = maxX - minX;
    const heartHeight = maxY - minY;
    
    // ç¼©æ”¾æ¯”ä¾‹å¿…é¡»è€ƒè™‘åˆ°å¡ç‰‡è‡ªèº«çš„å°ºå¯¸
    const scale = Math.min((areaW - cardW) / heartWidth, (areaH - cardH) / heartHeight);

    // --- 4. å°†å‰©ä½™å¡ç‰‡æ²¿å¤šå±‚å¿ƒå½¢æ”¾ç½® ---
    const heartCards = mutableCardsToPlace;
    const numLayers = game.level === 1 ? 3 : 4;
    let cardIndex = 0;

    for (let layer = 0; layer < numLayers; layer++) {
        if (cardIndex >= heartCards.length) break;

        const layerScale = 1 - layer * 0.16; 
        
        const layerScaledWidth = heartWidth * scale * layerScale;
        const layerScaledHeight = heartHeight * scale * layerScale;
        const layerOffsetX = (areaW - layerScaledWidth - cardW) / 2 - (minX * scale * layerScale);
        const layerOffsetY = (areaH - layerScaledHeight - cardH) / 2 - (minY * scale * layerScale);
        
        for (let i = 0; i < heartPoints.length; i++) {
            if (cardIndex >= heartCards.length) break;

            const p = heartPoints[i];
            const card = heartCards[cardIndex++];
            
            let x = p.x * scale * layerScale + layerOffsetX;
            let y = p.y * scale * layerScale + layerOffsetY;
            
            finalBoard.push({
                ...card,
                x: x,
                y: y,
                z: zCounter++,
                stack: 1 + layer // å¿ƒå½¢å±‚ä»1å¼€å§‹
            });
        }
    }

    // æŒ‰z-indexæ’åºä»¥ç¡®ä¿æ­£ç¡®çš„æ¸²æŸ“é¡ºåº
    finalBoard.sort((a, b) => (a.z || 0) - (b.z || 0));
    return finalBoard;
}

function genLevel(levelIdx){
  const lv = LEVELS[levelIdx - 1];
  game.score = 0;
  game.targetScore = lv.targetScore;
  game.totalDisplaySetsGenerated = 0;
  game.isCurtainEnabled = true;
  let allIcons = [];
  const requiredUniqueIcons = Math.ceil(lv.total / 3);
  let availableIcons = randArr(CARD_ICONS).slice(0, Math.min(CARD_ICONS.length, requiredUniqueIcons + 2));
  let iconPool = [];
  for (let i = 0; i < requiredUniqueIcons; i++) {
    for (let j = 0; j < 3; j++) {
      iconPool.push(availableIcons[i % availableIcons.length]);
    }
  }
  while (iconPool.length < lv.total) {
      const remaining = lv.total - iconPool.length;
      if (remaining < 3) {
          for (let i = 0; i < remaining; i++) iconPool.push(availableIcons[i % availableIcons.length]);
      } else {
          const iconToAdd = availableIcons[Math.floor(Math.random() * availableIcons.length)];
          iconPool.push(iconToAdd, iconToAdd, iconToAdd);
      }
  }
  shuffle(iconPool);
  allIcons = iconPool;
  let cards = [];
  for(let i = 0; i < lv.total; i++){
    cards.push({ id: i, icon: allIcons[i], matched: false });
  }
  game.cards = cards;
  // Use the new heart-shaped layout function
  game.board = repositionCardsAndLayout(cards.map(c => ({...c, covered: false, isNapping: false})), lv);
  game.displayCards = [];
  const usedDisplayIconsForLevel = new Set();
  for (let i = 0; i < INITIAL_DISPLAY_SETS_VISIBLE; i++) {
      const newSet = generateDisplayCardSet(Array.from(usedDisplayIconsForLevel));
      if (newSet) {
          game.displayCards.push({ id: `display-set-${i}`, cards: newSet, matched: false });
          usedDisplayIconsForLevel.add(newSet[0].icon);
          game.totalDisplaySetsGenerated++;
      }
  }
  return {cards: game.cards, board: game.board, usedIcons: availableIcons.slice(0, Math.ceil(lv.total/3))};
}

/**
 * Checks if a card is clickable by verifying it's not covered by another card.
 * This logic is crucial for the stacking mechanic.
 * @param {Object} card - The card to check.
 * @param {Array} board - The current game board.
 * @returns {boolean} - True if the card is on the top layer and clickable, false otherwise.
 */
function isCardClickable(card, board) {
    // A card cannot be clicked if it's already matched, being animated, or "napping".
    if (card.matched || card.isFlying || card.isNapping) return false;

    const activeCards = board.filter(c => !c.matched && !c.isFlying);
    const cardW = game.cardDimensions.width;
    const cardH = game.cardDimensions.height;
    
    // To be clickable, a card must not be covered. We check this by seeing if the
    // center point of the card is inside the bounding box of any other card
    // that has a higher z-index (is stacked on top).
    const centerX = card.x + cardW / 2;
    const centerY = card.y + cardH / 2;

    for (const otherCard of activeCards) {
        if (card.id === otherCard.id) continue;

        // The core of the "top layer" logic: only cards with a higher z-index can block the current card.
        if (otherCard.z > card.z) {
            const otherLeft = otherCard.x;
            const otherRight = otherCard.x + cardW;
            const otherTop = otherCard.y;
            const otherBottom = otherCard.y + cardH;

            // Check if the center of the current card falls within the bounds of the other card.
            if (centerX > otherLeft && centerX < otherRight && centerY > otherTop && centerY < otherBottom) {
                return false; // It's blocked by a card on top.
            }
        }
    }
    return true; // No card is blocking it, so it's on the top layer and clickable.
}


// MODIFIED: clickCard function with robust state checking
function clickCard(id, isAuto = false) {
  // å¦‚æœæ˜¯ç©å®¶æ‰‹åŠ¨ç‚¹å‡»ï¼Œå¹¶ä¸”è‡ªåŠ¨æ”¶é›†æ­£åœ¨è¿è¡Œï¼Œåˆ™æš‚åœå®ƒ
  if (!isAuto && autoCollectActive) {
    autoCollectPaused = true;
	lastManualClickTime = Date.now(); // è®°å½•æ‰‹åŠ¨ç‚¹å‡»æ—¶é—´
    if (autoCollectTimer) clearTimeout(autoCollectTimer);
    showMessage('è‡ªåŠ¨æ”¶é›†å·²æš‚åœï¼Œæ‰‹åŠ¨æ“ä½œä¸­');
    updateAutoCollectStatus();
  }

  let cardData = game.board.find(c => c.id === id);
  if (game.lock || !cardData || cardData.matched || cardData.isFlying || cardData.isNapping || !isCardClickable(cardData, game.board)) {
    if (game.temp.filter(c => !c.matched).length >= TEMP_LIMIT) {
      showMessage('æš‚å­˜åŒºå·²æ»¡ï¼Œæ— æ³•å†æ”¾å…¥å¡ç‰‡');
    }
    // å¦‚æœæ˜¯æ— æ•ˆç‚¹å‡»ï¼Œä½†ä¹‹å‰æ˜¯è‡ªåŠ¨æ”¶é›†ä¸­ï¼Œåˆ™å°è¯•æ¢å¤
    if (isAuto) tryResumeAutoCollect();
    return;
  }

  playClickSound();
  saveStep();

  cardData.matched = true;
  cardData.isFlying = true;
  game.flyingCardCount++;
  game.lock = true; // é”å®šæ¸¸æˆç›´åˆ°åŠ¨ç”»å®Œæˆ

  const clickedCardEl = document.querySelector(`#card-stack-area .card[data-id='${id}']`);
  if (!clickedCardEl) {
    cardData.matched = false;
    cardData.isFlying = false;
    game.flyingCardCount--;
    game.lock = false;
    if (isAuto) tryResumeAutoCollect();
    return;
  }

  const startRect = clickedCardEl.getBoundingClientRect();
  const flyingCard = document.createElement('div');
  flyingCard.className = 'flying-card';
  flyingCard.innerHTML = cardData.icon;
  const gameContainer = document.getElementById('game-container');
  const themeClass = Array.from(gameContainer.classList).find(cls => cls.startsWith('theme-'));
  if (themeClass) flyingCard.classList.add(themeClass);
  document.body.appendChild(flyingCard);
  Object.assign(flyingCard.style, {
      left: `${startRect.left}px`,
      top: `${startRect.top}px`,
      width: `${startRect.width}px`,
      height: `${startRect.height}px`,
      fontSize: `${game.cardDimensions.fontSize}px`,
      borderRadius: `${game.cardDimensions.borderRadius}px`,
      borderWidth: `${game.cardDimensions.borderWidth}px`
  });
  clickedCardEl.style.visibility = 'hidden';
  const tempForPositionCalculation = [...game.temp.filter(c => !c.matched), { icon: cardData.icon, id: cardData.id }];
  tempForPositionCalculation.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);
  const endSlotIndex = tempForPositionCalculation.findIndex(c => c.id === id);
  const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
  if (endSlotIndex < 0 || endSlotIndex >= tempSlots.length) {
    if (flyingCard.parentNode) flyingCard.remove();
    cardData.matched = false;
    cardData.isFlying = false;
    game.flyingCardCount--;
    clickedCardEl.style.visibility = 'visible';
    game.lock = false;
    if (isAuto) tryResumeAutoCollect();
    return;
  }
  const endRect = tempSlots[endSlotIndex].getBoundingClientRect();
  const tempSlotStyle = window.getComputedStyle(tempSlots[endSlotIndex]);
  const flyingCardFinalWidth = parseFloat(tempSlotStyle.width);
  const flyingCardFinalHeight = parseFloat(tempSlotStyle.height);
  const distance = Math.hypot(endRect.left - startRect.left, endRect.top - startRect.top);
  const animationDuration = Math.max(200, Math.min(500, (distance / FLYING_SPEED_PPS) * 1000));
  flyingCard.style.transition = `all ${animationDuration}ms ease-out`;
  requestAnimationFrame(() => {
    const destLeft = endRect.left + (endRect.width - flyingCardFinalWidth) / 2;
    const destTop = endRect.top + (endRect.height - flyingCardFinalHeight) / 2;
    flyingCard.style.left = `${destLeft}px`;
    flyingCard.style.top = `${destTop}px`;
    flyingCard.style.transform = `scale(${flyingCardFinalWidth / startRect.width})`;
  });

  // åŠ¨ç”»ç»“æŸåå¤„ç†
  setTimeout(() => {
    if (flyingCard.parentNode) flyingCard.remove();
    game.flyingCardCount--;
    delete cardData.isFlying;
    // â†“â†“â†“ æ–°å¢ï¼šé£ç‰Œè®¡æ•°å˜åŒ–åå°è¯•åˆ·æ–°å±éšœé˜Ÿåˆ—
    AnimBarrier.tryFlush();
    game.temp.push({ icon: cardData.icon, id: cardData.id, matched: false });
    game.temp.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);

    renderTemp();
    renderBoard();
    updateAutoCollectStatus(); // æ›´æ–°æŒ‰é’®çŠ¶æ€

    let iconCnt = {};
    game.temp.forEach(c => { if (!c.matched) iconCnt[c.icon] = (iconCnt[c.icon] || 0) + 1; });
    let matchedIcon = Object.keys(iconCnt).find(k => iconCnt[k] === 3);

    if (matchedIcon) {
      triggerMatchFeedback();
      const toVanishIndexes = [];
      game.temp.forEach((card, i) => {
        if (card.icon === matchedIcon && !card.matched) {
          card.matched = true;
          toVanishIndexes.push(i);
        }
      });
	  if (isAuto && autoCollectCount > 0) {
	    autoCollectCount--;
	    updateAutoCollectStatus();
	  }
      let animationsToComplete = toVanishIndexes.length;
      const finishCleanup = () => {
        game.temp = game.temp.filter(c => !c.matched);
        renderTemp();
        renderBoard();
        game.lock = false;
        checkWin();
        tryResumeAutoCollect();
        // â†“â†“â†“ æ–°å¢ï¼šè§£é”åå°è¯•åˆ·æ–°å±éšœé˜Ÿåˆ—
        AnimBarrier.tryFlush();
      };
      if (animationsToComplete === 0) {
        finishCleanup();
      } else {
        toVanishIndexes.forEach(idx => {
          const cardEl = tempSlots[idx]?.querySelector('.temp-card');
          if (cardEl) {
            cardEl.classList.add('vanishing');
            cardEl.addEventListener('animationend', () => {
              animationsToComplete--;
              if (animationsToComplete === 0) finishCleanup();
            }, { once: true });
          } else {
            animationsToComplete--;
          }
        });
        if (animationsToComplete === 0) finishCleanup();
        setTimeout(() => { if (animationsToComplete > 0) finishCleanup(); }, 700);
      }

      // å¤„ç†è®¡åˆ†å±•ç¤ºåŒºçš„é€»è¾‘ä¿æŒä¸å˜
      game.displayCards.forEach(displaySet => {
          if (!displaySet.matched && displaySet.cards[0].icon === matchedIcon) {
              displaySet.matched = true;
              game.score += DISPLAY_CARD_MATCH_SCORE;
              renderProgressAndScore();
              const matchedDisplayGroupEl = document.querySelector(`#display-area .display-group[data-id='${displaySet.id}']`);
              if (matchedDisplayGroupEl) {
                  const groupRect = matchedDisplayGroupEl.getBoundingClientRect();
                  const scoreAnimDiv = document.createElement('div');
                  scoreAnimDiv.className = 'score-animation';
                  scoreAnimDiv.textContent = `+${DISPLAY_CARD_MATCH_SCORE}`;
                  document.body.appendChild(scoreAnimDiv);
                  scoreAnimDiv.style.left = `${groupRect.left + groupRect.width / 2}px`;
                  scoreAnimDiv.style.top = `${groupRect.top + groupRect.height / 2}px`;
                  scoreAnimDiv.style.transform = 'translate(-50%, -50%)';
                  scoreAnimDiv.addEventListener('animationend', () => scoreAnimDiv.remove(), { once: true });
              }
              setTimeout(() => {
                  const newSet = generateDisplayCardSet(game.displayCards.map(ds => ds.cards[0].icon));
                  if (newSet) {
                      displaySet.cards = newSet;
                      displaySet.matched = false;
                  } else {
                      game.displayCards = game.displayCards.filter(ds => ds.id !== displaySet.id);
                  }
                  renderDisplay();
              }, 400);
          }
      });
    } else {
      game.lock = false;
      checkWin();
      tryResumeAutoCollect();
      // â†“â†“â†“ æ–°å¢ï¼šè§£é”åå°è¯•åˆ·æ–°å±éšœé˜Ÿåˆ—
      AnimBarrier.tryFlush();
    }
  }, animationDuration);
}

function checkWin() {
    // MODIFIED: Add an early exit if a game end screen is already visible
    const levelFinishScreen = document.getElementById('level-finish');
    const gameOverScreen = document.getElementById('game-over');
    if (levelFinishScreen.style.display === 'flex' || gameOverScreen.style.display === 'flex') {
        return;
    }

    const allCardsMatched = game.board.every(c => c.matched);
    const scoreMet = game.score >= game.targetScore;

    if (game.temp.filter(c => !c.matched).length >= TEMP_LIMIT && !allCardsMatched) {
        gameOver('æš‚å­˜åŒºå·²è¶…é™ï¼Œæ¸¸æˆå¤±è´¥ï¼');
        return;
    }

    if (allCardsMatched && scoreMet) {
        stopAutoCollect(); // å…³å¡ç»“æŸæ—¶å½»åº•åœæ­¢è‡ªåŠ¨æ”¶é›†
        game.ended = true;    // â† æ ‡è®°å·²ç»ç»“æŸ
        game.autoCollectEnabled = false;   // â† æ–°å¢ï¼šå½»åº•ç¦ç”¨è‡ªåŠ¨æ”¶é›†
        stopRandomEvents();
        stopCurtainRandomToggle();
        stopDecorationUpdates();
        game.lock = true;
        const elapsedSeconds = ((Date.now() - game.levelStartTime) / 1000).toFixed(1);
        const message = `æœ¬å…³è¿‡å…³ç”¨æ—¶ ${elapsedSeconds} ç§’`;
        const originalYesText = confirmYes.textContent;
        const originalNoDisplay = confirmNo.style.display;
        confirmYes.textContent = 'å¥½çš„';
        confirmNo.style.display = 'none';
        showConfirm(message, () => {
            if (game.level === 1) {
                showLevelFinish('æ­å–œæ­å–œï¼ç¬¬ä¸€å…³é€šå…³ï¼');
            } else {
                showLevelFinish('<p> <p>æ‰€æœ‰å…³å¡å…¨éƒ¨é€šå…³ï¼<br> ğŸ‰ ä½ å¤ªæ£’å•¦ï¼ğŸ‰');
            }
            confirmYes.textContent = originalYesText;
            confirmNo.style.display = originalNoDisplay;
        });
    } else if (allCardsMatched && !scoreMet) {
        game.ended = true;    // â† æ ‡è®°å·²ç»ç»“æŸ
        stopAutoCollect(); // å…³å¡ç»“æŸæ—¶å½»åº•åœæ­¢è‡ªåŠ¨æ”¶é›†
        gameOver(`å¡ç‰Œå·²å…¨éƒ¨æ¶ˆé™¤ï¼Œä½†åˆ†æ•°æœªè¾¾æ ‡ï¼<br>å½“å‰åˆ†æ•°: ${game.score} / ç›®æ ‡åˆ†æ•°: ${game.targetScore}`);
    }
  //updateAutoCollectStatus();
}

function saveStep(){
  game.stepStack.push({
    board: deepClone(game.board),
    temp: deepClone(game.temp),
    score: game.score,
    displayCards: deepClone(game.displayCards),
    totalDisplaySetsGenerated: game.totalDisplaySetsGenerated
  });
  if(game.stepStack.length > 20) game.stepStack.shift();
}

function undoStep(){
  if(game.stepStack.length > 0){
    let prev = game.stepStack.pop();
    game.board = deepClone(prev.board);
    game.temp = deepClone(prev.temp);
    game.score = prev.score;
    game.displayCards = deepClone(prev.displayCards);
    game.totalDisplaySetsGenerated = prev.totalDisplaySetsGenerated;
    renderAll();
    showMessage('å·²æ’¤é”€');
    updateToolButtons(); // Ensure tool buttons are updated after undo
    updateWigglingCatVisibility();
  } else {
    showMessage('æ— æ³•æ’¤é”€æ›´å¤š', '#888');
  }
}

function animateCardsInBatches(cards, batchSize = 20, delay = 100) {
  let index = 0;

  function animateBatch() {
    const batch = cards.slice(index, index + batchSize);
    batch.forEach(card => {
      card.classList.add('swirl-in');
    });
    index += batchSize;
    if (index < cards.length) {
      setTimeout(animateBatch, delay);
    } else {
      // æ‰€æœ‰åŠ¨ç”»å®Œæˆåï¼Œå¼ºåˆ¶åˆ·æ–°æ¸¸æˆçŠ¶æ€
      setTimeout(() => {
        // é‡æ–°è®¡ç®—å¡ç‰‡ä½ç½®
        game.board = repositionCardsAndLayout(game.board, LEVELS[game.level - 1]);

        // æ¸…é™¤åŠ¨ç”»ç±»åï¼Œé˜²æ­¢å¹²æ‰°ç‚¹å‡»
        cards.forEach(card => card.classList.remove('swirl-in'));

        // å¼ºåˆ¶åˆ·æ–° DOM
        renderAll();

        game.lock = false;
        showMessage('å·²æ´—ç‰Œ');
      }, 600); // ç­‰å¾…æœ€åä¸€æ‰¹åŠ¨ç”»å®Œæˆ
    }
  }

  animateBatch();
}
// è¾…åŠ©å‡½æ•°ï¼šåˆ†æ‰¹æ¬¡ä¸ºå¡ç‰‡æ·»åŠ  "swirl-in" åŠ¨ç”»
function animateShuffleInBatches(cards, onAnimationEnd) {
    let index = 0;
    const batchSize = 20; // æ¯æ‰¹å¤„ç†20ä¸ªå¡ç‰‡
    const delay = 100;    // æ¯æ‰¹ä¹‹é—´çš„å»¶è¿Ÿ

    function animateBatch() {
        const batch = cards.slice(index, index + batchSize);
        batch.forEach(card => {
            card.classList.add('swirl-in');
            // ä¸ºæ¯ä¸ªå¡ç‰‡æ·»åŠ ä¸€æ¬¡æ€§çš„åŠ¨ç”»ç»“æŸç›‘å¬å™¨
            card.addEventListener('animationend', onAnimationEnd, { once: true });
        });
        index += batchSize;
        if (index < cards.length) {
            setTimeout(animateBatch, delay);
        }
    }
    animateBatch();
}

// æ–°çš„ shuffleStep å‡½æ•°ï¼Œè°ƒç”¨ä¸Šé¢çš„è¾…åŠ©å‡½æ•°
function shuffleStep(){
  saveStep();
  game.lock = true;
  // æ‰“å¼€â€œæ´—ç‰Œå±éšœâ€ï¼Œç›´åˆ°å…¨éƒ¨åŠ¨ç”»å®Œæˆå¹¶ cleanup
  AnimBarrier.begin('shuffle');
  const allCards = Array.from(document.querySelectorAll('#card-stack-area .card:not(.matched)'));
  // ä»…å¯¹å½“å‰å¯è§çš„å¡ç‰‡åº”ç”¨åŠ¨ç”»
  const visibleCards = allCards.filter(card => card.offsetParent !== null);

  if (visibleCards.length === 0) {
      game.lock = false;
      AnimBarrier.end('shuffle'); // æ²¡æœ‰åŠ¨ç”»ä¹Ÿè¦é‡Šæ”¾å±éšœ
      AnimBarrier.tryFlush();
      return;
  }

  // ä½¿ç”¨è®¡æ•°å™¨ç¡®ä¿æ‰€æœ‰åŠ¨ç”»éƒ½å®Œæˆåå†æ‰§è¡Œæ¸…ç†
  let animationsToComplete = visibleCards.length;

  const cleanupAfterShuffle = () => {
      // é‡æ–°è®¡ç®—å¡ç‰‡å¸ƒå±€
      game.board = repositionCardsAndLayout(game.board, LEVELS[game.level - 1]);
      
      // é‡æ–°æ¸²æŸ“æ‰€æœ‰å†…å®¹ï¼Œæ–°ç”Ÿæˆçš„å¡ç‰‡å°†ä¸å¸¦ swirl-in ç±»
      renderAll();

      showMessage('å·²æ´—ç‰Œ');
      game.lock = false;
      updateWigglingCatVisibility();
      updateAutoCollectStatus();
      updateWigglingCatVisibility();
      updateAutoCollectStatus();
      tryResumeAutoCollect();
        if (autoCollectActive && !findDisplayAreaTriple() && !findAnyTriple()) {
        stopAutoCollect();
        showMessage('æ´—ç‰Œåæ— ä¸‰æ¶ˆï¼Œè‡ªåŠ¨æ”¶é›†å·²åœæ­¢');
      }
      AnimBarrier.end('shuffle');
      AnimBarrier.tryFlush();
  };
  
  const handleAnimationEnd = () => {
      animationsToComplete--;
      if (animationsToComplete === 0) {
          cleanupAfterShuffle();
      }
  };
  
  // æ¸…ç†å¯èƒ½æ®‹ç•™çš„æ—§åŠ¨ç”»ç±»
  visibleCards.forEach(card => card.classList.remove('swirl-in'));
  // å¼€å§‹åˆ†æ‰¹æ‰§è¡ŒåŠ¨ç”»
  animateShuffleInBatches(visibleCards, handleAnimationEnd);
}

function hintStep(){
  let tempIcons = game.temp.map(c => c.icon);
  let clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
  let clickableBoardIcons = clickableBoardCards.map(c => c.icon);
  let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];
  let iconCounts = {};
  allAvailableIcons.forEach(icon => iconCounts[icon] = (iconCounts[icon] || 0) + 1);
  // Fixed typo: changed iconCnt to iconCounts
  let targetIcon = Object.keys(iconCounts).find(icon => iconCounts[icon] >= 3);
  
  // Remove any existing hinted-shake classes before applying new ones
  document.querySelectorAll('.hinted-shake').forEach(el => el.classList.remove('hinted-shake'));

  if (targetIcon) {
    let hintDone = 0;
    const hintedElements = [];

    // Highlight cards in temp area
    for (let i = 0; i < game.temp.length && hintDone < 3; i++) {
      if (game.temp[i].icon === targetIcon && !game.temp[i].matched) {
        const tempCardElement = document.querySelectorAll('#temp-area .temp-slot .temp-card')[i];
        if (tempCardElement) {
          tempCardElement.classList.add('hinted-shake');
          hintedElements.push(tempCardElement);
          hintDone++;
        }
      }
    }

    // Highlight cards on the board
    for (let i = 0; i < clickableBoardCards.length && hintDone < 3; i++) {
      let boardCard = clickableBoardCards[i];
      if (boardCard.icon === targetIcon) {
        let doms = document.querySelector(`#card-stack-area .card[data-id='${boardCard.id}']`);
        if (doms) {
          doms.classList.add('hinted-shake');
          hintedElements.push(doms);
          hintDone++;
        }
      }
    }
    
    showMessage('å·²æç¤ºå¯æ¶ˆé™¤ä¸‰å¼ ');
    // Remove the shake animation after a short delay
    setTimeout(() => hintedElements.forEach(el => el.classList.remove('hinted-shake')), 2000);
  } else {
    showMessage('å½“å‰æ— å¯ä¸‰æ¶ˆ', "#888");
  }
}
reviveBtnGameOver.addEventListener('click', reviveGame);
function gameOver(msg){
  stopRandomEvents();
  stopCurtainRandomToggle();
  stopDecorationUpdates();
  stopAutoCollect(); // ç¡®ä¿åœæ­¢
  stopAutoCollectIdleWatcher();
  game.lock = true;
  document.getElementById('card-stack-area').innerHTML = '';
  document.querySelectorAll('#temp-area .temp-slot').forEach(slot => { slot.innerHTML = ''; });
  displayArea.innerHTML = '';
  document.getElementById('level-info').textContent = '';
  currentScoreElement.textContent = '0';
  targetScoreElement.textContent = '0';
  document.getElementById('message-bar').textContent = '';
  hideWigglingCats();
  document.querySelectorAll('.flying-card').forEach(card => card.remove());
  game.flyingCardCount = 0;
  const gameOverScreen = document.getElementById('game-over');
  gameOverScreen.style.display = 'flex';
  gameOverScreen.querySelector('#game-over-text').innerHTML = msg;
  if (game.toolUses.revive > 0) {
      reviveBtnGameOver.style.display = 'inline-block';
  } else {
      reviveBtnGameOver.style.display = 'none';
  }
}

function reviveGame() {
    if (game.toolUses.revive <= 0) {
        showMessage('æ²¡æœ‰å¤æ´»å¡äº†ï¼', '#c0392b');
        return;
    }

    showConfirm('ç¡®å®šè¦ä½¿ç”¨1æ¬¡å¤æ´»å¡å—ï¼Ÿè¿™å°†å›åˆ°æ¸¸æˆç•Œé¢å¹¶è§£é™¤æ‰“ç›¹å¡ç‰‡ã€‚', () => {
        game.toolUses.revive--;

        // æ’¤é”€æœ€åä¸€æ­¥ï¼ˆåªpopä¸€æ¬¡ï¼‰
        if (game.stepStack.length > 0) {
            game.stepStack.pop();
        }

        // è¿˜åŸåˆ°ä¸Šä¸€æ­¥çŠ¶æ€ï¼ˆå¦‚æœæœ‰ï¼‰
        if (game.stepStack.length > 0) {
            let prev = game.stepStack[game.stepStack.length - 1];
            game.board = deepClone(prev.board);
            game.temp = deepClone(prev.temp);
            game.score = prev.score;
            game.displayCards = deepClone(prev.displayCards);
            game.totalDisplaySetsGenerated = prev.totalDisplaySetsGenerated;
        } else {
            // å¦‚æœæ²¡æœ‰å†å²æ­¥éª¤ï¼Œåˆ™é‡å¼€å½“å‰å…³å¡
            startGame(game.level);
            showMessage('å¤æ´»æˆåŠŸï¼å·²å›åˆ°æœ¬å…³åˆå§‹çŠ¶æ€ã€‚', '#3e5a2b');
            return;
        }

        // è§£é™¤æ‰€æœ‰ nap çŠ¶æ€
        game.board.forEach(card => {
            card.isNapping = false;
        });

        document.getElementById('game-over').style.display = 'none';
        game.lock = false;
        renderAll();
        showMessage('å¤æ´»æˆåŠŸï¼æ’¤é”€æœ€åä¸€æ­¥å¹¶å”¤é†’å…¨éƒ¨å¡ç‰‡ã€‚', '#3e5a2b');
        startRandomEvents();
        startCurtainRandomToggle();
        startDecorationUpdates();
    });
}
        
function startGame(level) {
  game.lock = true;
  footer.style.display = 'block';
  game.level = level;
  game.levelStartTime = Date.now();
  game.flyingCardCount = 0;
  game.noShuffleCodePromptShown = false;
  let lvData = genLevel(level);
  game.cards = lvData.cards;
  game.board = lvData.board;
  game.usedIcons = lvData.usedIcons;
  game.temp = [];
  game.matched = [];
  game.toolUses.undo = 0;
  game.toolUses.hint = 0;
  game.toolUses.shuffle = 0;
  game.stepStack = [];
  game.isNewLevel = true;
  game.autoCollectEnabled = false; 
  renderAll();
  applyTheme(game.level);
  const cardStackArea = document.getElementById('card-stack-area');
  const oldLid = document.getElementById('card-stack-lid');
  if (oldLid) oldLid.remove();
  const lid = document.createElement('div');
  lid.id = 'card-stack-lid';
  lid.innerHTML = `
      <div class="lid-text-top">å¡ç‰‡éšæœºç”Ÿæˆ</div>
      <div class="lid-emoji">ğŸ“©</div>
      <div class="lid-footer"><small>Coded & Designed by å¼€å…ƒ</small></div>
  `;
  cardStackArea.appendChild(lid);
  cardStackArea.classList.add('level-starting');
  setTimeout(() => {
    const cards = cardStackArea.querySelectorAll('.card');
    cards.forEach((card, index) => {
      card.style.visibility = 'visible';
      card.classList.add('card-floating-in');
      card.style.animationDelay = `${index * 0.05}s`;
    });
  }, 1000);
  setTimeout(() => {
    cardStackArea.classList.remove('level-starting');
    if (lid.parentNode) {
        lid.remove();
    }
    const cards = cardStackArea.querySelectorAll('.card');
    cards.forEach(card => {
        card.classList.remove('card-floating-in');
        card.style.animationDelay = '';
    });
    game.lock = false;
}, 3000);

  if (game.bgmOn) playBgm(true);
  positionCatWalker();
  updateWigglingCatVisibility();
  startRandomEvents();
  startDecorationUpdates();
  positionCurtain();
  toggleCurtain(false);
  setTimeout(() => {
    toggleCurtain(true);
    startCurtainRandomToggle();
  }, 3200);
}

function renderBoard(){
  const area = document.getElementById('card-stack-area');
  const existingCardElements = area.querySelectorAll('.card');
  
  // Get IDs of cards that should currently be rendered on the board
  // These are cards that are not matched and not currently flying
  const cardsToDisplayInBoard = game.board.filter(c => !c.matched && !c.isFlying);
  const cardsToDisplayInBoardIds = new Set(cardsToDisplayInBoard.map(c => c.id));

  // 1. Remove cards from DOM that should no longer be there
  existingCardElements.forEach(el => {
    const cardId = parseInt(el.dataset.id, 10);
    if (!cardsToDisplayInBoardIds.has(cardId)) {
      el.remove();
    }
  });

  // 2. Add or update cards that should be on the board
  cardsToDisplayInBoard.sort((a, b) => a.z - b.z); // Ensure correct z-index order for rendering

  cardsToDisplayInBoard.forEach((card) => {
    let el = document.querySelector(`#card-stack-area .card[data-id='${card.id}']`);
    const clickable = isCardClickable(card, game.board); // Re-evaluate clickability for each card

    if (!el) { // Card does not exist in DOM, create it
      el = document.createElement('div');
      el.dataset.id = card.id;
      area.appendChild(el);
    }

    // Update common properties and classes for existing or new elements
    el.className = "card" + (clickable ? "" : " disabled"); // Crucial: Update disabled class
    if (card.isNapping) {
      el.classList.add('napping');
    } else {
      el.classList.remove('napping');
    }
    
    el.style.left = card.x + 'px';
    el.style.top = card.y + 'px';
    el.style.zIndex = card.z;
    el.innerHTML = card.icon;
    el.style.width = `${game.cardDimensions.width}px`;
    el.style.height = `${game.cardDimensions.height}px`;
    el.style.fontSize = `${game.cardDimensions.fontSize}px`;
    el.style.borderRadius = `${game.cardDimensions.borderRadius}px`;
    el.style.borderWidth = `${game.cardDimensions.borderWidth}px`;
  });
  game.isNewLevel = false;
  updateAutoCollectStatus();
  if (autoCollectActive && !autoCollectTimer) {
    autoCollectStep(); // åªåœ¨æ²¡æœ‰å®šæ—¶å™¨æ—¶å¯åŠ¨
  }
}

function renderTemp(){
  const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
  const tempArea = document.getElementById('temp-area');
  const tempCardScaleFactor = 0.8;
  const tempCardWidth = game.cardDimensions.width * tempCardScaleFactor;
  const tempCardHeight = game.cardDimensions.height * tempCardScaleFactor;
  const tempCardFontSize = game.cardDimensions.fontSize * tempCardScaleFactor;
  const tempCardBorderRadius = game.cardDimensions.borderRadius * tempCardScaleFactor;
  const tempCardBorderWidth = game.cardDimensions.borderWidth * tempCardScaleFactor;
  tempArea.style.minHeight = `${tempCardHeight + (tempCardBorderWidth * 2) + 16}px`;
  tempSlots.forEach((slot, i) => {
    slot.innerHTML = '';
    slot.style.width = `${tempCardWidth}px`;
    slot.style.height = `${tempCardHeight}px`;
    slot.style.borderRadius = `${tempCardBorderRadius}px`;
    slot.style.borderWidth = `${tempCardBorderWidth}px`;
    slot.style.margin = '0';
    if (i < game.temp.length) {
      const c = game.temp[i];
      let el = document.createElement('div');
      el.className = "temp-card" + (c.matched ? " matched" : "");
      el.innerHTML = c.icon;
      el.style.fontSize = `${tempCardFontSize}px`;
      el.style.borderRadius = `${tempCardBorderRadius}px`;
      el.style.borderWidth = `${tempCardBorderWidth}px`;
      slot.appendChild(el);
    }
  });
  let persistentHeart = document.getElementById('persistent-heart');
  if (game.temp.length === 7) {
    const seventhTempSlot = tempSlots[6];
    if (seventhTempSlot) {
      const mainArea = document.getElementById('main-area');
      const cardStackArea = document.getElementById('card-stack-area');
      const seventhSlotRect = seventhTempSlot.getBoundingClientRect();
      const cardStackRect = cardStackArea.getBoundingClientRect();
      const mainAreaRect = mainArea.getBoundingClientRect();
      const heartVerticalMidpointAbsolute = cardStackRect.bottom + (seventhSlotRect.top - cardStackRect.bottom) / 2;
      const heartTopRelativeToMainArea = heartVerticalMidpointAbsolute - mainAreaRect.top;
      const heartLeftRelativeToMainArea = (seventhTempSlot.left + seventhTempSlot.offsetWidth / 2) - mainAreaRect.left;
      if (!persistentHeart) {
        persistentHeart = document.createElement('div');
        persistentHeart.id = 'persistent-heart';
        persistentHeart.className = 'heart-animation';
        persistentHeart.innerHTML = 'ğŸ’';
        mainArea.appendChild(persistentHeart);
      }
      persistentHeart.style.left = `${heartLeftRelativeToMainArea}px`;
      persistentHeart.style.top = `${heartTopRelativeToMainArea}px`;
      persistentHeart.style.transform = 'translate(-50%, -50%)';
      persistentHeart.style.display = 'block';
    }
  } else {
    if (persistentHeart) persistentHeart.style.display = 'none';
  }
  updateAutoCollectStatus();
}

function renderDisplay() {
    displayArea.innerHTML = '';
    const displayCardWidth = game.cardDimensions.width * 0.7;
    const displayCardHeight = game.cardDimensions.height * 0.7;
    const displayCardFontSize = game.cardDimensions.fontSize * 0.7;
    const displayCardBorderRadius = game.cardDimensions.borderRadius * 0.7;
    const displayCardBorderWidth = game.cardDimensions.borderWidth * 0.7;
    const displayGroupGap = displayCardWidth * 0.1;
    displayArea.style.width = `${cardStackArea.offsetWidth * 0.95}px`;
    displayArea.style.minHeight = `${displayCardHeight + displayCardBorderWidth * 2 + 20}px`;
    game.displayCards.forEach(displaySet => {
        const groupDiv = document.createElement('div');
        groupDiv.className = 'display-group';
        groupDiv.dataset.id = displaySet.id;
        groupDiv.style.gap = `${displayGroupGap}px`;
        displaySet.cards.forEach(card => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'display-card' + (displaySet.matched ? ' matched-display' : '');
            cardDiv.innerHTML = card.icon;
            cardDiv.style.width = `${displayCardWidth}px`;
            cardDiv.style.height = `${displayCardHeight}px`;
            cardDiv.style.fontSize = `${displayCardFontSize}px`;
            cardDiv.style.borderRadius = `${displayCardBorderRadius}px`;
            cardDiv.style.borderWidth = `${displayCardBorderWidth}px`;
            groupDiv.appendChild(cardDiv);
        });
        displayArea.appendChild(groupDiv);
    });
}

function renderProgressAndScore(){
  levelInfoElement.textContent = `å…³å¡: ${game.level} / 2`;
  currentScoreElement.textContent = game.score;
  targetScoreElement.textContent = game.targetScore;
  updateWigglingCatVisibility();
}

function showMessage(msg, color){
  let bar = document.getElementById('message-bar');
  bar.style.color = color || '#c0392b';
  bar.textContent = msg || '';
  if(msg) setTimeout(()=>{bar.textContent='';}, 2300);
}

function hasTripleMatch() {
  let tempIcons = game.temp.filter(c => !c.matched).map(c => c.icon);
  let clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
  let clickableBoardIcons = clickableBoardCards.map(c => c.icon);
  let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];
  let iconCounts = {};
  allAvailableIcons.forEach(icon => iconCounts[icon] = (iconCounts[icon] || 0) + 1);
  return Object.values(iconCounts).some(cnt => cnt >= 3);
}

function updateToolButtons() {
  document.getElementById('undo-count').textContent = game.toolUses.undo;
  document.getElementById('hint-count').textContent = game.toolUses.hint;
  document.getElementById('shuffle-count').textContent = game.toolUses.shuffle;
  document.getElementById('revive-count').textContent = game.toolUses.revive;

  undoBtn.disabled = isLandscape || game.toolUses.undo <= 0;
  undoBtn.title = isLandscape ? "æ¨ªå±æ¨¡å¼ä¸‹ä¸å¯ç”¨" : "æ’¤é”€(éœ€å…‘æ¢ç )";
  hintBtn.disabled = game.toolUses.hint <= 0 || !hasTripleMatch(); // æ–°å¢ä¸‰æ¶ˆæ£€æµ‹
  shuffleBtn.disabled = game.toolUses.shuffle <= 0;
  reviveBtn.disabled = game.toolUses.revive <= 0;
}

function renderAll(){
  renderBoard();
  renderTemp();
  renderDisplay();
  renderProgressAndScore();
  updateToolButtons();
  positionCatWalker();
  updateWigglingCatVisibility();
  positionCurtain();
  toggleCurtain(false);
  updateAutoCollectStatus();
  if (autoCollectActive && !autoCollectTimer) {
    autoCollectStep(); // åªåœ¨æ²¡æœ‰å®šæ—¶å™¨æ—¶å¯åŠ¨
  }
}

function showLevelFinish(msg){
  stopRandomEvents();
  stopCurtainRandomToggle();
  stopDecorationUpdates();
  stopAutoCollectIdleWatcher();
  playBgm(false);
  if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
  if (outroVideo) {
      outroVideo.pause();
      outroVideo.currentTime = 0;
  }
  level2OutroScreen.style.display = 'none';
  skipOutroBtn.style.display = 'none';

  const levelFinishScreen = document.getElementById('level-finish');
  levelFinishScreen.style.display='flex';
  levelFinishTextElement.innerHTML = msg;
  const existingConfetti = levelFinishScreen.querySelector('.confetti-container');
  if (existingConfetti) existingConfetti.remove();
  const confettiContainer = document.createElement('div');
  confettiContainer.className = 'confetti-container';
  levelFinishScreen.appendChild(confettiContainer);
  // Monet pastel palette for confetti
  const colors = [
  '#D8EAF5', // mist blue
  '#CBE9E2', // seafoam
  '#F6D7E6', // petal pink
  '#F4E2BD', // warm sand
  '#D5E3C8', // soft green
  '#E9D5F2', // lilac haze
  '#FBE8D3', // apricot veil
  '#C7DBF0', // sky wash
  '#E4F1E6'  // light jade
  ];

  for (let i = 0; i < 150; i++) {
      const piece = document.createElement('div');
      piece.className = 'confetti-piece';
      piece.style.left = Math.random() * 100 + 'vw';
      piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      const duration = Math.random() * 3 + 4;
      piece.style.animationDuration = `${duration}s`;
      piece.style.animationDelay = `${Math.random() * 5}s`;
      piece.style.transform = `rotate(${Math.random() * 360}deg)`;
      confettiContainer.appendChild(piece);
  }
  nextBtn.style.display = (game.level === 1) ? 'inline-block' : 'none';
  gobangBtn.classList.remove('animated-scale-fade');
  closeGameBtnLevel.classList.remove('animated-scale-fade');
  if (game.level === 1) {
    levelFinishTextElement.style.animation = 'shake 6s infinite, show-card-property 15s forwards';
    levelFinishTextElement.innerHTML += '<br>ä¸‹ä¸€å…³åæœ‰å½©è›‹ğŸª…ï¼';
    playerDiv.style.display = 'block';
    neteasePlayerDiv.style.display = 'none';
    gobangBtn.style.display = 'none';
    restartGameBtn.style.display = 'none';
    retryBtnLevelFinish.style.display = 'inline-block';
    closeGameBtnLevel.onclick = () => handleCloseGame('level');
  } else if (game.level === 2) {
    levelFinishTextElement.style.animation = 'pulse-scale 2s infinite alternate, wave 2s infinite';
    playerDiv.style.display = 'none';
    neteasePlayerDiv.style.display = 'block';
    gobangBtn.style.display = 'inline-block';
    restartGameBtn.style.display = 'inline-block';
    retryBtnLevelFinish.style.display = 'none';
    gobangBtn.classList.add('animated-scale-fade');
    closeGameBtnLevel.classList.add('animated-scale-fade');
    closeGameBtnLevel.onclick = () => {
        document.getElementById('level-finish').style.display = 'none';
        playLevel2Outro();
    };
  }
}

function initializeGame(){
  createRiskModal(); // åˆ›å»ºé£é™©æç¤ºæ¡†
  musicToggleBtn.innerHTML = game.bgmOn ? 'ğŸ¼' : 'ğŸ”‡';
  updateToolButtons();
}

function handleCloseGame(type) {
    showConfirm('ç¡®å®šè¦å…³é—­æ¸¸æˆå—ï¼Ÿ', () => {
        window.close();
        setTimeout(() => {
            document.getElementById('game-container').style.display = 'none';
            let messageHtml = '';

            if (type === 'level') {
                if (game.level === 1) {
                    messageHtml = `
                        <p>å½“å‰å®¢æˆ·ç«¯æš‚ä¸æ”¯æŒè‡ªåŠ¨å…³é—­ï¼Œ</p>
                        <p><small>å°æç¤ºï¼šå¯è¾“å…¥"kaiyuan"å…‘æ¢æç¤ºæ¬¡æ•°ã€‚</small></p>
                        <br> å¦‚æœæƒ³é‡æ–°å¼€å§‹æ¸¸æˆï¼Œè¯·ç‚¹å‡»<br>
                        <br><button onclick="window.location.href='https://www.kaiyuanzhu.qzz.io/cat/'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">é‡æ–°å¼€å§‹</button>
                    `;
                } else {
                    messageHtml = `
                        <p>å½“å‰å®¢æˆ·ç«¯æš‚ä¸æ”¯æŒè‡ªåŠ¨å…³é—­</p>
                        <p>æ„Ÿè°¢æ¸¸ç©å…¨éƒ¨å…³å¡ï¼</p>
                        <br> å¦‚éœ€é‡å¼€ï¼Œè¯·ç‚¹å‡»<br><br>
                        <button onclick="window.location.href='https://sub.kaiyuanzhu.qzz.io/'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">é‡æ–°å¼€å§‹</button>
                    `;
                }
            } else if (type === 'gameover') {
                messageHtml = `
                    <p>å½“å‰å®¢æˆ·ç«¯æš‚ä¸æ”¯æŒè‡ªåŠ¨å…³é—­</p>
                    <p><small>å°æç¤ºï¼šå¯è¾“å…¥"<b>kaiyuan</b>"å…‘æ¢æç¤ºæ¬¡æ•°ã€‚</small></p>
                    <br> å¦‚æœæƒ³é‡æ–°å¼€å§‹æ¸¸æˆï¼Œè¯·ç‚¹å‡»<br><br>
                    <button onclick="window.location.href='https://www.kaiyuanzhu.qzz.io/cat/'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">é‡æ–°å¼€å§‹</button>
                `;
            }

            document.body.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh; font-size:1.2em; color:#5d4037; text-align:center; opacity: 1;">
                    ${messageHtml}
                    <br><small class="loading-footer mt-8">è¶…çº§å–µå–µ &copy; 2025 | Designed by å¼€å…ƒ</small>
                </div>
            `;
        }, 100);
    });
}

function showEventMessage(icon, text) {
    eventIconEl.textContent = icon;
    eventTextEl.innerHTML = text;
    eventOverlay.style.display = 'flex';
    setTimeout(() => eventOverlay.style.display = 'none', 3500);
}

function eventCatNap() {
    const CATNAP_MIN_DURATION = 2000;
    const CATNAP_MAX_DURATION = 4000;
    const clickableCards = game.board.filter(c => isCardClickable(c, game.board));
    if (clickableCards.length < 3) return;
    // æ‰“â€œçŒ«å’ªäº‹ä»¶â€å±éšœ
    AnimBarrier.begin('catNap');
    showEventMessage('ğŸ’¤', 'çŒ«å’ªåœ¨æ‰“ç›¹...<br>æœ‰äº›å¡ç‰Œæš‚æ—¶æ‹¿ä¸åˆ°äº†ï¼');
    game.lock = true;
    const nappingCards = [];
    const centerCard = clickableCards[Math.floor(Math.random() * clickableCards.length)];
    nappingCards.push(centerCard);
    const otherCards = game.board.filter(c => !c.matched && c.id !== centerCard.id);
    otherCards.sort((a, b) => Math.hypot(a.x - centerCard.x, a.y - centerCard.y) - Math.hypot(b.x - centerCard.x, b.y - centerCard.y));
    nappingCards.push(...otherCards.slice(0, Math.floor(Math.random() * 2) + 2));
    nappingCards.forEach(card => card.isNapping = true);
    renderBoard();
    autoCollectPaused = true;
    if (autoCollectTimer) clearTimeout(autoCollectTimer);
    updateAutoCollectStatus(); // â† æ·»åŠ è¿™ä¸€è¡Œ
  game.lock = false;
  AnimBarrier.tryFlush();
  const nappingDuration = randBetween(CATNAP_MIN_DURATION, CATNAP_MAX_DURATION);
  setTimeout(() => {
    nappingCards.forEach(card => {
      const boardCard = game.board.find(c => c.id === card.id);
      if (boardCard) boardCard.isNapping = false;
    });
    renderBoard();
    checkWin();
    autoCollectPaused = false;
    tryResumeAutoCollect();
    // ç»“æŸå±éšœå¹¶å°è¯•è§¦å‘ç»­è·‘
    AnimBarrier.end('catNap');
    AnimBarrier.tryFlush();
  }, nappingDuration);
}

function eventCuriousPaw() {
    let clickableCards = game.board.filter(c => isCardClickable(c, game.board));
    let unclickableCards = game.board.filter(c => !c.matched && !isCardClickable(c, game.board));

    if (clickableCards.length === 0 || unclickableCards.length === 0) return;

    // Determine how many pairs to swap (1 to 3)
    const swapCount = Math.floor(Math.random() * 3) + 1;
    const actualSwapCount = Math.min(swapCount, clickableCards.length, unclickableCards.length);

    if (actualSwapCount === 0) return;
    AnimBarrier.begin('curiousPaw');
    showEventMessage('ğŸ¾', `å¥½å¥‡çš„çˆªå­...<br>${actualSwapCount}å¯¹å¯è§ä¸ä¸å¯è§å¡ç‰Œçš„å›¾æ ‡è¢«äº¤æ¢äº†ï¼`);
    game.lock = true;

    const swappedElements = [];

    for (let i = 0; i < actualSwapCount; i++) {
        // Pick a random clickable card
        const clickableIndex = Math.floor(Math.random() * clickableCards.length);
        const card1 = clickableCards[clickableIndex];

        // Pick a random unclickable card
        const unclickableIndex = Math.floor(Math.random() * unclickableCards.length);
        const card2 = unclickableCards[unclickableIndex];

        // Swap icons
        if(card1 && card2) {
            [card1.icon, card2.icon] = [card2.icon, card1.icon];
        }

        // Animate the swapped cards
        const card1El = document.querySelector(`.card[data-id='${card1.id}']`);
        const card2El = document.querySelector(`.card[data-id='${card2.id}']`);
        if (card1El) swappedElements.push(card1El);
        if (card2El) swappedElements.push(card2El);

        // Remove the swapped cards from the pools to avoid picking them again
        clickableCards.splice(clickableIndex, 1);
        unclickableCards.splice(unclickableIndex, 1);
    }
    swappedElements.forEach(el => el.classList.add('hinted-shake'));
    setTimeout(() => {
      renderBoard();
      game.lock = false;

    // ç»“æŸå±éšœå¹¶å°è¯•è§¦å‘ç»­è·‘
      AnimBarrier.end('curiousPaw');
      AnimBarrier.tryFlush();

    // å¦‚æœè‡ªåŠ¨æ”¶é›†å¯è¿è¡Œï¼Œç©ºé—²åä¼šè‡ªç„¶ç»­è·‘
      tryResumeAutoCollect();
    }, 800);
}

function eventGiftOffering() {
    const tools = ['undo', 'hint', 'shuffle', 'revive']; // Added revive to tools list for random event
    const toolNames = { undo: 'æ’¤é”€', hint: 'æç¤º', shuffle: 'æ´—ç‰Œ', revive: 'å¤æ´»å¡' }; // Added revive tool name
    const randomTool = tools[Math.floor(Math.random() * tools.length)];
    game.toolUses[randomTool]++;
    updateToolButtons();
    showEventMessage('ğŸ', `çŒ«å’ªé€æ¥äº†ç¤¼ç‰©ï¼<br>è·å¾—1æ¬¡å…è´¹<b>${toolNames[randomTool]}</b>ï¼`);
}

const randomEvents = [
    { name: 'catNap', func: eventCatNap, weight: 3 },
    { name: 'curiousPaw', func: eventCuriousPaw, weight: 3 },
    { name: 'giftOffering', func: eventGiftOffering, weight: 2 }
];
function startRandomEvents() {
    stopRandomEvents(); // Ensure no multiple timers are running
    randomEventTimer = setInterval(() => {
        if (game.lock || document.getElementById('level-finish').style.display === 'flex' || document.getElementById('game-over').style.display === 'flex') return;
        const weightedList = [];
        randomEvents.forEach(event => { for (let i = 0; i < event.weight; i++) weightedList.push(event.func); });
        const randomEventFunc = weightedList[Math.floor(Math.random() * weightedList.length)];
        randomEventFunc();
    }, randBetween(20000, 30000));
}
function stopRandomEvents() {
    if (randomEventTimer) clearInterval(randomEventTimer);
    randomEventTimer = null;
}

function startDecorationUpdates() {
    stopDecorationUpdates();
    const decorations = document.querySelectorAll('.path-decoration');
    if (decorations.length === 0) return;
    decorationInterval = setInterval(() => {
        if (!walkingCat) return;
        const catRect = walkingCat.getBoundingClientRect();
        const catCenterX = catRect.left + catRect.width / 2;
        decorations.forEach(deco => {
            const decoRect = deco.getBoundingClientRect();
            const decoCenterX = decoRect.left + decoRect.width / 2;
            const distance = Math.abs(catCenterX - decoCenterX);
            if (distance < 50) {
                deco.classList.add('shaking');
            } else {
                deco.classList.remove('shaking');
            }
        });
    }, 100);
}

function stopDecorationUpdates() {
    if (decorationInterval) {
        clearInterval(decorationInterval);
        decorationInterval = null;
    }
}

function positionCurtain() {
    if (!curtainElement || !displayArea) return;
    const displayRect = displayArea.getBoundingClientRect();
    const mainAreaRect = document.getElementById('main-area').getBoundingClientRect();
    curtainElement.style.left = `${displayRect.left - mainAreaRect.left}px`;
    curtainElement.style.top = `${displayRect.top - mainAreaRect.top}px`;
    curtainElement.style.width = `${displayRect.width}px`;
    curtainElement.style.height = `${displayRect.height}px`;
    curtainElement.style.borderRadius = window.getComputedStyle(displayArea).borderRadius;
    curtainElement.style.display = 'block';
}

function toggleCurtain(open) {
    if (!curtainElement) return;
    if (!game.isCurtainEnabled) {
        curtainElement.classList.remove('closed');
        curtainElement.classList.add('open');
        return;
    }
    if (open) {
        curtainElement.classList.remove('closed');
        curtainElement.classList.add('open');
    } else {
        curtainElement.classList.remove('open');
        curtainElement.classList.add('closed');
    }
}

function startCurtainRandomToggle() {
    stopCurtainRandomToggle();
    curtainTimer = setInterval(() => {
        if (game.lock || !game.isCurtainEnabled || document.getElementById('level-finish').style.display === 'flex' || document.getElementById('game-over').style.display === 'flex') {
            toggleCurtain(true);
            return;
        }
        const shouldClose = Math.random() < 0.5;
        if (shouldClose) {
            toggleCurtain(false);
            setTimeout(() => {
                toggleCurtain(true);
            }, 2000);
        } else {
            toggleCurtain(true);
        }
    }, randBetween(20000, 30000));
}

function stopCurtainRandomToggle() {
    if (curtainTimer) {
        clearInterval(curtainTimer);
        curtainTimer = null;
    }
}

// =================================================================================
// START OF MODIFICATION: Handle screen rotation by refreshing the layout.
// =================================================================================
// (æºæ–‡ä»¶é€»è¾‘)
/* æ ¸å¿ƒå‡½æ•° */
function handleOrientation(e) {
 // æ£€æµ‹ä»æ¨ªå±åˆ‡å›ç«–å±
  if (e.matches === false && isLandscape === true) {
    const container = document.getElementById('game-container');
    container.classList.add('rotate-transition');

    // ç­‰å¾…åŠ¨ç”»å®Œæˆååˆ·æ–°å¸ƒå±€
    setTimeout(() => {
      handleRotationRefresh();
      container.classList.remove('rotate-transition');
    }, 700);
  }
    document.body.classList.toggle('landscape', isLandscape);
    isLandscape = e.matches;      // true = æ¨ªå±
    updateToolButtons();          // åªæ›´æ–°æŒ‰é’®çŠ¶æ€å³å¯
    // å¯é€‰ï¼šæ¨ªç«–åˆ‡æ¢æ—¶ï¼Œé‡æ–°å¸ƒå±€
    handleRotationRefresh();      
}

/* ç›‘å¬ä¸€æ¬¡å°±å¤Ÿ */
window.matchMedia("(orientation: landscape)").addEventListener('change', handleOrientation);

function handleRotationRefresh() {
    if (game.lock) return;
    // æ—‹è½¬åé‡æ–°è®¡ç®— layout
    const remainingCards = game.board.filter(c => !c.matched);
    game.board = repositionCardsAndLayout(remainingCards, LEVELS[game.level - 1]);
    renderAll();
    // Lock the game during refresh
    game.lock = true;
    if (isLandscape) {
       showEventMessage('âœ¨', 'å‘ç°æ–°å¤§é™†ï¼Œ<br>æ’¤é”€åŠŸèƒ½è¢«ç¦ç”¨äº†ã€‚');
    }

    game.stepStack = [];
   
    // After a short delay to allow the screen to resize, re-layout the cards
    setTimeout(() => {
        // Recalculate the layout with the new screen dimensions
        game.board = repositionCardsAndLayout(remainingCards, LEVELS[game.level - 1]);
        
        // Re-render the entire game state
        renderAll();
        
        // Unlock the game
        game.lock = false;
    }, 250); // 250ms delay to ensure browser has completed the rotation
  }

// æœ€åï¼Œæ‰¾åˆ° DOMContentLoaded äº‹ä»¶ç›‘å¬å™¨ï¼Œå¹¶å°†é‡Œé¢çš„ window.addEventListener('resize', ...) è¿™ä¸€è¡Œåˆ é™¤æˆ–æ³¨é‡Šæ‰ï¼Œ
// å› ä¸ºå±å¹•æ–¹å‘çš„æ”¹å˜å·²ç»ç”±ä¸Šé¢çš„ handleOrientation ç»Ÿä¸€å¤„ç†äº†ã€‚
// window.addEventListener('resize', debounce(handleResize, 200)); // <--- åˆ é™¤è¿™ä¸€è¡Œ
// =================================================================================
// END OF MODIFICATION
// =================================================================================
function updateAutoCollectStatus() {
  if (!autoCollectBtn) return;
  autoCollectCountEl.textContent = autoCollectCount;

  if (autoCollectActive && !autoCollectPaused) {
    autoCollectBtn.innerHTML = `æš‚åœğŸª½ (<span id="auto-collect-count">${autoCollectCount}</span>)`;
    autoCollectBtn.disabled = false;
    autoCollectBtn.title = 'ç‚¹å‡»æš‚åœè‡ªåŠ¨æ”¶é›†';
  } else if (autoCollectPaused) {
    autoCollectBtn.innerHTML = `ç»§ç»­ğŸª½ (<span id="auto-collect-count">${autoCollectCount}</span>)`;
    autoCollectBtn.disabled = false;
    autoCollectBtn.title = 'ç‚¹å‡»ç»§ç»­è‡ªåŠ¨æ”¶é›†';
  } else {
    autoCollectBtn.innerHTML = `è‡ªåŠ¨ğŸª½ (<span id="auto-collect-count">${autoCollectCount}</span>)`;
    autoCollectBtn.title = 'ç‚¹å‡»å¼€å§‹è‡ªåŠ¨æ”¶é›†';
    autoCollectBtn.disabled = autoCollectCount <= 0 || !(findDisplayAreaTriple() || findAnyTriple());
  }
}

updateAutoCollectStatus();
function findDisplayAreaTriple() {
  if (!game.displayCards) return null;
  for (const set of game.displayCards) {
    if (set.matched) continue;
    const icon = set.cards[0].icon;
    const tempCount = game.temp.filter(c => !c.matched && c.icon === icon).length;
    const boardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board) && c.icon === icon);
    const needCount = 3 - tempCount;
    if (needCount > 0 && boardCards.length >= needCount) {
      return boardCards.slice(0, needCount).map(c => c.id);
    }
  }
  return null;
}

function handleDeviceMotion(event) {
  if (game.lock || game.toolUses.shuffle <= 0) return;
  const currentTime = new Date().getTime();
  if ((currentTime - lastShakeTime) > 1500) {
    const acc = event.accelerationIncludingGravity;
    const threshold = 18;
    if (Math.abs(acc.x) > threshold || Math.abs(acc.y) > threshold) {
      lastShakeTime = currentTime;
      shuffleStep();
      game.toolUses.shuffle--;
      updateToolButtons();
      showMessage('ä½ æ‘‡åŠ¨äº†æ‰‹æœºï¼Œè‡ªåŠ¨ä½¿ç”¨äº†ä¸€æ¬¡æ´—ç‰Œï¼', '#3e5a2b');

      if (autoCollectActive && !autoCollectPaused) scheduleAutoCollectAfterIdle(); // â† æ–°å¢
    }
  }
}

// Event Listeners
document.addEventListener('DOMContentLoaded', function() {
    // Prevent copy, paste, and cut
    ['copy', 'paste', 'cut'].forEach(event => {
        document.addEventListener(event, e => e.preventDefault());
    });
    
    initializeRealisticLoadingScreen();
    attemptVideoAutoplay();
    
    if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', handleDeviceMotion);
    } else {
        console.log("æ­¤è®¾å¤‡ä¸æ”¯æŒæ‘‡ä¸€æ‘‡åŠŸèƒ½ã€‚");
    }

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        playBgm(false);
    } else {
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().catch(e => console.error("AudioContext resume failed on visibility change.", e));
        }
        // è§£å†³ nap çŠ¶æ€æ®‹ç•™
        if (game && game.board) {
            game.board.forEach(card => { card.isNapping = false; });
        }
        renderAll();
    }
});

    const feedbackDiv = document.createElement('div');
    feedbackDiv.style.cssText = 'color: red; font-size: 12px; margin-top: 5px;';
    codeInput.parentNode.insertBefore(feedbackDiv, codeInput.nextSibling);
    codeInput.addEventListener('input', function() {
        const code = codeInput.value.trim();
        feedbackDiv.textContent = '';
        codeInput.style.borderColor = '';
        const codeRegex = /^[\u4e00-\u9fa5a-zA-Z0-9]*$/;
        if (code.length === 7) {
            if (codeRegex.test(code)) {
                feedbackDiv.textContent = 'å­—ç¬¦æ•°æ­£ç¡®';
                feedbackDiv.style.color = 'green';
                codeInput.style.borderColor = 'green';
                codeBtn.disabled = false;
                codeBtn.click();
            } else {
                feedbackDiv.textContent = 'å…‘æ¢ç åŒ…å«ä¸æ”¯æŒçš„å­—ç¬¦';
                feedbackDiv.style.color = 'red';
                codeInput.style.borderColor = 'red';
                codeBtn.disabled = true;
            }
        } else if (code.length < 7) {
            feedbackDiv.textContent = `è¿˜å¯è¾“å…¥ ${7 - code.length} ä½`;
            feedbackDiv.style.color = 'orange';
            codeInput.style.borderColor = 'orange';
        } else {
            codeBtn.disabled = true;
        }
    });
    codeBtn.addEventListener('click', function() {
       codeInput.value = '';
       feedbackDiv.textContent = '';
       codeInput.style.borderColor = '';
    });
    codeBtn.disabled = true;
    codeInput.addEventListener('keyup', e => { if (e.key === 'Enter' && !codeBtn.disabled) codeBtn.click(); });

    // We still call handleResize once to set initial positions, but don't listen for resize events anymore.
    

    // MODIFIED: Added event delegation for both touch and mouse events
    cardStackArea.addEventListener('click', function(e) {
        const cardEl = e.target.closest('.card:not(.disabled)');
        if (cardEl && cardEl.dataset.id) {
            const cardId = parseInt(cardEl.dataset.id, 10);
            clickCard(cardId);
        }
    });

    cardStackArea.addEventListener('touchstart', function(e) {
        e.preventDefault();
        Array.from(e.changedTouches).forEach(touch => {
            const touchedEl = document.elementFromPoint(touch.clientX, touch.clientY);
            if (touchedEl) {
                const cardEl = touchedEl.closest('.card:not(.disabled)');
                if (cardEl && cardEl.dataset.id) {
                    const cardId = parseInt(cardEl.dataset.id, 10);
                    clickCard(cardId);
                }
            }
        });
    }, { passive: false });

    skipOutroBtn.addEventListener('click', () => handleCloseGame('level'));
});

undoBtn.onclick = function(){
  if(game.toolUses.undo > 0 && game.stepStack.length > 0){
    undoStep();
    game.toolUses.undo--;
    updateToolButtons();
  } else if (game.toolUses.undo > 0 && game.stepStack.length === 0) {
    showMessage('æ— æ³•æ’¤é”€æ›´å¤š', '#888');
  }
};
hintBtn.onclick = function(){
  if(game.toolUses.hint > 0){
    hintStep();
    game.toolUses.hint--;
    updateToolButtons();
  }
};
shuffleBtn.onclick = function(){
  if(game.toolUses.shuffle > 0){
    shuffleStep();
    game.toolUses.shuffle--;
    updateToolButtons();
    if (autoCollectActive && !autoCollectPaused) scheduleAutoCollectAfterIdle(); // â† æ–°å¢
  }
};
reviveBtn.onclick = reviveGame; // Added event listener for revive button in tools bar
reviveBtnGameOver.onclick = reviveGame; // Added event listener for revive button on game over screen

restartCurrentLevelBtn.onclick = () => showConfirm('ç¡®å®šè¦é‡æ–°å¼€å§‹å½“å‰å…³å¡å—ï¼Ÿ', () => {
    stopRandomEvents();
    stopCurtainRandomToggle();
    stopDecorationUpdates();
    startGame(game.level);
    showMessage('å…³å¡å·²é‡æ–°å¼€å§‹ï¼', '#3e5a2b');
});
codeBtn.onclick = function(){
  let val = codeInput.value.trim().toLowerCase();
  if (REDEMPTION_CODES[val]) {
    const rewards = REDEMPTION_CODES[val];
    let rewardMsgs = [];

    if (rewards.type === "skip_level") {
      game.board.forEach(card => card.matched = true);
      game.score = game.targetScore;
      renderBoard();
      renderProgressAndScore();
      checkWin();
      showMessage(`å…‘æ¢æˆåŠŸï¼å½“å‰å…³å¡å·²è·³è¿‡ï¼`, "#3e5a2b");
    } else if (rewards.type === "curtain_off") {
        game.isCurtainEnabled = false;
        toggleCurtain(true);
        stopCurtainRandomToggle();
        showMessage(`å…‘æ¢æˆåŠŸï¼å¹•å¸ƒå·²åœ¨æœ¬å…³å¡å…³é—­ï¼`, "#3e5a2b");
    } else {
        if (rewards.undo) { game.toolUses.undo += rewards.undo; rewardMsgs.push(`æ’¤é”€x${rewards.undo}`); }
        if (rewards.hint) { game.toolUses.hint += rewards.hint; rewardMsgs.push(`æç¤ºx${rewards.hint}`); }
        if (rewards.shuffle) { game.toolUses.shuffle += rewards.shuffle; rewardMsgs.push(`æ´—ç‰Œx${rewards.shuffle}`); }
        if (rewards.revive) { game.toolUses.revive += rewards.revive; rewardMsgs.push(`å¤æ´»å¡x${rewards.revive}`); }
        if (rewards.autoCollect) {
            autoCollectCount += rewards.autoCollect;
            rewardMsgs.push(`è‡ªåŠ¨æ”¶é›†x${rewards.autoCollect}`);
        }
        
        if (rewardMsgs.length > 0) {
            showMessage('å…‘æ¢æˆåŠŸï¼è·å¾— ' + rewardMsgs.join('ï¼Œ'), "#3e5a2b");
        }
    }
    updateToolButtons();
    updateAutoCollectStatus();
  } else {
    showMessage('å…‘æ¢ç é”™è¯¯', "#c0392b");
  }
  codeInput.value = '';
};
musicToggleBtn.onclick = function(){
  game.bgmOn = !game.bgmOn;
  this.innerHTML = game.bgmOn ? 'ğŸ¼' : 'ğŸ”‡';
  playBgm(game.bgmOn);
};
startBtn.onclick = function(){
  document.getElementById('start-screen').style.display = 'none';
  initAudio(); 
  startGame(1);
};
nextBtn.onclick = function(){
  document.getElementById('level-finish').style.display = 'none';
  startGame(2);
};
retryBtnLevelFinish.onclick = function(){
  document.getElementById('level-finish').style.display = 'none';
  startGame(game.level);
};
retryBtnGameOver.onclick = function(){
  document.getElementById('game-over').style.display = 'none';
  startGame(game.level);
};
gobangBtn.onclick = () => window.open('https://www.kaiyuanzhu.qzz.io/kaiyuan/', '_blank');
restartGameBtn.onclick = () => window.location.href = 'https://www.kaiyuanzhu.qzz.io/cat/';
closeGameBtnLevel.onclick = () => handleCloseGame('level');
closeGameBtnGameOver.onclick = () => handleCloseGame('gameover');

function initializeRealisticLoadingScreen() {
    const loadingScreen = document.getElementById('loading-screen');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');
    const LOAD_TIMEOUT = 5000;
    const assetsToLoad = [
        { type: 'image', src: 'me.png', name: 'å›¾æ ‡' },
        { type: 'image', src: 'mao3.webp', name: 'åŠ è½½èƒŒæ™¯' },
        { type: 'image', src: 'mao1.webp', name: 'é€šå…³èƒŒæ™¯' },
        { type: 'image', src: 'mao.webp', name: 'å¼€å§‹èƒŒæ™¯' },
        { type: 'image', src: 'cat1.webp', name: 'æ¸¸æˆèƒŒæ™¯' },
        { type: 'video', src: 'aimao.mp4', name: 'å¼€å§‹åŠ¨ç”»' },
        { type: 'video', src: 'mao2.mp4', name: 'å½©è›‹è§†é¢‘' },
        { type: 'image', src: 'mao2.webp', name: 'å½©è›‹å›¾ç‰‡' },
        { type: 'audio', src: 'kaa.mp3', name: 'ç‚¹å‡»éŸ³æ•ˆ' },
        { type: 'audio', src: 'Sukidakara.mp3', name: 'èƒŒæ™¯éŸ³ä¹' },
        { type: 'image', src: 'run.gif', name: 'è·‘åŠ¨çŒ«å’ªGIF' } // Added run.gif to preload list
    ];
    let assetsLoaded = 0;
    const totalAssets = assetsToLoad.length;
    const updateProgress = () => {
        assetsLoaded++;
        const progress = (assetsLoaded / totalAssets) * 100;
        progressBar.style.width = progress + '%';
        if (assetsLoaded === totalAssets) {
            loadingText.textContent = 'å®Œæˆ!';
            setTimeout(() => {
                loadingScreen.style.opacity = '0';
                loadingScreen.addEventListener('transitionend', () => {
                    loadingScreen.style.display = 'none';
                    document.title = "è¶…çº§å–µå–µ";
                    initializeGame();
                }, { once: true });
            }, 400);
        } else {
            loadNextAsset();
        }
    };
    const loadAsset = (asset) => {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Timeout loading ${asset.src}`));
            }, LOAD_TIMEOUT);
            const successHandler = () => {
                clearTimeout(timeoutId);
                resolve();
            };
            const errorHandler = () => {
                clearTimeout(timeoutId);
                reject(new Error(`Failed to load ${asset.src}`));
            };
            switch (asset.type) {
                case 'image':
                    const img = new Image();
                    img.onload = successHandler;
                    img.onerror = errorHandler;
                    img.src = asset.src;
                    break;
                case 'audio':
                    fetch(asset.src)
                        .then(response => {
                            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                            return response.blob();
                        })
                        .then(() => successHandler())
                        .catch(errorHandler);
                    break;
                case 'video':
                    const video = document.createElement('video');
                    video.addEventListener('canplaythrough', successHandler, { once: true });
                    video.onerror = errorHandler;
                    video.src = asset.src;
                    video.load();
                    break;
            }
        });
    };
    const loadNextAsset = async () => {
        if (assetsLoaded >= totalAssets) return;
        const asset = assetsToLoad[assetsLoaded];
        loadingText.textContent = `æ­£åœ¨åŠ è½½ ${asset.name}... (${assetsLoaded + 1}/${totalAssets})`;
        try {
            await loadAsset(asset);
        } catch (error) {
            console.error(error.message);
        } finally {
            updateProgress();
        }
    };
    loadNextAsset();
}

function attemptVideoAutoplay() {
    const video = document.getElementById('start-screen-video');
    if (!video) return;
    const playPromise = video.play();
    if (playPromise !== undefined) {
        playPromise.catch(error => {
            console.log("Video direct play failed, waiting for user interaction.", error);
            document.body.addEventListener('touchstart', function onFirstTouch() {
                video.play().catch(e => console.error("Video playback failed after touch:", e));
                document.body.removeEventListener('touchstart', onFirstTouch);
            }, { once: true });
        });
    }
    if (typeof WeixinJSBridge == "object" && typeof WeixinJSBridge.invoke == "function") {
        WeixinJSBridge.invoke('getNetworkType', {}, e => video.play().catch(err => console.error("Video playback failed in WeixinJSBridge:", err)));
    } else {
        document.addEventListener("WeixinJSBridgeReady", () => WeixinJSBridge.invoke('getNetworkType', {}, e => WeixinJSBridge.invoke('getNetworkType', {}, e => video.play().catch(err => console.error("Video playback failed on WeixinJSBridgeReady:", err)))), false);
    }
}

function positionCatWalker() {
    const displayArea = document.getElementById('display-area');
    const catPath = document.getElementById('cat-path');
    const mainArea = document.getElementById('main-area');
    if (!displayArea || !catPath || !mainArea) return;
    const displayAreaBottomRelativeToMainArea = displayArea.offsetTop + displayArea.offsetHeight;
    // Adjust catPath top to align the cat GIF correctly above the display area
    // The GIF is 50px tall, and its top is at -30px relative to catPath. So its bottom is at 20px relative to catPath.
    // We want the bottom of the cat to be slightly above the display area.
    // Let's assume cat's bottom should be at displayAreaBottomRelativeToMainArea + 5px
    // catPath.top = (displayAreaBottomRelativeToMainArea + 5px) - (50px - 30px) = displayAreaBottomRelativeToMainArea - 15px
    catPath.style.top = `${displayAreaBottomRelativeToMainArea - 15}px`; 
    catPath.style.width = `${mainArea.offsetWidth}px`;
}

function positionWigglingCat(wigglingCatEl, slotIndex) {
    const tempSlots = document.querySelectorAll('#temp-area .temp-slot');
    const cardStackArea = document.getElementById('card-stack-area');
    const mainArea = document.getElementById('main-area');
    if (!wigglingCatEl || tempSlots.length === 0 || !cardStackArea || !mainArea || slotIndex < 0 || slotIndex >= tempSlots.length) {
        if(wigglingCatEl) wigglingCatEl.style.display = 'none';
        return;
    }
    const targetTempSlot = tempSlots[slotIndex];
    const cardStackRect = cardStackArea.getBoundingClientRect();
    const targetTempSlotRect = targetTempSlot.getBoundingClientRect();
    const mainAreaRect = mainArea.getBoundingClientRect();
    const gapMidpointAbsolute = cardStackRect.bottom + (targetTempSlotRect.top - cardStackRect.bottom) / 2;
    const topRelativeToMainArea = gapMidpointAbsolute - mainAreaRect.top;
    const leftRelativeToMainArea = (targetTempSlotRect.left + targetTempSlot.offsetWidth / 2) - mainAreaRect.left;
    wigglingCatEl.style.top = `${topRelativeToMainArea - (wigglingCatEl.offsetHeight / 2)}px`;
    wigglingCatEl.style.left = `${leftRelativeToMainArea}px`;
    wigglingCatEl.style.display = 'block';
}

function hideWigglingCats() {
    wigglingCat1.style.display = 'none';
    wigglingCat4.style.display = 'none';
    wigglingCat7.style.display = 'none';
}

function updateWigglingCatVisibility() {
    if (game.score >= game.targetScore) {
        positionWigglingCat(wigglingCat1, 0);
        positionWigglingCat(wigglingCat4, 3);
        positionWigglingCat(wigglingCat7, 6);
    } else {
        hideWigglingCats();
    }
}

function playLevel2Outro() {
    game.lock = true;
    playBgm(false);
    level2OutroScreen.style.display = 'flex';
    outroLoadingText.style.display = 'block';
    skipOutroBtn.style.display = 'block';
    outroVideo.style.display = 'none';
    outroImage.style.display = 'none';
    const finalCloseAction = () => handleCloseGame('level');
    outroVideoTimeout = setTimeout(() => {
        outroVideo.style.display = 'none';
        outroImage.style.display = 'block';
        outroLoadingText.textContent = 'è§†é¢‘æ— æ³•æ’­æ”¾ï¼Œæ˜¾ç¤ºå›¾ç‰‡...';
        setTimeout(finalCloseAction, 3000);
    }, 7000);
    outroVideo.load();
    const playPromise = outroVideo.play();
    if (playPromise !== undefined) {
        playPromise.then(() => {
            outroVideo.style.display = 'block';
            outroLoadingText.style.display = 'none';
            if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        }).catch(error => {
            outroVideo.style.display = 'none';
            outroImage.style.display = 'block';
            outroLoadingText.textContent = 'è§†é¢‘æ— æ³•æ’­æ”¾ï¼Œæ˜¾ç¤ºå›¾ç‰‡...';
            if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
            setTimeout(finalCloseAction, 3000);
        });
    }
    outroVideo.onended = () => {
        if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        finalCloseAction();
    };
    outroVideo.onerror = (e) => {
        if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        outroVideo.style.display = 'none';
        outroImage.style.display = 'block';
        outroLoadingText.textContent = 'è§†é¢‘åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºå›¾ç‰‡...';
        setTimeout(finalCloseAction, 3000);
    };
}

function debounce(func, delay) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), delay);
  };
}
// è‡ªåŠ¨æ”¶é›†ä¸»å¾ªç¯
function startAutoCollect() {
  if (autoCollectCount <= 0 || autoCollectActive) return;
  
  // ç¬¬ä¸€æ¬¡ç‚¹å‡»æ—¶å¯ç”¨è‡ªåŠ¨æ”¶é›†
  game.autoCollectEnabled = true;
  
  // æ˜¾ç¤ºå¯ç”¨æç¤º
  showMessage('å·²å¯ç”¨è‡ªåŠ¨æ”¶é›†åŠŸèƒ½', '#3e5a2b');
  autoCollectActive = true;
  updateAutoCollectStatus();
  autoCollectStep();
  startAutoCollectIdleWatcher();
}
function startAutoCollectIdleWatcher() {
  if (autoCollectIdleWatcher) return; // é˜²æ­¢é‡å¤å¯åŠ¨
  autoCollectIdleWatcher = setInterval(() => {
    if (autoCollectPaused && autoCollectActive) {
      const now = Date.now();
      if (now - lastManualClickTime > 2000) {
        autoCollectPaused = false;
        showMessage('è‡ªåŠ¨æ”¶é›†å·²æ¢å¤');
		showBlinkingCat(); // â† æ·»åŠ è¿™ä¸€è¡Œ
        autoCollectStep();
        updateAutoCollectStatus();
      }
    }
  }, 1000);
}
function stopAutoCollectIdleWatcher() {
  if (autoCollectIdleWatcher) {
    clearInterval(autoCollectIdleWatcher);
    autoCollectIdleWatcher = null;
  }
}

function autoCollectStep() {
  if (autoCollectTimer) clearTimeout(autoCollectTimer);
  updateAutoCollectStatus();

  if (!autoCollectActive || autoCollectPaused) return;
  if (game.lock || game.flyingCardCount > 0 || AnimBarrier.count > 0) {
    scheduleAutoCollectAfterIdle();
    return;
  }
  if (autoCollectCount <= 0) {
    showMessage('è‡ªåŠ¨æ”¶é›†æ¬¡æ•°ç”¨å°½');
    stopAutoCollect();
    return;
  }

  const currentTempCount = game.temp.filter(c => !c.matched).length;
  const safeThreshold = TEMP_LIMIT - 2;

  // å·¥å…·å‡½æ•°ï¼šç»Ÿè®¡ temp ä¸å¯ç‚¹å‡»ç‰Œ
  const tempCounts = (() => {
    const map = {};
    game.temp.forEach(c => { if (!c.matched) map[c.icon] = (map[c.icon] || 0) + 1; });
    return map;
  })();
  const clickableBoardCards = game.board.filter(c => !c.matched && isCardClickable(c, game.board));
  const boardIconMap = (() => {
    const map = {};
    clickableBoardCards.forEach(c => {
      (map[c.icon] = map[c.icon] || []).push(c);
    });
    return map;
  })();
  const spaceLeft = TEMP_LIMIT - currentTempCount;

  // è¾…åŠ©ï¼šæ— å¯ä¸‰æ¶ˆæ—¶å°è¯•è‡ªåŠ¨æ´—ç‰Œï¼›è‹¥æ— æ¬¡æ•°åˆ™æç¤ºè¾“å…¥å…‘æ¢ç 
  function attemptAutoShuffleOrPrompt() {
    if (game.toolUses.shuffle > 0) {
      game.toolUses.shuffle--;
      updateToolButtons();
      showMessage('æ— ä¸‰æ¶ˆï¼Œè‡ªåŠ¨æ´—ç‰Œä¸€æ¬¡', '#3e5a2b');
      shuffleStep(); // å†…éƒ¨å·²å¤„ç†åŠ¨ç”»ä¸è§£é”ï¼Œå¹¶ä¼šè°ƒç”¨ tryResumeAutoCollect
      scheduleAutoCollectAfterIdle();
      } else {
      // åªåœ¨æœ¬å…³ç¬¬ä¸€æ¬¡å‡ºç°è¯¥æƒ…å½¢æ—¶æç¤º
      if (!game.noShuffleCodePromptShown) {
        game.noShuffleCodePromptShown = true;
        showRiskModal(
          'å½“å‰æ— å¯ä¸‰æ¶ˆï¼Œä¸”æ´—ç‰Œæ¬¡æ•°ä¸º 0ã€‚<br>è¯·è¾“å…¥å…‘æ¢ç è·å–æ´—ç‰Œæ¬¡æ•°ï¼Œä¾‹å¦‚ï¼š<b>haogege</b>ï¼Œ<b>æˆ–è€…å»é—®ä»–</b>ã€‚',
          'warning'
        );
        setTimeout(() => { try { codeInput && codeInput.focus(); } catch(e){} }, 80);
      }
      stopAutoCollect();
      updateAutoCollectStatus();
      return;
    }
  }

  // æ™ºèƒ½å¯è¡Œæ€§æ£€æŸ¥ï¼šæ˜¯å¦å­˜åœ¨â€œåœ¨å®¹é‡é™åˆ¶å†…èƒ½å®Œæˆçš„ä¸‰æ¶ˆè·¯å¾„â€
  const hasCapacityFeasibleTriple = (() => {
    const icons = new Set([
      ...Object.keys(tempCounts),
      ...Object.keys(boardIconMap)
    ]);
    for (const icon of icons) {
      const t = tempCounts[icon] || 0;
      const b = (boardIconMap[icon] || []).length;
      const need = Math.max(0, 3 - t);
      if (need > 0 && b >= need && need <= spaceLeft) return true;
    }
    return false;
  })();

  // è‹¥åœ¨å®¹é‡é™åˆ¶å†…å®Œå…¨æ— æ³•ç»„æˆä»»ä½•ä¸‰æ¶ˆï¼šç›´æ¥è‡ªåŠ¨æ´—ç‰Œæˆ–æç¤ºå…‘æ¢
  if (!hasCapacityFeasibleTriple) {
    attemptAutoShuffleOrPrompt();
    return;
  }

  // 1ï¸âƒ£ ä¼˜å…ˆçº§æœ€é«˜ï¼šç«‹å³ä¸‰æ¶ˆï¼ˆtemp å·²æœ‰ 2 å¼  â†’ åªéœ€ç‚¹ 1 å¼ ï¼‰ï¼Œä¸”ä¸è¶…å®¹é‡
  const tryImmediateTriple = () => {
    for (const [icon, count] of Object.entries(tempCounts)) {
      if (count === 2 && spaceLeft >= 1) {
        const board = boardIconMap[icon] || [];
        if (board.length > 0) {
          const id = board[0].id;
          setTimeout(() => clickCard(id, true), 0);
          return true;
        }
      }
    }
    return false;
  };
  if (tryImmediateTriple()) return;

  // 2ï¸âƒ£ å…¶æ¬¡ï¼šå±•ç¤ºåŒºçš„ä¸‰æ¶ˆï¼ˆå±•ç¤ºåŒºå›¾æ ‡ + temp + å¯ç‚¹å‡»ç‰Œï¼‰ï¼Œä¸”ä¸è¶…å®¹é‡
  const tryDisplayTriple = () => {
    for (const set of game.displayCards) {
      if (set.matched) continue;
      const icon = set.cards[0].icon;
      const t = (tempCounts[icon] || 0);
      const need = 3 - t;
      if (need <= 0) continue;
      const picks = (boardIconMap[icon] || []).slice(0, need);
      if (picks.length === need && need <= spaceLeft) {
        picks.forEach((c, i) => setTimeout(() => clickCard(c.id, true), i * 300));
        return true;
      }
    }
    return false;
  };
  if (tryDisplayTriple()) return;

  // 3ï¸âƒ£ æœ€åï¼šå…¶ä»–ä»»æ„ä¸‰æ¶ˆç»„åˆï¼ˆtemp + boardï¼‰ï¼Œä¸”ä¸è¶…å®¹é‡
  const tryGenericTriple = () => {
    const icons = new Set([
      ...Object.keys(tempCounts),
      ...Object.keys(boardIconMap)
    ]);
    for (const icon of icons) {
      const t = tempCounts[icon] || 0;
      const need = 3 - t;
      if (need <= 0) continue;
      const picks = (boardIconMap[icon] || []).slice(0, need);
      if (picks.length === need && need <= spaceLeft) {
        picks.forEach((c, i) => setTimeout(() => clickCard(c.id, true), i * 300));
        return true;
      }
    }
    return false;
  };
  if (tryGenericTriple()) return;

  // â© ä¸‰æ¶ˆå‡å¤±è´¥ï¼šè‡ªåŠ¨æ´—ç‰Œæˆ–æç¤ºå…‘æ¢
  attemptAutoShuffleOrPrompt();
  return;

  // ä¸‹é¢é€»è¾‘é€šå¸¸ä¸ä¼šèµ°åˆ°ï¼ˆä¸Šé¢ returnï¼‰ï¼Œä¿ç•™ä»¥å…¼å®¹éœ€è¦æ—¶çš„å…œåº•

  // NEW â©ï¼ˆä¼˜å…ˆçº§ä½äºæ‰€æœ‰ä¸‰æ¶ˆï¼‰ï¼šç©ºä½å……è¶³æ—¶çš„â€œå®‰å…¨è¯•ç‚¹å‡»â€
  // - æ¡ä»¶ï¼šspaceLeft â‰¥ 3
  // - ç›®çš„ï¼šåœ¨ä¸é€¼è¿‘å®¹é‡ä¸Šé™çš„å‰æä¸‹åŠ é€Ÿæ¨è¿›å±€é¢
  if (spaceLeft >= 3) {
    const safeProbe = clickableBoardCards.find(card => !willAddCardFail(card));
    if (safeProbe) {
      clickCard(safeProbe.id, true);
      return;
    }
  }

  // 4ï¸âƒ£ ä¿ç•™åŸé€»è¾‘ï¼šå¦‚æœæ¥è¿‘æ»¡ï¼Œåªå…è®¸æ‰§è¡Œèƒ½ç«‹å³ä¸‰æ¶ˆçš„æ“ä½œï¼›å¦åˆ™åœæ­¢ä»¥ä¿ç•™ä¸¤ä¸ªç©ºä½
  if (currentTempCount >= safeThreshold) {
    const reIcons = new Set([
      ...Object.keys(tempCounts),
      ...Object.keys(boardIconMap)
    ]);
    for (const icon of reIcons) {
      const t = tempCounts[icon] || 0;
      const need = 3 - t;
      if (need <= 0) continue;
      const picks = (boardIconMap[icon] || []).slice(0, need);
      if (picks.length === need && need <= spaceLeft) {
        picks.forEach((c, i) => setTimeout(() => clickCard(c.id, true), i * 300));
        return;
      }
    }
    // è‹¥ä»æ— ä¸‰æ¶ˆï¼Œæœ€åå†å°è¯•æ´—ç‰Œæˆ–æç¤º
    attemptAutoShuffleOrPrompt();
    return;
  }

  // 5ï¸âƒ£ å…¶ä»–é€»è¾‘ä¿ç•™ï¼šè‹¥ä»æ— ä¸‰æ¶ˆï¼Œå°è¯•â€œå®‰å…¨çš„ä»»æ„ç‚¹å‡»â€ï¼ˆä¸ä¼šå¯¼è‡´å¤±è´¥ï¼‰
  const safeNextMove = clickableBoardCards.find(card => !willAddCardFail(card));
  if (safeNextMove) {
    clickCard(safeNextMove.id, true);
    return;
  }

  // ğŸ›‘ æ— ä»»ä½•å®‰å…¨æ“ä½œï¼šå†å°è¯•æ´—ç‰Œæˆ–æç¤º
  attemptAutoShuffleOrPrompt();
}

// æ–°å¢ï¼šå®‰å…¨ç‚¹å‡»æ£€æŸ¥å‡½æ•°
function isSafeToClickCard(cardId) {
  const unMatchedTempCards = game.temp.filter(c => !c.matched).length;
  if (unMatchedTempCards >= TEMP_LIMIT) return false;

  // è·å–å½“å‰tempåŒºçš„å›¾æ ‡åˆ†å¸ƒ
  const tempIcons = {};
  game.temp.filter(c => !c.matched).forEach(c => {
    tempIcons[c.icon] = (tempIcons[c.icon] || 0) + 1;
  });

  // è·å–è¦ç‚¹å‡»çš„å¡ç‰‡
  const cardToClick = game.board.find(c => c.id === cardId);
  if (!cardToClick) return false;

  // æ¨¡æ‹Ÿæ·»åŠ è¿™å¼ å¡åçš„çŠ¶æ€
  const updatedTempIcons = { ...tempIcons };
  updatedTempIcons[cardToClick.icon] = (updatedTempIcons[cardToClick.icon] || 0) + 1;

  // æ£€æŸ¥æ˜¯å¦ä¼šå½¢æˆä¸‰æ¶ˆ
  if (Object.values(updatedTempIcons).some(count => count >= 3)) return true;

  // å¦‚æœåŠ å…¥åä¼šè¾¾åˆ°å€’æ•°1ä¸ªæ ¼
  if (unMatchedTempCards + 1 >= TEMP_LIMIT - 1) {
    // æ£€æŸ¥å‰©ä½™å¯ç‚¹å‡»å¡ç‰‡ä¸­æ˜¯å¦æœ‰æœºä¼šå½¢æˆä¸‰æ¶ˆ
    const remainingClickableCards = game.board.filter(c => 
      !c.matched && 
      isCardClickable(c, game.board) && 
      c.id !== cardId
    );

    // æ£€æŸ¥æ¯ä¸ªå›¾æ ‡æ˜¯å¦æœ‰å½¢æˆä¸‰æ¶ˆçš„å¯èƒ½
    for (const [icon, count] of Object.entries(updatedTempIcons)) {
      const neededForTriple = 3 - count;
      if (neededForTriple <= 0) continue;
      const availableMatches = remainingClickableCards.filter(c => c.icon === icon).length;
      if (availableMatches >= neededForTriple) return true;
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯èƒ½çš„ä¸‰æ¶ˆç»„åˆ
    return false;
  }

  // å¦‚æœè¿˜æœ‰è¶³å¤Ÿç©ºé—´ï¼Œåˆ™å…è®¸ç‚¹å‡»
  return true;
}
// æŸ¥æ‰¾display-areaä¼˜å…ˆä¸‰æ¶ˆï¼ˆå¯ç”¨tempåŒºå¡ç‰‡è¡¥è¶³ï¼Œè¿”å›éœ€ç‚¹å‡»çš„boardå¡idæ•°ç»„ï¼‰
function findAnyTriple() {
  let tempCounts = {};
  game.temp.forEach(c => {
    if (!c.matched) tempCounts[c.icon] = (tempCounts[c.icon] || 0) + 1;
  });

  let boardIcons = {};
  game.board.forEach(c => {
    if (!c.matched && isCardClickable(c, game.board)) {
      if (!boardIcons[c.icon]) boardIcons[c.icon] = [];
      boardIcons[c.icon].push(c.id);
    }
  });

  for (const [icon, ids] of Object.entries(boardIcons)) {
    const tempCount = tempCounts[icon] || 0;
    const needCount = 3 - tempCount;
    if (needCount > 0 && ids.length >= needCount) {
      return ids.slice(0, needCount);
    }
  }
  return null;
}

// æŸ¥æ‰¾ä»»æ„ä¸‰æ¶ˆï¼ˆå¯ç”¨tempåŒºè¡¥è¶³ï¼‰
function findAnyTriple() {
  let tempCounts = {};
  game.temp.forEach(c => {
    if (!c.matched) tempCounts[c.icon] = (tempCounts[c.icon] || 0) + 1;
  });
  let boardIcons = {};
  game.board.forEach(c => {
    if (!c.matched && isCardClickable(c, game.board)) {
      if (!boardIcons[c.icon]) boardIcons[c.icon] = [];
      boardIcons[c.icon].push(c.id);
    }
  });
  for (const [icon, ids] of Object.entries(boardIcons)) {
    const tempCount = tempCounts[icon] || 0;
    const needCount = 3 - tempCount;
    if (needCount > 0 && ids.length >= needCount) {
      return ids.slice(0, needCount);
    }
  }
  return null;
}

// æŒ‰é’®ç›‘å¬
autoCollectBtn.onclick = toggleAutoCollect;
function tryResumeAutoCollect() {
  if (autoCollectActive && !autoCollectPaused) {
    if (autoCollectTimer) clearTimeout(autoCollectTimer);
    // æ”¹ä¸ºå±éšœç©ºé—²åç»­è·‘ï¼Œé¿å…è¢«åŠ¨ç”»çŠ¶æ€æŠ¢è·‘
    scheduleAutoCollectAfterIdle();
    updateAutoCollectStatus();
  }
}
// åœ¨ç¡®è®¤æ¡†ä¹‹åæ·»åŠ æ–°çš„é£é™©æç¤ºæ¡†
function createRiskModal() {
  const modal = document.createElement('div');
  modal.id = 'risk-modal';
  modal.className = 'modal-overlay';
  modal.innerHTML = `
    <div class="modal-content" style="background: #fff3f3; border-color: #dc2626;">
      <p id="risk-msg" style="color: #991b1b;"></p>
      <div class="modal-buttons">
        <button id="risk-confirm" style="background: #fee2e2; border-color: #991b1b; color: #991b1b;">æˆ‘çŸ¥é“äº†</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);
  
  // æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬
  document.getElementById('risk-confirm').addEventListener('click', hideRiskModal);
}

// æ˜¾ç¤ºé£é™©æç¤ºæ¡†
function showRiskModal(msg, type = 'risk') {
  const modal = document.getElementById('risk-modal');
  if (!modal) {
    createRiskModal();
  }
  
  const modalContent = modal.querySelector('.modal-content');
  // æ ¹æ®ä¸åŒç±»å‹è®¾ç½®ä¸åŒçš„æ ·å¼
  switch(type) {
    case 'risk':
      modalContent.style.background = '#fff3f3';
      modalContent.style.borderColor = '#dc2626';
      break;
    case 'info':
      modalContent.style.background = '#f0f9ff';
      modalContent.style.borderColor = '#3b82f6';
      break;
    case 'warning':
      modalContent.style.background = '#fefce8';
      modalContent.style.borderColor = '#ca8a04';
      break;
  }
  modalContent.setAttribute('data-type', type);
  document.getElementById('risk-msg').innerHTML = msg;
  modal.style.display = 'flex';
  
  // æ·»åŠ éœ‡åŠ¨æ•ˆæœ
  if (navigator.vibrate && type === 'risk') {
    navigator.vibrate(100);
  }
}
// éšè—é£é™©æç¤ºæ¡†
function hideRiskModal() {
  const modal = document.getElementById('risk-modal');
  if (modal) {
    modal.style.display = 'none';
  }
}
function willAddCardFail(card) {
  let tempSim = game.temp.filter(c => !c.matched).map(c => c.icon);
  tempSim.push(card.icon);
  if (tempSim.length < TEMP_LIMIT) return false;
  let counts = {};
  tempSim.forEach(icon => counts[icon] = (counts[icon] || 0) + 1);
  if (Object.values(counts).some(cnt => cnt >= 3)) return false;
  return true;
}
function showBlinkingCat() {
  const cat = document.getElementById('blinking-cat');
  if (!cat) return;

  cat.textContent = 'ğŸ˜º';
  cat.style.animation = 'blink-cat 2s ease-in-out';
  cat.style.opacity = '1';

  setTimeout(() => {
    cat.style.opacity = '0';
    cat.style.animation = '';
    cat.textContent = '';
  }, 2000);
}
// ç»Ÿä¸€ç®¡ç†â€œå¿™é—²çŠ¶æ€â€ï¼Œå½“æ‰€æœ‰åŠ¨ç”»/é”/é£ç‰Œéƒ½ç©ºé—²æ—¶ï¼Œç»Ÿä¸€è§¦å‘ç»­è·‘å›è°ƒ
const AnimBarrier = {
  count: 0,
  tags: new Map(),
  queue: [],
  scheduled: false,

  begin(tag = 'unknown') {
    this.count++;
    this.tags.set(tag, (this.tags.get(tag) || 0) + 1);
  },

  end(tag = 'unknown') {
    const now = (this.tags.get(tag) || 0) - 1;
    if (now <= 0) this.tags.delete(tag); else this.tags.set(tag, now);
    this.count = Math.max(0, this.count - 1);
    this.tryFlush();
  },

  onIdle(cb) {
    if (this.isIdle()) cb();
    else this.queue.push(cb);
  },

  isIdle() {
    // å°† lock / flying ä¸€å¹¶è§†ä½œå±éšœ
    const busy = this.count > 0 || game.flyingCardCount > 0 || game.lock;
    return !busy;
  },

  tryFlush() {
    if (!this.isIdle()) return;
    if (this.scheduled) return;
    this.scheduled = true;
    setTimeout(() => {
      this.scheduled = false;
      if (!this.isIdle()) return;
      const cbs = this.queue.splice(0);
      cbs.forEach(cb => { try { cb(); } catch(e){ console.error(e); } });
    }, 0);
  }
};

// ç»Ÿä¸€çš„â€œç©ºé—²åå†ç»­è·‘è‡ªåŠ¨æ”¶é›†â€
function scheduleAutoCollectAfterIdle() {
  AnimBarrier.onIdle(() => {
    if (autoCollectActive && !autoCollectPaused) autoCollectStep();
  });
}
function applyTheme(level) {
  const container = document.getElementById('game-container');
  container.classList.remove('theme-starry-night', 'theme-renaissance');
  if (level === 1)      container.classList.add('theme-starry-night');
  else if (level === 2) container.classList.add('theme-renaissance');
}
</script>
</body>
</html>
