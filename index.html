<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
    />
    <title>乖乖加载中...</title>
    <link rel="icon" type="image/png" sizes="96x96" href="me.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap"
      rel="stylesheet"
    />
    <link rel="preload" href="mao3.webp" as="image" />
    <link rel="preload" href="mao1.webp" as="image" />
    <link rel="preload" href="font/iconfont.css" as="style" />
    <link rel="preload" href="css/style.css" as="style" />
    <link rel="preload" href="mao.webp" as="image" />
    <link rel="preload" href="aimao.mp4" as="video" />
    <link rel="preload" href="cat1.webp" as="image" />
    <link rel="preload" href="rose.webp" as="image" />
    <link rel="preload" href="lily.webp" as="image" />
    <link rel="preload" href="js/index.js" as="script" />
    <link rel="preload" href="run.gif" as="image" />
    <link rel="preload" href="kaa.mp3" as="audio" />
    <link rel="preload" href="Sukidakara.mp3" as="audio" />
    <link rel="preload" href="mao2.mp4" as="video" />
    <link rel="preload" href="mao2.webp" as="image" />

    <style>
      /* 添加屏幕过渡动画 */
      @keyframes rotateToPortrait {
        0% {
          transform: rotateY(90deg) scale(0.8);
          opacity: 0;
        }

        50% {
          transform: rotateY(0deg) scale(1.05);
          opacity: 1;
        }

        100% {
          transform: rotateY(0deg) scale(1);
          opacity: 1;
        }
      }

      .rotate-transition {
        animation: rotateToPortrait 0.7s ease-in-out forwards;
      }

      @media (orientation: landscape) {

        #display-area,
        #card-stack-area {
          max-width: 90vw;
          /* 增加最大宽度 */
          width: 90vw;
        }

        #display-area {
          min-height: 140px;
          /* 可根据需要增加高度以更突出显示区域 */
        }

        #card-stack-area {
          height: 75vh;
          /* 更高一点，使得比例更协调 */
        }
      }

      #pause-screen { z-index: 2600 !important; }

      #risk-modal .modal-content {
        animation: risk-modal-in 0.3s ease-out;
        min-width: 280px;
        max-width: 90%;
        width: auto;
        transition: all 0.3s ease;
      }

      #risk-modal .modal-content[data-type="info"] {
        background: #f0f9ff;
        border-color: #3b82f6;
      }

      #risk-modal .modal-content[data-type="risk"] {
        background: #fff3f3;
        border-color: #dc2626;
      }

      #risk-modal .modal-content[data-type="warning"] {
        background: #fefce8;
        border-color: #ca8a04;
      }

      #risk-modal button {
        padding: 8px 20px;
        font-size: 1rem;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: 'ZCOOL KuaiLe', cursive;
        background: white;
      }

      #risk-modal button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #risk-modal p {
        margin: 0 0 20px 0;
        line-height: 1.5;
      }

      /* 添加不同类型按钮的样式 */
      #risk-modal[data-type="info"] button {
        border-color: #3b82f6;
        color: #1d4ed8;
      }

      #risk-modal[data-type="risk"] button {
        border-color: #dc2626;
        color: #991b1b;
      }

      #risk-modal[data-type="warning"] button {
        border-color: #ca8a04;
        color: #854d0e;
      }

      @keyframes card-vanish {
        0% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
        }

        50% {
          transform: scale(1.1) rotate(5deg);
          opacity: 0.8;
        }

        100% {
          transform: scale(0.1) rotate(15deg) translateY(50px);
          opacity: 0;
        }
      }

      .temp-card.vanishing {
        position: relative;
        /* 确保 z-index 生效 */
        z-index: 10;
        animation: card-vanish 0.5s ease-out forwards;
      }

      /* 原有的 card-disappear 动画不再使用，可以安全移除或保留 */
      @keyframes card-disappear {
        from {
          opacity: 1;
          transform: scale(1) rotate(0deg);
        }

        to {
          opacity: 0;
          transform: scale(0.4) rotate(20deg);
        }
      }

      .temp-card.disappearing {
        animation: card-disappear 0.3s ease-out forwards;
      }

      /* 其他样式保持不变 */
      @keyframes card-float-out {
        0% {
          opacity: 0;
          transform: translateY(40px);
        }

        100% {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .card-floating-in {
        animation: fade-in-scale-glow 0.6s ease-out forwards;
      }

      @keyframes fade-in-scale-glow {
        0% {
          transform: scale(0.8);
          opacity: 0;
          box-shadow: none;
        }

        50% {
          transform: scale(1.05);
          opacity: 1;
          box-shadow: 0 0 12px rgba(200, 160, 230, 0.2);
        }

        100% {
          transform: scale(1);
          opacity: 1;
          box-shadow: 0 0 8px rgba(160, 130, 190, 0.1);
        }
      }

      @keyframes lid-open {
        0% {
          transform: rotateX(0deg);
          opacity: 1;
        }

        70% {
          transform: rotateX(80deg);
          opacity: 1;
        }

        100% {
          transform: rotateX(90deg);
          opacity: 0;
          visibility: hidden;
        }
      }

      @keyframes slot-flash {
        0% {
          background-color: #fdf5e6;
          box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        }

        50% {
          background-color: #fff8dc;
          box-shadow: inset 0 0 10px rgba(255, 215, 0, 0.8), 0 0 15px rgba(255, 215, 0, 0.5);
        }

        100% {
          background-color: #fdf5e6;
          box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        }
      }

      .temp-slot.clearing {
        animation: slot-flash 0.4s ease-out;
      }

      @keyframes pulse-scale {

        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
        }

        50% {
          transform: scale(1.05);
          opacity: 1;
        }
      }

      @keyframes text-progress {
        0% {
          content: ".";
        }

        33% {
          content: "..";
        }

        66% {
          content: "...";
        }

        100% {
          content: ".";
        }
      }

      @keyframes wave {

        0%,
        100% {
          transform: translateY(0) rotate(0deg);
        }

        25% {
          transform: translateY(-10px) rotate(2deg);
        }

        75% {
          transform: translateY(5px) rotate(-1deg);
        }
      }

      @keyframes show-card-property {
        0% {
          opacity: 0;
        }

        20% {
          opacity: 1;
        }

        80% {
          opacity: 1;
        }

        100% {
          opacity: 0;
        }
      }

      @keyframes fade-in-out-scale {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }

        50% {
          opacity: 1;
          transform: scale(1);
        }

        100% {
          opacity: 0;
          transform: scale(0.9);
        }
      }

      @keyframes shake {

        0%,
        100% {
          transform: translateX(0) rotate(0deg);
        }

        10%,
        30%,
        50%,
        70%,
        90% {
          transform: translateX(-3px) rotate(-1deg);
        }

        20%,
        40%,
        60%,
        80% {
          transform: translateX(3px) rotate(1deg);
        }
      }

      @keyframes score-pop {
        0% {
          opacity: 0;
          transform: translateY(0) scale(0.8);
        }

        20% {
          opacity: 1;
          transform: translateY(-15px) scale(1.1);
        }

        80% {
          opacity: 1;
          transform: translateY(-30px) scale(1);
        }

        100% {
          opacity: 0;
          transform: translateY(-40px) scale(0.7);
        }
      }

      .score-animation {
        position: absolute;
        font-size: 1.5rem;
        font-weight: bold;
        color: #4CAF50;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        animation: score-pop 1s ease-out forwards;
        z-index: 2000;
      }

      /* 吸入动画 (源文件效果) */
      @keyframes swirlIn {
        0% {
          transform: scale(1);
          opacity: 1;
        }

        100% {
          transform: scale(0.2);
          opacity: 0.5;
          /* 动画终点是父容器的中心 */
          left: 50%;
          top: 50%;
        }
      }

      /* 喷出动画 (源文件效果，虽然洗牌没用上，但最好保留) */
      @keyframes swirlOut {
        0% {
          transform: scale(0.2) rotate(720deg);
          opacity: 0.5;
          left: 50%;
          top: 50%;
        }

        100% {
          transform: scale(1) rotate(0deg);
          opacity: 1;
          left: var(--final-left);
          top: var(--final-top);
        }
      }

      /* 应用动画的类名 */
      .card.swirl-in {
        animation: swirlIn 0.6s ease-in forwards;
        z-index: 10;
      }

      .card.swirl-out {
        animation: swirlOut 0.6s ease-out forwards;
        z-index: 10;
      }

      @keyframes fade-in-out-heart {
        0% {
          opacity: 0;
          transform: scale(0.5);
        }

        50% {
          opacity: 1;
          transform: scale(1.2);
        }

        100% {
          opacity: 0;
          transform: scale(0.8);
        }
      }

      .heart-animation {
        position: absolute;
        font-size: 30px;
        color: #ff69b4;
        pointer-events: none;
        animation: fade-in-out-heart 2.5s ease-out infinite alternate;
        z-index: 1000;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
      }

      .confetti-container {
        position: absolute;
        top: -30vh;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
        z-index: 9999;
      }

      .confetti-piece {
        position: absolute;
        width: 8px;
        height: 16px;
        background: #f00;
        top: -20px;
        opacity: 0;
        animation: fall linear forwards;
      }

      @keyframes fall {
        0% {
          transform: translateY(0) rotateZ(0deg);
          opacity: 1;
        }

        100% {
          transform: translateY(110vh) rotateZ(720deg);
          opacity: 0;
        }
      }

      @keyframes button-scale-pulse {

        0%,
        100% {
          transform: scale(1);
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        50% {
          transform: scale(1.08);
          box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
      }

      @keyframes button-scale-fade-pulse {

        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        50% {
          transform: scale(1.08);
          opacity: 1;
          box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
      }

      .animated-scale-fade {
        animation: button-scale-fade-pulse 1.8s infinite ease-in-out;
      }

      @keyframes cloud-pass {
        from {
          transform: translateX(-250px);
        }

        to {
          transform: translateX(100vw);
        }
      }

      body {
        margin: 0;
        min-height: 100vh;
        overflow-x: hidden;
        font-family: 'ZCOOL KuaiLe', 'HanyiSentyLotus', 'FangSong', cursive, sans-serif;
        color: #3e2723;
        position: relative;
        user-select: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
      }

      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* 默认图片被移除，背景现在由JS控制的class来决定 */
        background-color: var(--bg-base);
        background-repeat: no-repeat;
        background-position: center center;
        background-size: cover;
        z-index: -1;
        /* 添加一个平滑的过渡效果 */
        transition: background-image 0.5s ease-in-out;
      }

      /* 第一关背景：《沉思的玫瑰》 */
      body.bg-level-1::before {
        background-image: url('rose.webp');
      }

      /* 第二关背景：《睡莲》 */
      body.bg-level-2::before {
        background-image: url('lily.webp');
      }

      body::after {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: white;
        opacity: 0.3;
        z-index: -1;
      }

      body.no-scroll {
        overflow: hidden;
      }

      #game-container {
        max-width: 650px;
        margin: 30px auto;
        background: rgba(255, 255, 255, 0.7);
        background: var(--panel-bg);
        border-radius: 25px;
        box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
        padding: 0 0 20px 0;
        position: relative;
        min-height: 880px;
        display: flex;
        flex-direction: column;
        align-items: center;
        border: 3px solid var(--panel-border);
      }

      @media (max-width: 700px) {
        #game-container {
          max-width: 100vw;
          margin: 0;
          box-shadow: none;
          border-radius: 0;
          min-height: 100vh;
          border: none;
          padding-top: env(safe-area-inset-top);
          padding-bottom: env(safe-area-inset-bottom);
          padding-left: env(safe-area-inset-left);
          padding-right: env(safe-area-inset-right);
        }
      }

      @media (min-width: 701px) {
        #game-container {
          max-width: 900px;
          min-height: 90vh;
          margin: 5vh auto;
        }
      }

      #header-bar {
        width: 100%;
        padding: 15px 25px 0 25px;
        box-sizing: border-box;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--panel-bg);
        border-top-left-radius: 22px;
        border-top-right-radius: 22px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      #progress-info {
        font-size: 1.55rem;
        font-weight: bold;
        display: flex;
        gap: 15px;
        align-items: center;
      }

      #progress-info,
      .score-display,
      .target-display {
        color: var(--text-primary);
        text-shadow: 0.5px 0.5px 0 rgba(255, 255, 255, 0.7);
      }

      #music-toggle {
        background: none;
        border: none;
        outline: none;
        font-size: 1.8rem;
        cursor: pointer;
        color: #6d4c41;
        transition: transform 0.2s ease-in-out;
      }

      #music-toggle:hover {
        transform: scale(1.1);
      }

      .score-display,
      .target-display {
        font-size: 1.2rem;
        font-weight: bold;
      }

      #main-area {
        flex: 1;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        position: relative;
        padding-top: 10px;
      }

      #display-area {
        margin-top: 20px;
        width: 90%;
        max-width: 580px;
        min-height: 100px;
        background: rgba(240, 230, 210, 0.6);
        border-radius: 15px;
        box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        border: 2px dashed #b8860b;
        padding: 10px;
        box-sizing: border-box;
        gap: 10px;
      }

      @media (max-width: 650px) {
        #display-area {
          width: 96vw;
          min-width: unset;
          min-height: 80px;
        }
      }

      .display-group {
        display: flex;
        gap: 5px;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 8px;
        padding: 5px 10px;
        border: 1px solid #d4a762;
      }

      .display-card {
        background: #fffdf7;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 2px solid #a0522d;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        opacity: 1;
        transition: opacity 0.3s ease-out;
      }

      .display-card.matched-display {
        opacity: 0;
      }

      #curtain {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.95);
        z-index: 1050;
        display: none;
        border-radius: 15px;
        transition: opacity 0.5s ease-in-out;
        overflow: hidden;
        opacity: 1;
      }

      #curtain::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #f7f0e8, #e0d8cf);
        opacity: 0.9;
      }

      #curtain.open {
        opacity: 0;
        pointer-events: none;
      }

      #curtain.closed {
        opacity: 1;
        pointer-events: all;
      }

      #cat-path {
        position: absolute;
        width: 100%;
        height: 20px;
        left: 0;
        z-index: 1060;
        pointer-events: none;
        overflow: visible;
      }

      @keyframes cat-walk {
        0% {
          left: 0;
          transform: scaleX(1);
        }

        49% {
          transform: scaleX(1);
        }

        50% {
          left: calc(100% - 95px);
          transform: scaleX(-1);
        }

        99% {
          transform: scaleX(-1);
        }

        100% {
          left: 0;
          transform: scaleX(1);
        }
      }

      #walking-cat {
        position: absolute;
        width: 95px;
        height: 71px;
        display: flex;
        z-index: 10;
        align-items: center;
        justify-content: center;
        top: -30px;
        animation: cat-walk 15s linear infinite;
        --cat-width: 95px;
      }

      #walking-cat img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }

      .path-decoration {
        position: absolute;
        bottom: -5px;
        font-size: 23px;
        transition: transform 0.2s ease-in-out;
        z-index: 9;
      }

      .path-decoration.shaking {
        animation: gentle-shake 0.5s ease-in-out infinite alternate;
      }

      @keyframes gentle-shake {
        0% {
          transform: rotate(-2deg) scale(1.05);
        }

        100% {
          transform: rotate(2deg) scale(1);
        }
      }

      .wiggling-cat-instance {
        position: absolute;
        width: 29px;
        height: 29px;
        font-size: 29px;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #5d4037;
        transform: translateX(-50%);
        animation: shake 1.8s ease-in-out infinite alternate;
        z-index: 10;
        pointer-events: none;
        display: none;
      }

      #card-stack-area {
        margin-top: 20px;
        max-width: 580px;
        aspect-ratio: 4 / 5;
        /* 宽:高 = 4:5，可自行修改 */
        max-height: 90vh;
        /* 避免过高盖住工具栏 */
        position: relative;
        background: rgba(240, 230, 210, 0.6);
        border-radius: 15px;
        box-shadow: inset 0 2px 10px rgba(100, 60, 40, 0.15), 0 5px 15px rgba(100, 60, 40, 0.2);
        overflow: visible;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px dashed #b8860b;
        perspective: 1500px;
      }

      @media (max-width: 650px) {
        #card-stack-area {
          width: 96vw;
          min-width: unset;
          height: 60vh;
          max-height: 420px;
          margin-top: 15px;
          margin-bottom: 15px;
        }
      }

      @media (min-width: 701px) {
        #card-stack-area {
          height: 600px;
          max-height: 60vh;
        }
      }

      #blinking-cat {
        position: absolute;
        bottom: 10px;
        right: 10px;
        font-size: 1.2rem;
        z-index: 1000;
        pointer-events: none;
        color: #ff69b4;
        text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        opacity: 0;
        transform: scale(1);
        transition: opacity 0.3s ease;
      }

      @keyframes blink-cat {

        0%,
        100% {
          opacity: 0.8;
          transform: scale(1);
        }

        50% {
          opacity: 1;
          transform: scale(1.2);
        }
      }

      #card-stack-lid {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f7e9d7;
        border: 2px dashed #b8860b;
        border-radius: 15px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-around;
        padding: 20px;
        box-sizing: border-box;
        color: #6e352f;
        transform-origin: top center;
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #card-stack-lid .lid-text-top {
        font-size: 2rem;
        font-weight: bold;
      }

      #card-stack-lid .lid-emoji {
        font-size: 10rem;
        line-height: 1;
      }

      #card-stack-lid .lid-footer {
        font-size: 0.9rem;
      }

      #card-stack-area.level-starting #card-stack-lid {
        display: flex;
        animation: lid-open 4s ease-in-out forwards;
      }

      #card-stack-area.level-starting .card {
        visibility: hidden;
      }

      .card {
        background: var(--card-bg);
        border-radius: 10px;
        box-shadow: var(--card-shadow, 0 4px 10px rgba(0, 0, 0, 0.1));
        border: var(--card-border);
        position: absolute;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        user-select: none;
        transition: transform 0.15s ease-out, box-shadow 0.15s ease-out, opacity 0.2s, border-color 0.15s;
        z-index: 1;
        overflow: hidden;
      }

      .card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.15), 0 0 5px rgba(180, 150, 180, 0.35);
      }

      .hint-animation {
        animation: show-card-property 2s forwards;
      }

      .card.selected {
        border: 3.5px solid #a0522d;
        box-shadow: 0 4px 20px rgba(160, 82, 45, 0.4), 0 0 25px rgba(255, 255, 0, 0.5);
        z-index: 100 !important;
        transform: scale(1.01) rotate(-4deg);
      }

      .card.disabled {
        pointer-events: none;
        position: absolute;
        opacity: 1;
      }

      .card.disabled::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(128, 128, 128, 0.5);
        border-radius: 8px;
        z-index: 2;
        transition: background 0.5s ease;
      }

      .card.disabled>*:not(.disabled::before) {
        opacity: 0.5;
      }

      .card:not(.disabled):not(.matched):hover {
        transform: translateY(-5px) scale(1.05) rotate(2deg);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        transition: transform 0.08s ease-out, box-shadow 0.05s ease-out;
        z-index: 2;
      }

      .card.matched {
        opacity: 0.05;
        transition: opacity 0.1s;
        pointer-events: none;
      }

      .card .mini {
        font-size: 1.2rem;
        position: absolute;
        bottom: 7px;
        right: 9px;
        opacity: 0.5;
        user-select: none;
      }

      .card.napping {
        pointer-events: none !important;
      }

      .card.napping::after {
        content: '💤';
        position: absolute;
        top: -10px;
        right: -5px;
        font-size: 1.5rem;
        animation: wave 1.5s infinite ease-in-out;
        z-index: 5;
      }

      .card.napping::before {
        background: rgba(100, 100, 150, 0.3) !important;
      }

      #temp-area {
        margin: 20px auto 0 auto;
        display: flex;
        justify-content: space-evenly;
        align-items: center;
        min-height: 80px;
        width: 90%;
        max-width: 500px;
        border-radius: 12px;
        background: #fffcf0;
        border: 2px dashed #b8860b;
        padding: 8px 0;
        box-sizing: border-box;
        box-shadow: inset 0 1px 5px rgba(0, 0, 0, 0.08);
      }

      .temp-slot {
        margin: 0;
        background: #fdf5e6;
        border-radius: 9px;
        border: 2px dashed #d4a762;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #92776c;
        box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
        flex-shrink: 0;
      }

      .temp-card {
        width: 100%;
        height: 100%;
        background: var(--card-bg);
        border-radius: 9px;
        border: 2px solid var(--card-border);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(160, 82, 45, 0.3);
        cursor: default;
        position: absolute;
        transition: transform 140ms ease, opacity 140ms ease;
        box-sizing: border-box;
      }

      .temp-card.matched {
        opacity: 0.05;
      }

      .flying-card {
        background: var(--card-bg);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1), inset 0 0 0 1px rgba(255, 255, 255, 0.5);
        border: var(--card-border);
        position: fixed;
        display: flex;
        align-items: center;
        justify-content: center;
        user-select: none;
        z-index: 10000;
        transition-property: top, left, transform;
        transition-timing-function: ease-out;
        overflow: hidden;
      }

      /* ... 其他所有CSS样式保持不变 ... */
      #tools-bar {
        margin: 20px auto 0 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 18px;
        width: 90%;
        max-width: 500px;
        flex-wrap: wrap;
      }

      #tools-bar button {
        padding: 9px 18px;
        background: var(--btn-bg);
        border: 2px solid #b8860b;
        border-radius: 10px;
        border-color: var(--btn-border);
        font-size: 1.05rem;
        color: var(--text-accent);
        font-weight: bold;
        cursor: pointer;
        transition: background 0.15s, transform 0.1s;
        outline: none;
        position: relative;
        min-width: 75px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #tools-bar button:hover {
        background: var(--btn-hover-bg);
        transform: translateY(-1px);
      }

      #tools-bar button:disabled {
        background: #f0f0f0;
        color: #b0b0b0;
        border-color: #d0d0d0;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      #restart-btn {
        background: #ffe0b3;
        border-color: #ffcc80;
        color: #96602c;
      }

      #restart-btn:hover {
        background: #ffd599;
      }

      #code-bar {
        margin: 15px auto 0 auto;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        width: 90%;
        max-width: 450px;
      }

      #code-bar input {
        flex-grow: 1;
        max-width: 180px;
        padding: 7px 10px;
        border-radius: 8px;
        border: 2px solid #b8860b;
        outline: none;
        font-size: 1.05rem;
        color: #5d4037;
        background: #fffdf7;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #code-bar input::placeholder {
        color: #a0a0a0;
      }

      #code-bar button {
        padding: 7px 12px;
        font-size: 1.05rem;
        background: #e6f6d3;
        border: 2px solid #a0c388;
        border-radius: 9px;
        cursor: pointer;
        color: #3e5a2b;
        font-weight: bold;
        transition: background 0.15s;
        min-width: 65px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #code-bar button:hover {
        background: #d2e5bb;
      }

      #message-bar {
        margin: 15px auto 0 auto;
        text-align: center;
        font-size: 1.1rem;
        color: #c0392b;
        min-height: 28px;
        font-weight: bold;
        letter-spacing: 1.2px;
      }

      #event-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2200;
        pointer-events: none;
      }

      #event-message-box {
        background: rgba(255, 253, 247, 0.9);
        padding: 20px 30px;
        border-radius: 15px;
        border: 3px solid #b8860b;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
        text-align: center;
        animation: fade-in-out-scale 3.5s forwards;
      }

      #event-message-box p {
        font-size: 1.3rem;
        color: #6e352f;
        margin: 0;
        font-weight: bold;
        text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
      }

      #event-message-box .event-icon {
        font-size: 2rem;
        margin-bottom: 10px;
      }

      #start-screen,
      #game-over,
      #level-finish {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.98);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        font-size: 1.1rem;
        border-radius: 25px;
        text-align: center;
      }

      #level-finish {
        justify-content: flex-start;
      }

      #level-finish>* {
        margin-top: 30%;
      }

      /* 第二关：从 10% 开始 */
      #level-finish.level2-start-10>* {
        margin-top: 10%;
      }

      /* 可选小屏调整，避免太靠近顶部 */
      @media (max-width: 500px) {
        #level-finish.level2-start-10>* {
          margin-top: 6%;
        }
      }

      #start-screen {
        padding-top: 10vh;
        overflow: hidden;
        box-sizing: border-box;
      }

      #start-screen-video {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        z-index: -1;
        opacity: 0.99;
        object-fit: cover;
      }

      #start-screen::before {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background-image: url('mao.webp');
        background-size: cover;
        background-position: center;
        opacity: 0.5;
        z-index: -2;
      }

      #start-screen h1 {
        font-size: clamp(3rem, 12vw, 5rem);
        margin: 0 0 25px 0;
        letter-spacing: 3px;
        text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
        display: inline-block;
      }

      #start-screen h1 span {
        display: inline-block;
        animation: wave 2s infinite ease-in-out;
      }

      #start-screen h1 span:nth-child(1) {
        animation-delay: -0.4s;
      }

      #start-screen h1 span:nth-child(2) {
        animation-delay: -0.2s;
      }

      #start-screen h1 span:nth-child(3) {
        animation-delay: 0s;
      }

      #start-screen h1 span:nth-child(4) {
        animation-delay: 0.2s;
      }

      #start-screen h1 span:nth-child(5) {
        animation-delay: 0.4s;
      }

      #start-screen .start-btn {
        margin-top: 30px;
        padding: 15px 50px;
        font-size: 1.4rem;
        background: linear-gradient(90deg, #a0c388, #88b368);
        border: none;
        border-radius: 15px;
        color: #3e5a2b;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 15px rgba(160, 195, 136, 0.5);
        animation: pulse-scale 1.5s infinite ease-in-out;
        transition: background 0.2s, transform 0.1s;
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #start-screen .start-btn:hover {
        background: linear-gradient(90deg, #88b368, #a0c388);
        transform: translateY(-2px);
      }

      #start-screen p {
        color: #5d4037;
        line-height: 1.6;
        margin: 0 40px 15px;
        margin-top: 15vh;
      }

      #start-screen span {
        color: #c0392b;
        font-weight: bold;
      }

      .loading-footer {
        color: #795548;
        font-size: 0.85rem;
        position: absolute;
        bottom: 30px;
        left: 0;
        right: 0;
        text-align: center;
        letter-spacing: 1.5px;
        text-shadow: 0.5px 0.5px 0 rgba(255, 255, 255, 0.5);
      }

      #level-finish,
      #game-over {
        font-size: 1.8rem;
        color: #5d4037;
        background: rgba(255, 243, 245, 0.99);
        border-radius: 25px;
        position: absolute;
        overflow: hidden;
        border: 3px solid #8B4513;
        box-shadow: 0 5px 25px rgba(100, 60, 40, 0.3);
      }

      #game-over {
        overflow: hidden;
      }

      #game-over-content {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: -30%;
        animation: wave 2s infinite;
      }

      .cloud-layer {
        content: '';
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 0;
      }

      .cloud-layer::before,
      .cloud-layer::after {
        content: '🌧️';
        position: absolute;
        opacity: 0.88;
        color: #888;
        animation-name: cloud-pass;
        animation-timing-function: linear;
        animation-iteration-count: infinite;
      }

      .cloud-layer::before {
        font-size: 120px;
        top: 10%;
        animation-duration: 20s;
        animation-delay: -5s;
      }

      .cloud-layer::after {
        font-size: 80px;
        top: 25%;
        animation-duration: 15s;
      }

      #game-over>* {
        position: relative;
        z-index: 1;
      }

      #level-finish::before,
      #game-over::before {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
        background-image: url('mao1.webp');
        background-size: cover;
        background-position: center;
        opacity: 0.4;
        z-index: -1;
      }

      #level-finish button,
      #game-over button {
        margin-top: 20px;
        padding: 12px 35px;
        font-size: 1.25rem;
        background: #e6f6d3;
        border: 2px solid #a0c388;
        border-radius: 12px;
        color: #3e5a2b;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.15s, transform 0.1s;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #level-finish button:hover,
      #game-over button:hover {
        background: #d2e5bb;
        transform: translateY(-1px);
      }

      #retry-btn {
        margin-top: 18px;
        padding: 10px 30px;
        font-size: 1.15rem;
        background: #f7e9d7;
        border: 2px solid #d4a762;
        border-radius: 10px;
        color: #6e352f;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.15s, transform 0.1s;
        display: inline-block;
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
      }

      #retry-btn:hover {
        background: #f0e1d0;
        transform: translateY(-1px);
      }

      #retry-btn2,
      #next-btn {
        animation: button-scale-pulse 1.5s infinite ease-in-out;
      }

      #footer {
        margin: 20px auto 20px auto;
        width: 100%;
        text-align: center;
        font-size: 1rem;
        color: #8B4513;
        letter-spacing: 1.5px;
        text-shadow: 0.5px 0.5px 0 rgba(255, 255, 255, 0.5);
      }

      .hinted-shake {
        animation: shake 0.5s ease-in-out 4;
      }

      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 2500;
        display: none;
        align-items: center;
        justify-content: center;
      }

      .modal-content {
        background: #fffdf7;
        padding: 30px 40px;
        border-radius: 15px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        border: 3px solid #d4a762;
      }

      .modal-content p {
        font-size: 1.2rem;
        color: #5d4037;
        margin: 0 0 25px 0;
        font-weight: bold;
      }

      .modal-content button {
        padding: 9px 25px;
        background: #f7e9d7;
        border: 2px solid #b8860b;
        border-radius: 10px;
        font-size: 1.05rem;
        color: #6e352f;
        font-weight: bold;
        cursor: pointer;
        margin: 0 10px;
        transition: background 0.15s, transform 0.1s;
        font-family: 'ZCOOL KuaiLe', cursive;
      }

      #confirm-yes {
        background: #e6f6d3;
        border-color: #a0c388;
        color: #3e5a2b;
      }

      #confirm-yes:hover {
        background: #d2e5bb;
      }

      #confirm-no:hover {
        background: #e9d9c6;
      }

      #level-finish-text {
        color: #3e2723;
        font-size: 1.2em;
        text-align: center;
        margin-top: 20px;
        margin-bottom: 0px;
      }

      #loading-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1199;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f7f0e8;
        background-size: cover;
        transition: opacity 0.5s ease-out;
        border-radius: 25px;
        overflow: hidden;
      }

      #loading-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: url('mao3.webp');
        background-repeat: no-repeat;
        background-position: center center;
        background-size: cover;
        opacity: 0.6;
      }

      .loading-content {
        position: relative;
        z-index: 1001;
        text-align: center;
        width: 80%;
        max-width: 500px;
        display: flex;
        flex-direction: column;
        height: 100%;
        align-items: center;
        justify-content: flex-start;
        padding-top: 10vh;
        box-sizing: border-box;
      }

      .loading-title {
        font-size: 2.8rem;
        margin: 0 0 40px 0;
        color: #3e2723;
        letter-spacing: 3px;
        text-shadow: 2px 2px 0 #f7e9d7, 4px 4px 0 #b8860b;
        animation: pulse-scale 1.5s infinite ease-in-out;
      }

      .loading-title::after {
        content: ".";
        animation: text-progress 2s infinite;
      }

      .progress-bar-container {
        width: 100%;
        height: 30px;
        background: rgba(184, 134, 11, 0.2);
        border-radius: 10px;
        border: 2px solid #b8860b;
        overflow: hidden;
        margin-bottom: 15px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        margin-top: 30vh;
        z-index: 1004;
      }

      #progress-bar {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #a0c388, #88b368);
        border-radius: 8px;
        transition: width 0.3s ease-out;
      }

      #loading-text {
        font-size: 1.1rem;
        color: #5d4037;
        margin-bottom: 40px;
        min-height: 20px;
        text-align: center;
      }

      .responsive-video-container {
        position: relative;
        width: 100%;
        max-width: 660px;
        padding-bottom: 68.1818%;
        height: 0;
        overflow: hidden;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      }

      .responsive-video-container iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border: 0;
        border-radius: 10px;
      }

      #level2-outro-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        z-index: 2000;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 25px;
        overflow: hidden;
      }

      #level2-outro-screen video,
      #level2-outro-screen img {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        object-fit: cover;
        border-radius: 0;
        box-shadow: none;
      }

      #level2-outro-screen .loading-text {
        color: white;
        font-size: 1.5rem;
        margin-top: 20px;
      }

      #skip-outro-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.7);
        border: 1px solid #ccc;
        border-radius: 8px;
        font-size: 1rem;
        color: #333;
        cursor: pointer;
        z-index: 2001;
        transition: background 0.2s, transform 0.2s;
      }

      #skip-outro-btn:hover {
        background: rgba(255, 255, 255, 0.9);
        transform: scale(1.05);
      }

      @media (max-width: 500px) {

        #card-stack-area,
        #temp-area,
        #tools-bar,
        #code-bar {
          width: 98vw;
        }

        #tools-bar button {
          min-width: unset;
          width: 30%;
          margin-bottom: 8px;
          padding: 8px 10px;
          font-size: 0.95rem;
        }

        #tools-bar {
          gap: 6px;
        }

        #temp-area {
          width: 98vw;
          margin: 15px auto 0 auto;
        }

        #code-bar input {
          width: 50%;
        }

        #display-area {
          width: 96vw;
          padding: 5px;
        }

        #level-finish,
        #game-over {
          font-size: 1.2rem;
          padding: 20px;
          box-sizing: border-box;
        }

        #level-finish button,
        #game-over button,
        #retry-btn {
          font-size: 1rem;
          padding: 10px 20px;
        }

        #level-finish-text {
          font-size: 1em;
        }
      }

      :root {
        /*
                    以 iPhone 15 Pro Max 的屏幕宽度 (430px) 为基准进行字体缩放。
                    我们将基准字号 --fz-s 在 430px 宽度下设置为 18px。
                    计算公式为: (基准字号 / 基准宽度) * 100vw
                    即: (18 / 430) * 100vw
                    这会生成一个与屏幕宽度成正比的动态基准字号。
                  */
        --font-base-dynamic: calc(18 / 430 * 100vw);

        /* 语义层级（现在所有字体大小都基于动态基准值进行缩放） */
        --fz-xs: calc(var(--font-base-dynamic) * 0.85);
        --fz-s: var(--font-base-dynamic);
        --fz-m: calc(var(--font-base-dynamic) * 1.15);
        --fz-l: calc(var(--font-base-dynamic) * 1.35);
        --fz-xl: calc(var(--font-base-dynamic) * 1.8);

        /* 行高与字距 */
        --lh-tight: 1.45;
        --lh-normal: 2.35;
        --ls-tight: 0.02em;
        /* 通用样式变量保持不变 */
        --bg-base: #f7f0e8;
        --panel-bg: rgba(240, 230, 210, 0.6);
        --panel-border: #b8860b;
        --card-bg: #fffdf7;
        --card-border: #d4a762;
        --text-primary: #3e2723;
        --text-accent: #6e352f;
        --btn-bg: #f7e9d7;
        --btn-border: #b8860b;
        --btn-hover-bg: #e9d9c6;
      }

      /*
                  针对 iPhone 11 (414px) 及类似尺寸屏幕的优化。
                  在这些设备上，头部信息栏的字体可能会过大导致换行。
                  我们通过这个媒体查询，将该区域的字体从 --fz-m 降为 --fz-s，
                  使其与“分数”和“目标”的字体大小保持一致，从而解决拥挤和换行问题。
                */
      @media (max-width: 420px) {
        #progress-info {
          font-size: var(--fz-s);
          gap: 10px;
          /* 同时也可以略微减小间距 */
        }
      }

      body.bg-default::before {
        background-image: url('cat1.webp');
      }

      /*
                                Theme: Dali Rose (Enhanced)
                                Author: Gemini
                                Description: An enhanced theme inspired by Salvador Dalí's "The Meditative Rose".
                                             This version incorporates advanced CSS techniques inferred from a
                                             renaissance-themed stylesheet, adding depth, texture, and more
                                             dynamic interactions while preserving the original color story.
                              */

      /*
                                Description: An enhanced theme inspired by Salvador Dalí's "The Meditative Rose".
                                             This version incorporates advanced CSS techniques inferred from a
                                             renaissance-themed stylesheet, adding depth, texture, and more
                                             dynamic interactions while preserving the original color story.
                                描述：一个增强版主题，灵感来源于萨尔瓦多·达利的《沉思的玫瑰》。
                                      此版本借鉴了文艺复兴风格主题中的高级CSS技巧，在保留原有色彩故事的同时，
                                      增加了深度、纹理和更丰富的动态交互效果。
                              */
      .theme-dali-rose {
        /* -- Color & Style Variables -- */
        /* -- 颜色与样式变量 -- */

        /* Background colors inspired by the painting's sky and sand */
        /* 背景色：灵感源于画作的天空与沙地 */
        --color-sky-light: #d4e7f5;
        --color-sky-deep: #a5c9e4;
        --color-sand: #e4d7c6;

        /* 🌹 红玫瑰色调：以花瓣深红为主，带柔光与雾化感 */
        --color-rose-bright: #e87a89;
        /* 鲜艳明亮的红玫瑰亮色 */
        --color-rose-deep: #b41e3c;
        /* 深层花瓣色调，情绪浓烈 */
        --color-rose-highlight: rgba(255, 240, 245, 0.1);
        /* 粉雾高光，模拟柔焦光晕 */
        --color-rose-glow: #d46a7e;
        /* 带梦幻感的玫瑰发光色 */


        /* UI及文本颜色 */
        --color-text-primary: #4a4e69;
        --color-text-accent: #6a5676;
        --color-shadow-main: rgba(74, 78, 105, 0.2);
        --color-shadow-rose: rgba(120, 50, 60, 0.3);
        --color-panel-border: rgba(255, 255, 255, 0.4);

        /* -- Main Background -- */
        /* -- 主背景 -- */
        --bg-base: linear-gradient(to bottom, var(--color-sky-light) 0%, var(--color-sky-deep) 60%, var(--color-sand) 95%);

        /* -- Panel Styles (for frosted glass effect) -- */
        /* -- 面板样式 (用于毛玻璃效果) -- */
        --panel-bg: rgba(250, 246, 241, 0.2);
        --panel-border: 1.5px solid var(--color-panel-border);
        --panel-shadow: 0 8px 24px var(--color-shadow-main);
        --panel-backdrop-filter: blur(12px) saturate(1.2);

        /* -- Card Styles -- */
        /* -- 卡片样式 -- */
        --card-bg: linear-gradient(160deg, var(--color-rose-bright), var(--color-rose-deep));
        --card-border: 1px solid rgba(255, 255, 255, 0.2);
        --card-shadow: 0 6px 16px var(--color-shadow-rose);
        --card-hover-shadow: 0 10px 22px rgba(120, 50, 60, 0.4);
        --card-selected-shadow: 0 0 0 4px var(--color-rose-glow);

        /* -- Button Styles -- */
        /* -- 按钮样式 -- */
        --btn-bg: rgba(255, 255, 255, 0.5);
        --btn-border: 1.5px solid var(--color-panel-border);
        --btn-hover-bg: rgba(255, 255, 255, 0.7);
        --btn-shadow: 0 2px 8px rgba(74, 78, 105, 0.1);
      }

      /* -- Apply Theme to Game Elements -- */
      /* -- 将主题应用于游戏元素 -- */

      /* General text colors */
      /* 通用文本颜色 */
      .theme-dali-rose #progress-info,
      .theme-dali-rose .score-display,
      .theme-dali-rose .target-display,
      .theme-dali-rose #footer {
        color: var(--color-text-primary);
        text-shadow: 0 1px 1px rgba(255, 255, 255, 0.5);
      }

      /* Main containers with frosted glass effect */
      /* 具有毛玻璃效果的主容器 */
      .theme-dali-rose #card-stack-area,
      .theme-dali-rose #display-area,
      .theme-dali-rose #temp-area {
        background: var(--panel-bg);
        border: var(--panel-border);
        box-shadow: var(--panel-shadow);
        backdrop-filter: var(--panel-backdrop-filter);
        -webkit-backdrop-filter: var(--panel-backdrop-filter);
        border-radius: 18px;
      }

      /* NEW: Card stack lid styling */
      /* 新增: 卡片堆叠区盖子样式 */
      /* 达利《沉思的玫瑰》主题 - 卡片盖子 */
      .theme-dali-rose #card-stack-lid {
        /*
                                  更新为更淡雅的天空蓝色调，下半部分平滑渐变为白色。
                                  径向渐变模拟玫瑰的柔和光芒，线性渐变则创造出清澈的天空效果。
                                */
        background: radial-gradient(circle at 50% 80%, rgba(255, 204, 219, 0.6) 0%, rgba(255, 204, 219, 0) 50%),
          linear-gradient(180deg, #e0f0ff 0%, #ffffff 100%);

        /* 边框和玻璃拟态效果保持不变，提供梦幻感 */
        border: var(--panel-border, 1px solid rgba(0, 0, 0, 0.1));
        backdrop-filter: var(--panel-backdrop-filter, blur(10px) saturate(1.5));
        -webkit-backdrop-filter: var(--panel-backdrop-filter, blur(10px) saturate(1.5));

        /* 添加内部阴影，模拟微光，同时调整颜色以适应浅色背景 */
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);

        /* 文本颜色调整为深色，以确保在浅色背景上的可读性 */
        color: #1f4277;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);

        /* 增加过渡效果，使交互更平滑 */
        transition: all 0.3s ease;
      }

      /* 添加一个微妙的悬停效果，提升用户体验 */
      .theme-dali-rose #card-stack-lid:hover {
        transform: translateY(-5px);
        /* 向上移动一点 */
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 8px 25px rgba(0, 0, 0, 0.2);
      }

      /* 玫瑰色卡片 */
      .theme-dali-rose .card,
      .theme-dali-rose .temp-card,
      .theme-dali-rose .flying-card,
      .theme-dali-rose .display-card

      /* Apply to display cards too */
        {
        background: var(--card-bg);
        border: var(--card-border);
        box-shadow: var(--card-shadow);
        color: white;
        /* Text on cards should be light */
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, opacity 0.2s;
      }

      /* Add a subtle shine to the cards */
      /* 为卡片添加微妙的光泽 */
      .theme-dali-rose .card::before,
      .theme-dali-rose .temp-card::before,
      .theme-dali-rose .flying-card::before,
      .theme-dali-rose .display-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: inherit;
        background: linear-gradient(145deg, var(--color-rose-highlight) 0%, transparent 40%);
        pointer-events: none;
      }

      /* Card hover effect */
      /* 卡片悬停效果 */
      .theme-dali-rose .card:not(.disabled):not(.matched):hover {
        transform: translateY(-5px) scale(1.03);
        box-shadow: var(--card-hover-shadow);
      }

      /* Selected card effect */
      /* 选中卡片的效果 */
      .theme-dali-rose .card.selected {
        box-shadow: var(--card-selected-shadow), var(--card-hover-shadow);
        transform: scale(1.05) rotate(-3deg);
      }

      /* Matched card effect */
      /* 已匹配卡片的效果 */
      .theme-dali-rose .card.matched,
      .theme-dali-rose .temp-card.matched {
        opacity: 0.1;
        transform: scale(0.9);
      }

      /* Disabled card overlay specifically for Dali Rose theme - Enhanced Visibility */
      .theme-dali-rose .card.disabled::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(200, 200, 200, 0.3) !important;
        /* 更深、与主题协调的半透明暗色 */
        border-radius: inherit;
        /* 继承父级卡片的圆角 */
        transition: background 0.5s ease;
      }

      .theme-dali-rose .card.disabled>*:not(.disabled::before) {
        opacity: 0.3 !important;
        /* 使卡片内容更暗，对比更强 */
      }

      /* Napping card overlay */
      /* 打盹卡片的遮罩 */
      .theme-dali-rose .card.napping::before {
        background: rgba(74, 78, 105, 0.4) !important;
      }

      /* NEW: Display area styling */
      /* 新增: 顶部展示区样式 */
      .theme-dali-rose #display-area .display-group {
        background: rgba(255, 255, 255, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.4);
        border-radius: 12px;
        padding: 4px;
      }

      /* Temp area slot styling */
      /* 暂存区槽位样式 */
      .theme-dali-rose .temp-slot {
        background: rgba(255, 255, 255, 0.2);
        border: 1px dashed rgba(255, 255, 255, 0.6);
        box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
      }

      /* Tools bar buttons */
      /* 工具栏按钮 */
      .theme-dali-rose #tools-bar button {
        background: var(--btn-bg);
        border: var(--btn-border);
        color: var(--color-text-accent);
        box-shadow: var(--btn-shadow);
      }

      .theme-dali-rose #tools-bar button:hover {
        background: var(--btn-hover-bg);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(74, 78, 105, 0.15);
      }

      .theme-dali-rose #tools-bar button:disabled {
        background: rgba(230, 230, 230, 0.4);
        color: rgba(74, 78, 105, 0.4);
        border-color: rgba(255, 255, 255, 0.2);
      }

      /* Restart button special style */
      /* 重开按钮特殊样式 */
      .theme-dali-rose #restart-btn {
        background: rgba(255, 230, 235, 0.6);
        border-color: rgba(210, 74, 97, 0.4);
        color: #b83b50;
      }

      .theme-dali-rose #restart-btn:hover {
        background: rgba(255, 230, 235, 0.8);
      }

      /* NEW: Game Over Screen Styling */
      /* 新增: 游戏结束界面样式 */
      .theme-dali-rose #game-over {
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: var(--panel-backdrop-filter);
        -webkit-backdrop-filter: var(--panel-backdrop-filter);
        border: 2px solid var(--color-panel-border);
        color: var(--color-text-primary);
      }

      .theme-dali-rose #game-over button {
        background: var(--btn-bg);
        border: var(--btn-border);
        color: var(--color-text-accent);
      }

      .theme-dali-rose #game-over button:hover {
        background: var(--btn-hover-bg);
        transform: translateY(-2px);
      }

      /* Level Finish Screen */
      /* 关卡完成界面 */
      .theme-dali-rose #level-finish {
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(15px) saturate(1.5);
        border: 2px solid var(--color-panel-border);
        color: var(--color-text-primary);
      }

      /* Shimmering text effect for level finish title */
      /* 关卡完成标题的流光效果 */
      @keyframes dali-text-shimmer {

        0%,
        100% {
          background-position: 200% 50%;
        }

        50% {
          background-position: 0% 50%;
        }
      }

      .theme-dali-rose #level-finish-text {
        font-weight: 700;
        background: linear-gradient(90deg, var(--color-text-accent), var(--color-rose-deep), var(--color-text-accent));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        background-size: 200% 100%;
        animation: dali-text-shimmer 4s ease-in-out infinite;
        text-shadow: none;
      }

      .theme-dali-rose #level-finish button {
        background: var(--btn-bg);
        border: var(--btn-border);
        color: var(--color-text-accent);
        box-shadow: var(--btn-shadow);
      }

      .theme-dali-rose #level-finish button:hover {
        background: var(--btn-hover-bg);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(74, 78, 105, 0.15);
      }

      /* NEW: Themed confetti */
      /* 新增: 主题化礼花 */
      .theme-dali-rose .confetti-piece {
        box-shadow: 0 0 8px rgba(255, 255, 255, .15);
        opacity: .95;
      }

      .theme-renaissance {
        --bg-base: linear-gradient(135deg, #fdf7f3, #f9f3eb);
        /* 米白背景 */
        --panel-bg: rgba(250, 246, 241, 0.2);
        /* 面板半透 */
        --panel-border: #d4b8a8;
        --grey-shadow: rgba(200, 200, 200, 0.9);
        --card-shadow: 0 6px 14px var(--grey-shadow);
        --card-bg: rgba(240, 231, 233, 1);
        --text-primary: #5f4b57;
        --text-accent: #c98596;
        --btn-bg: #f8e8ea;
        --btn-hover-bg: #f0d8dc;
        --grad-aurora: linear-gradient(135deg, #fbf5ef, #f6ede9, #f0e6d6);
      }


      /* 容器：雾面玻璃 + 渐变边框（覆盖原 dashed） */
      .theme-renaissance #temp-area {
        background:
          linear-gradient(0deg, rgba(255, 255, 255, .45), rgba(255, 255, 255, .25)) padding-box,
          var(--grad-aurora) border-box;
        border: 1.5px solid transparent;
        /* 用背景模拟彩色边框 */
        border-radius: 16px;
        box-shadow: var(--shadow-soft);
        backdrop-filter: blur(10px) saturate(1.05);
      }

      /* 槽位：丝绸微光 + 渐变边框 */
      .theme-renaissance #temp-area .temp-slot {
        background:
          linear-gradient(0deg, rgba(255, 255, 255, .60), rgba(255, 255, 255, .35)) padding-box,
          linear-gradient(120deg, #f6e6e9, #d9efe6) border-box;
        border: 1px solid transparent;
        /* 覆盖 dashed，为光滑边框 */
        box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        transition: transform var(--t-fast) var(--ease), box-shadow var(--t-fast) var(--ease);
      }

      .theme-renaissance #temp-area .temp-slot:hover {
        transform: translateY(-1px);
        box-shadow: inset 0 1px 6px rgba(0, 0, 0, 0.07), 0 6px 12px rgba(90, 74, 83, .12);
      }

      /* 清空闪光（复用你已有的 .clearing 动画名） */
      .theme-renaissance .temp-slot.clearing {
        animation: slot-flash 0.45s ease-out;
      }

      /* 牌：柔影 */
      .theme-renaissance #temp-area .temp-card {
        background: var(--card-bg);
        color: var(--text-primary);
        box-shadow: var(--card-shadow);
      }

      /* 三消后消退（沿用你的 .vanishing） */
      .theme-renaissance .temp-card.vanishing {
        animation: card-vanish 0.55s ease-out forwards;
      }

      /* 容器：柔彩画布 + 渐变边框（覆盖原 dashed） */
      .theme-renaissance #card-stack-area {
        background:
          linear-gradient(180deg, rgba(236, 228, 241, 0.58), rgba(236, 228, 241, 0.38)) padding-box;
        border: 1px solid transparent;
        border-radius: 18px;
        box-shadow: 0 8px 18px rgba(90, 74, 83, 0.18);
        backdrop-filter: blur(8px) saturate(1.05);
      }

      /* 盖子：丝绸渐变 + 光泽边框 */
      /* 文艺复兴主题 - 卡片盖子 */
      .theme-renaissance #card-stack-lid {
        /*
                                  更新为淡紫色到白色的渐变背景。
                                  径向渐变模拟柔和的光晕，线性渐变则创造出从淡紫色到白色的平滑过渡。
                                */
        background: radial-gradient(circle at 50% 80%, rgba(224, 204, 255, 0.6) 0%, rgba(224, 204, 255, 0) 50%),
          linear-gradient(180deg, #e6e6fa 0%, #ffffff 100%);

        /* 边框改为更简洁的实色，颜色与主题匹配 */
        border: var(--panel-border, 1px solid rgba(0, 0, 0, 0.1));

        /* 保持并优化了玻璃拟态效果，使其更具梦幻感 */
        backdrop-filter: var(--panel-backdrop-filter, blur(10px) saturate(1.5));
        -webkit-backdrop-filter: var(--panel-backdrop-filter, blur(10px) saturate(1.5));

        /* 添加内部阴影，模拟微光 */
        box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.1);

        /* 文本颜色调整为深色，以确保在浅色背景上的可读性 */
        color: #58417c;
        text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);

        /* 增加过渡效果，使交互更平滑 */
        transition: all 0.3s ease;
      }

      /* 添加一个微妙的悬停效果，提升用户体验 */
      .theme-renaissance #card-stack-lid:hover {
        transform: translateY(-5px);
        /* 向上移动一点 */
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.2), 0 8px 25px rgba(0, 0, 0, 0.2);
      }

      /* 卡片整体：柔雾渐层 + 抽象纸感纹理 */
      .theme-renaissance .card,
      .theme-renaissance .temp-card,
      .flying-card.theme-renaissance {
        color: var(--text-primary) !important;
        background: var(--card-bg);
        box-shadow: var(--card-shadow);
        border: none;
        border-radius: 10px; /* 统一圆角 */
        transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
      }

      .theme-renaissance .card:hover {
        transform: translateY(-4px) scale(1.02);
        box-shadow: 0 10px 20px rgba(190, 160, 180, 0.2);
      }

      .theme-renaissance .card.matched {
        opacity: 0.08;
        transform: scale(0.95);
      }

      .theme-renaissance .card.disabled::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(200, 200, 200, 0.37) !important;
        /* 更深、与主题协调的半透明暗色 */
        border-radius: inherit;
        /* 继承父级卡片的圆角 */
        transition: background 0.5s ease;
      }

      .theme-renaissance .card.disabled>*:not(.disabled::before) {
        opacity: 0.3 !important;
        /* 使卡片内容更暗，对比更强 */
      }

      /* 悬停浮起：无边框，仅轻柔浮动与光晕 */
      .theme-renaissance .card:not(.disabled):not(.matched):hover {
        transform: translateY(-6px) scale(1.04) rotate(1.5deg);
        box-shadow: 0 12px 24px rgba(90, 74, 83, 0.2), 0 0 12px rgba(255, 228, 202, 0.3);
      }

      /* 选中态：金粉光晕、微抬升，不恢复边框 */
      .theme-renaissance .card.selected {
        box-shadow: 0 0 0 4px rgba(210, 160, 120, 0.35), 0 12px 24px rgba(90, 74, 83, 0.22);
        transform: scale(1.02) rotate(-2.5deg);
      }

      /* 打盹态遮罩优化：柔雾罩层 */
      .theme-renaissance .card.napping::before {
        background: rgba(90, 74, 83, 0.18) !important;
      }

      .theme-renaissance .card.napping::after {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, .15));
      }

      /* 背景：极光渐变 + 轻微色相流动 */
      @keyframes lfHue {
        0% {
          filter: hue-rotate(0deg);
        }

        100% {
          filter: hue-rotate(18deg);
        }
      }

      .theme-renaissance #level-finish {
        background:
          radial-gradient(120% 100% at 50% 10%, rgba(255, 255, 255, .35), transparent 60%),
          var(--grad-aurora);
        border: 2px solid transparent;
        background-clip: padding-box, border-box;
        animation: lfHue 10s linear infinite;
        color: var(--text-primary);
        box-shadow: 0 14px 28px rgba(90, 74, 83, .22), 0 2px 6px rgba(90, 74, 83, .12);
      }

      /* 叠加一层薄纱，不覆盖你已有的 ::before 图片层 */
      .theme-renaissance #level-finish::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(circle at 20% 30%, rgba(255, 255, 255, .22), transparent 40%),
          radial-gradient(circle at 80% 20%, rgba(255, 255, 255, .16), transparent 45%),
          repeating-linear-gradient(45deg, rgba(255, 255, 255, .05) 0 2px, transparent 2px 6px);
        mix-blend-mode: screen;
      }

      /* 标题：流光文字（不改变你的结构，直接美化 #level-finish-text） */
      @keyframes textShimmer {
        0% {
          background-position: 0% 50%;
        }

        50% {
          background-position: 100% 50%;
        }

        100% {
          background-position: 0% 50%;
        }
      }

      .theme-renaissance #level-finish-text {
        font-weight: 700;
        letter-spacing: .4px;
        background: linear-gradient(90deg, #5f4b57, #c98596, #5f4b57);
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        background-size: 200% 100%;
        animation: textShimmer 3s ease-in-out infinite;
        text-shadow: none;
      }

      /* 按钮：丝缎渐变 + 轻浮动 */
      .theme-renaissance #level-finish button {
        background:
          linear-gradient(0deg, rgba(255, 255, 255, .7), rgba(255, 255, 255, .45)) padding-box,
          linear-gradient(120deg, #f6e6e9, #d9cbe8, #d9efe6) border-box;
        border: 1px solid transparent;
        color: var(--text-primary);
        box-shadow: 0 6px 14px rgba(90, 74, 83, .18);
        transition: transform var(--t-fast) var(--ease), box-shadow var(--t-fast) var(--ease);
      }

      .theme-renaissance #level-finish button:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 18px rgba(90, 74, 83, .22);
      }

      /* 礼花：更细腻的彩片（保留你的生成逻辑，仅美化外观） */
      .theme-renaissance .confetti-piece {
        width: 7px;
        height: 14px;
        border-radius: 2px;
        box-shadow: 0 0 8px rgba(255, 255, 255, .15);
        opacity: .95;
      }

      /* 可选：display-area 也走玻璃与渐变边框，保持整体一致 */
      .theme-renaissance #display-area {
        background:
          linear-gradient(0deg, rgba(255, 255, 255, .45), rgba(255, 255, 255, .25)) padding-box,
          var(--grad-aurora) border-box;
        border: 1.5px solid transparent;
        border-radius: 15px;
        box-shadow: var(--shadow-soft);
        backdrop-filter: blur(8px) saturate(1.03);
      }

      .theme-renaissance #display-area .display-group {
        background: rgba(255, 255, 255, .55);
        border: 1px solid rgba(177, 154, 132, .35);
      }

      .theme-renaissance #display-area .display-card {
        background:
          radial-gradient(120% 100% at 10% 0%, rgba(255, 255, 255, .7), transparent 60%),
          linear-gradient(180deg, #fffdf7, #f7efe7);
        border: 2px solid var(--card-border);
        color: var(--text-primary);
        box-shadow: 0 4px 10px rgba(0, 0, 0, .12);
      }

      @media (prefers-reduced-motion: reduce) {

        .theme-renaissance #level-finish,
        .theme-renaissance #level-finish-text,
        .theme-renaissance .confetti-piece {
          animation: none !important;
        }

        .theme-renaissance #card-stack-area .card,
        .theme-renaissance #temp-area,
        .theme-renaissance #temp-area .temp-slot {
          transition: none !important;
        }
      }
    </style>
    <link rel="stylesheet" href="font/iconfont.css" />
    <link rel="stylesheet" href="css/style.css" />
  </head>

  <body class="bg-default">
    <!-- HTML 结构保持不变 -->
    <div id="game-container">
      <div id="loading-screen">
        <div class="loading-content">
          <h1 class="loading-title">乖乖加载中.</h1>
          <div class="progress-bar-container">
            <div id="progress-bar"></div>
          </div>
          <p id="loading-text">正在初次加载资源，请等待...</p>
          <small class="loading-footer"
            >超级喵喵 &copy; 2025 | Designed by 开元</small
          >
        </div>
      </div>

      <div id="header-bar">
        <div id="progress-info">
          <span id="level-info">关卡: 1 / 2</span>
          <span class="score-display"
            >分数: <span id="current-score">0</span></span
          >
          <span class="target-display"
            >目标: <span id="target-score">0</span></span
          >
        </div>
        <button id="music-toggle" title="音乐开关">🎼</button>
      </div>
      <div id="main-area">
        <div id="display-area"></div>
        <div id="curtain"></div>
        <div id="cat-path">
          <div id="walking-cat">
            <img src="run.gif" alt="Walking Cat" />
          </div>
          <span class="path-decoration" style="left: 20%">💌</span>
          <span class="path-decoration" style="left: 40%">🌿</span>
          <span class="path-decoration" style="left: 60%">☘️</span>
          <span class="path-decoration" style="left: 80%">🌼</span>
        </div>
        <div id="card-stack-area"></div>
        <div id="wiggling-cat-1" class="wiggling-cat-instance">🥳</div>
        <div id="wiggling-cat-4" class="wiggling-cat-instance">🎉</div>
        <div id="wiggling-cat-7" class="wiggling-cat-instance">🎀</div>
        <div id="blinking-cat">😺</div>

        <div id="temp-area">
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
          <div class="temp-slot"></div>
        </div>
        <div id="tools-bar">
          <button id="undo-btn" disabled title="撤销(需兑换码)">
            ↩️ 撤销 (<span id="undo-count">0</span>)
          </button>
          <button id="hint-btn" disabled title="提示(需兑换码)">
            提示💡 (<span id="hint-count">0</span>)
          </button>
          <button id="shuffle-btn" disabled title="洗牌(需兑换码)">
            洗牌🔀 (<span id="shuffle-count">0</span>)
          </button>
          <button id="revive-btn" disabled title="复活(需兑换码)">
            💖 复活 (<span id="revive-count">0</span>)
          </button>
          <button id="restart-btn" title="重新开始当前关卡">🔄重新开始</button>
          <button id="auto-collect-btn" title="自动收集(需兑换码)" disabled>
            自动🪽 (<span id="auto-collect-count">0</span>)
          </button>
        </div>
        <div id="code-bar">
          <input
            type="text"
            id="code-input"
            placeholder="兑换码"
            maxlength="12"
          />
          <button id="code-btn">兑换</button>
        </div>
        <div id="message-bar"></div>
      </div>
      <div id="footer">
        <p>超级喵喵 &copy; 2025 | Designed by 开元</p>
      </div>

      <div id="event-overlay">
        <div id="event-message-box">
          <div class="event-icon"></div>
          <p class="event-text"></p>
        </div>
      </div>

      <div id="start-screen">
        <video id="start-screen-video" autoplay loop muted playsinline>
          <source src="mao.webm" type="video/webm" />
          <source src="aimao.mp4" type="video/mp4" />
          <img src="mao.webp" alt="背景图" />
        </video>
        <h1>
          <span>超</span><span>级</span><span>喵</span><span>喵</span
          ><span>🐾</span>
        </h1>
        <p></p>
        <p>
          <button class="start-btn" id="start-btn">开始游戏</button>
        </p>
        <p>
          收集卡牌获得分数、全部清空过关<br />
          <span style="color: #c0392b">第二关难度略有升级<br /></span
          >可使用兑换码解锁道具
        </p>
        <small class="loading-footer"
          >超级喵喵 &copy; 2025 | Designed by 开元</small
        >
      </div>

      <div id="level2-outro-screen" style="display: none">
        <video id="outro-video" playsinline muted>
          <source src="mao2.mp4" type="video/mp4" />
          您的浏览器不支持视频播放。
        </video>
        <img
          id="outro-image"
          src="mao2.webp"
          alt="Level 2 Outro Image"
          style="display: none"
        />
        <div class="loading-text" style="display: none">正在加载...</div>
        <button id="skip-outro-btn" style="display: none">跳过动画</button>
      </div>

      <div id="level-finish" style="display: none">
        <div
          id="netease-player"
          class="responsive-video-container"
          style="display: none"
        >
          <iframe
            allow="encrypted-media *; fullscreen *; clipboard-write"
            frameborder="0"
            height="450"
            style="
							width: 100%;
							max-width: 660px;
							overflow: hidden;
							border-radius: 10px;
						"
            sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-storage-access-by-user-activation allow-top-navigation-by-user-activation"
            src="https://player.bilibili.com/player.html?isOutside=true&aid=114878413148199&bvid=BV1X9uQz6E6v&cid=31143166462&p=1"
          ></iframe>
        </div>
        <div id="player" style="display: none">
          <div id="player-content1">
            <div class="music-name"></div>
            <div class="artist-name"></div>
            <div class="time">
              <div class="current-time"></div>
              <div class="total-time"></div>
            </div>
            <div id="s-area">
              <div id="ins-time"></div>
              <div id="s-hover"></div>
              <div id="seek-bar"></div>
            </div>
          </div>
          <div id="player-content2">
            <div class="music-imgs">
              <div class="img"></div>
              <div id="buffer-box">缓冲,稍等...</div>
            </div>
            <div class="player-controls">
              <div class="btn prev iconfont"></div>
              <div class="btn play-pause icon-jiediankaishi iconfont"></div>
              <div class="btn next iconfont"></div>
            </div>
          </div>
        </div>
        <div id="level-finish-text"></div>
        <button id="next-btn">下一关</button>
        <button id="retry-btn" style="margin-left: 10px">重玩</button>
        <button id="gobang-btn" style="margin-left: 10px; display: none">
          五子棋对弈
        </button>
        <button id="restart-game-btn" style="margin-left: 10px; display: none">
          重开游戏
        </button>
        <button id="close-game-btn-level" style="margin-left: 10px">
          关闭游戏
        </button>
      </div>

      <div id="game-over" style="display: none">
        <div class="cloud-layer"></div>
        <div id="game-over-content">
          <div id="game-over-text"></div>
          <button id="retry-btn2">重试</button>
          <button
            id="revive-btn-gameover"
            style="margin-left: 10px; display: none"
          >
            💖 复活
          </button>
          <button id="close-game-btn-gameover" style="margin-left: 10px">
            关闭游戏
          </button>
        </div>
      </div>
    </div>
    <div
      id="pause-screen"
      class="modal-overlay"
      style="display: none; z-index: 2600;"
    >
      <div class="modal-content">
        <h2 style="font-size: 1.8rem; color: #5d4037; margin-bottom: 15px;">
          游戏已暂停
        </h2>
        <p style="margin-bottom: 25px;">休息一下，稍后继续！</p>
        <button
          id="resume-btn"
          style="padding: 12px 35px; font-size: 1.25rem; background: #e6f6d3; border: 2px solid #a0c388; border-radius: 12px; color: #3e5a2b; cursor: pointer;"
        >
          继续游戏
        </button>
      </div>
    </div>
    <div id="confirm-modal" class="modal-overlay">
      <div class="modal-content">
        <p id="confirm-msg">你确定吗？</p>
        <div class="modal-buttons">
          <button id="confirm-yes">确定</button>
          <button id="confirm-no">取消</button>
        </div>
      </div>
    </div>

    <audio id="bgm" loop preload="auto">您的浏览器不支持音频元素。</audio>

    <script src="js/jquery-3.4.1.min.js"></script>
    <script src="js/index.js"></script>
    <script>
      // 游戏配置和逻辑部分保持不变
      const CARD_ICONS = [
        "🐈",
        "💐",
        "👒",
        "🏵️",
        "🧸",
        "🔮",
        "🌷",
        "🎃",
        "🍪",
        "🐖",
        "🔆",
        "🌻",
        "🎁",
        "🌈",
        "🍟",
        "🕰️",
      ];
      const LEVELS = [
        // Level 1 now has more cards to ensure a visible heart shape can be formed.
        {
          num: 1,
          visible: 15,
          total: 42,
          stack: 1,
          rows: 3,
          cols: 5,
          overlap: 20,
          targetScore: 25,
          totalDisplaySets: 12,
        },
        {
          num: 2,
          visible: 15,
          total: 153,
          stack: 2,
          rows: 3,
          cols: 5,
          overlap: 20,
          targetScore: 100,
          totalDisplaySets: 30,
        },
      ];
      const TEMP_LIMIT = 7;
      const DISPLAY_CARD_MATCH_SCORE = 5;
      const INITIAL_DISPLAY_SETS_VISIBLE = 2;
      const FLYING_SPEED_PPS = 1000;

      const REDEMPTION_CODES = {
        haogege: { undo: 20, hint: 20, shuffle: 20, autoCollect: 20 },
        兑换码: { undo: 5, hint: 5, shuffle: 5 },
        或者去问他: {
          undo: 50,
          hint: 50,
          shuffle: 50,
          autoCollect: 40,
        },
        kaiyuan: { autoCollect: 20 },
        开元: { undo: 10, hint: 10, shuffle: 10 },
        通关: { type: "skip_level" },
        xianshi: { type: "curtain_off" },
        shuaige: { revive: 3 },
      };

      // DOM 元素获取部分保持不变
      const bgm = document.getElementById("bgm");
      const confirmModal = document.getElementById("confirm-modal");
      const confirmMsg = document.getElementById("confirm-msg");
      const confirmYes = document.getElementById("confirm-yes");
      const confirmNo = document.getElementById("confirm-no");
      const footer = document.getElementById("footer");
      const musicToggleBtn = document.getElementById("music-toggle");
      const startBtn = document.getElementById("start-btn");
      const nextBtn = document.getElementById("next-btn");
      const retryBtnLevelFinish = document.getElementById("retry-btn");
      const retryBtnGameOver = document.getElementById("retry-btn2");
      const gobangBtn = document.getElementById("gobang-btn");
      const restartGameBtn = document.getElementById("restart-game-btn");
      const closeGameBtnLevel = document.getElementById("close-game-btn-level");
      const closeGameBtnGameOver = document.getElementById(
        "close-game-btn-gameover"
      );
      const undoBtn = document.getElementById("undo-btn");
      const hintBtn = document.getElementById("hint-btn");
      const shuffleBtn = document.getElementById("shuffle-btn");
      const reviveBtn = document.getElementById("revive-btn");
      const reviveBtnGameOver = document.getElementById("revive-btn-gameover");
      const restartCurrentLevelBtn = document.getElementById("restart-btn");
      const codeInput = document.getElementById("code-input");
      const codeBtn = document.getElementById("code-btn");
      const levelFinishTextElement =
        document.getElementById("level-finish-text");
      const neteasePlayerDiv = document.getElementById("netease-player");
      const playerDiv = document.getElementById("player");
      const currentScoreElement = document.getElementById("current-score");
      const targetScoreElement = document.getElementById("target-score");
      const levelInfoElement = document.getElementById("level-info");
      const displayArea = document.getElementById("display-area");
      const cardStackArea = document.getElementById("card-stack-area");
      const catPath = document.getElementById("cat-path");
      const walkingCat = document.getElementById("walking-cat");
      const curtainElement = document.getElementById("curtain");
      const wigglingCat1 = document.getElementById("wiggling-cat-1");
      const wigglingCat4 = document.getElementById("wiggling-cat-4");
      const wigglingCat7 = document.getElementById("wiggling-cat-7");
      const level2OutroScreen = document.getElementById("level2-outro-screen");
      const outroVideo = document.getElementById("outro-video");
      const outroImage = document.getElementById("outro-image");
      const outroLoadingText = level2OutroScreen.querySelector(".loading-text");
      const skipOutroBtn = document.getElementById("skip-outro-btn");
      const eventOverlay = document.getElementById("event-overlay");
      const eventMessageBox = document.getElementById("event-message-box");
      const eventIconEl = eventMessageBox.querySelector(".event-icon");
      const eventTextEl = eventMessageBox.querySelector(".event-text");
      const autoCollectBtn = document.getElementById("auto-collect-btn");
      const autoCollectCountEl = document.getElementById("auto-collect-count");
      const pauseScreen = document.getElementById("pause-screen");
      const resumeBtn = document.getElementById("resume-btn");

      // 游戏状态和工具函数保持不变
      let autoCollectCount = 0;
      let autoCollectActive = false;
      let autoCollectPaused = false; // 标记自动收集是否被玩家手动暂停
      let autoCollectTimer = null;
      let confirmCallback = null;
      let outroVideoTimeout = null;
      let decorationInterval = null;
      let randomEventTimer = null;
      let curtainTimer = null;
      let isLandscape = false;
      let hasShownLandscapeMessage = false;
      let lastShakeTime = 0;
      let lastManualClickTime = 0;
      let autoCollectIdleWatcher = null;

      let audioContext;
      let clickSoundBuffer;
      let clickAudioFailed = false;

      let game = {
        level: 1,
        levelStartTime: 0,
        cards: [],
        board: [],
        temp: [],
        matched: [],
        usedIcons: [],
        toolUses: { undo: 0, hint: 0, shuffle: 0, revive: 0 },
        score: 0,
        targetScore: 0,
        displayCards: [],
        totalDisplaySetsGenerated: 0,
        progress: 0,
        stepStack: [],
        bgmOn: true,
        isNewLevel: false,
        lock: false,
        flyingCardCount: 0,
        isPaused: false,
        cardDimensions: {
          width: 0,
          height: 0,
          fontSize: 0,
          borderRadius: 0,
          borderWidth: 0,
        },
        layout: { areaWidth: 0, areaHeight: 0 },
        autoCollectEnabled: false,
        noShuffleCodePromptShown: false, // 新增：本关已显示过“兑换码获取洗牌次数”的提示
        isCurtainEnabled: true,
      };

      function randArr(arr) {
        return arr.slice().sort(() => Math.random() - 0.5);
      }
      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
      }
      function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
      function randBetween(a, b) {
        return a + Math.random() * (b - a);
      }

      async function initAudio() {
        try {
          // 1. 如果 context 已关闭或不存在，则必须创建一个新的
          if (!audioContext || audioContext.state === "closed") {
            console.log("AudioContext 已关闭或未创建，正在初始化一个新的。");
            // @ts-ignore
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)();
            clickSoundBuffer = null; // 为新的 context 强制重新加载音频 buffer
            clickAudioFailed = false; // 重置失败标志
          }

          // 2. 如果 context 被挂起（例如，由于浏览器自动播放策略或进入后台），尝试恢复它
          // 这是解决问题的关键步骤
          if (audioContext.state === "suspended") {
            console.log("AudioContext 已挂起，尝试恢复。");
            await audioContext.resume();
          }

          // 3. 如果此 context 还没有加载过音频 buffer，并且之前没有失败过，则加载它
          if (!clickSoundBuffer && !clickAudioFailed) {
            console.log("正在加载音频文件: kaa.mp3");
            const response = await fetch("kaa.mp3");
            const arrayBuffer = await response.arrayBuffer();
            // 使用现在保证可用的 context 来解码音频数据
            clickSoundBuffer = await audioContext.decodeAudioData(arrayBuffer);
            console.log("音频文件加载并解码成功。");
          }
        } catch (e) {
          console.error(
            "Web Audio API 初始化失败 (kaa.mp3)，将回退到 HTML5 Audio。",
            e
          );
          clickAudioFailed = true;
          // 失败时彻底清空，防止后续出错
          if (audioContext && audioContext.state !== "closed") {
            audioContext.close();
          }
          audioContext = null;
        }
      }

      function toggleAutoCollect() {
        if (autoCollectActive) {
          // 如果正在运行，则暂停
          autoCollectActive = false;
          autoCollectPaused = true;
          if (autoCollectTimer) {
            clearTimeout(autoCollectTimer);
            autoCollectTimer = null;
          }
          showMessage("自动收集已暂停");
        } else {
          // 如果未运行，则开始
          if (autoCollectCount <= 0) {
            showMessage("自动收集次数不足");
            return;
          }
          autoCollectActive = true;
          autoCollectPaused = false;
          showMessage("自动收集已启动", "#3e5a2b");
          autoCollectStep();
          startAutoCollectIdleWatcher(); // ✅ 确保这一行存在
        }
        updateAutoCollectStatus();
      }
      function stopAutoCollect() {
        autoCollectActive = false;
        autoCollectPaused = false;
        if (autoCollectTimer) {
          clearTimeout(autoCollectTimer);
          autoCollectTimer = null;
        }
        updateAutoCollectStatus();
      }

      function playBgm(on) {
        const bgmElement = document.getElementById("bgm");
        if (on) {
          if (bgmElement.src.indexOf("Sukidakara.mp3") === -1) {
            bgmElement.src = "Sukidakara.mp3";
          }
          bgmElement.volume = 0.2;
          const playPromise = bgmElement.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              console.log(
                "BGM play failed, most likely due to browser autoplay policy.",
                error
              );
            });
          }
        } else {
          bgmElement.pause();
        }
      }

      async function playClickSound() {
        // 关键改动：在播放任何声音之前，始终确保音频上下文是准备好的。
        // 这使得该功能具有自我修复能力。
        await initAudio();

        // 如果 Web Audio API 失败，则使用标准的 <audio> 标签作为后备方案
        if (clickAudioFailed) {
          const clickAudio = new Audio("kaa.mp3");
          clickAudio
            .play()
            .catch((e) => console.error("HTML5 Audio 回退播放失败:", e));
          return;
        }

        // 在尝试初始化后，再次检查所有条件是否满足
        if (
          !clickSoundBuffer ||
          !audioContext ||
          audioContext.state !== "running"
        ) {
          console.error("AudioContext 未运行或 buffer 未加载，无法播放声音。");
          return;
        }

        try {
          const source = audioContext.createBufferSource();
          source.buffer = clickSoundBuffer;
          source.connect(audioContext.destination);
          source.start(0);
        } catch (e) {
          console.error("通过 Web Audio API 播放点击音效失败:", e);
        }
      }

      function triggerMatchFeedback() {
        if (navigator.vibrate) {
          navigator.vibrate(100);
        }
        playClickSound();
      }

      function showConfirm(msg, callback) {
        confirmMsg.innerHTML = msg;
        confirmCallback = callback;
        confirmModal.style.display = "flex";
      }

      function hideConfirm() {
        confirmModal.style.display = "none";
        confirmCallback = null;
      }

      confirmYes.onclick = () => {
        const callback = confirmCallback;
        hideConfirm();
        if (callback) {
          setTimeout(callback, 20);
        }
      };
      confirmNo.onclick = hideConfirm;

      function generateDisplayCardSet(excludeIcons = []) {
        let chosenIcon = null;
        const visibleLayeredCards = game.board.filter(
          (c) =>
            !c.matched &&
            isCardClickable(c, game.board) &&
            c.stack >= 0 &&
            c.stack <= 3
        );
        const visibleLayeredIconCounts = {};
        visibleLayeredCards.forEach(
          (c) =>
            (visibleLayeredIconCounts[c.icon] =
              (visibleLayeredIconCounts[c.icon] || 0) + 1)
        );
        let potentialVisibleLayeredIcons = Object.keys(
          visibleLayeredIconCounts
        ).filter(
          (icon) =>
            !excludeIcons.includes(icon) && visibleLayeredIconCounts[icon] >= 3
        );
        if (potentialVisibleLayeredIcons.length > 0) {
          chosenIcon =
            potentialVisibleLayeredIcons[
              Math.floor(Math.random() * potentialVisibleLayeredIcons.length)
            ];
        } else {
          const allClickableBoardCards = game.board.filter(
            (c) => !c.matched && isCardClickable(c, game.board)
          );
          const combinedClickableIcons = [
            ...allClickableBoardCards.map((c) => c.icon),
            ...game.temp.map((c) => c.icon),
          ];
          const combinedClickableIconCounts = {};
          combinedClickableIcons.forEach(
            (icon) =>
              (combinedClickableIconCounts[icon] =
                (combinedClickableIconCounts[icon] || 0) + 1)
          );
          let potentialCombinedIcons = Object.keys(
            combinedClickableIconCounts
          ).filter(
            (icon) =>
              !excludeIcons.includes(icon) &&
              combinedClickableIconCounts[icon] >= 3
          );
          if (potentialCombinedIcons.length > 0) {
            chosenIcon =
              potentialCombinedIcons[
                Math.floor(Math.random() * potentialCombinedIcons.length)
              ];
          } else {
            const allIconsInGame = game.cards.map((c) => c.icon);
            const allIconCounts = {};
            allIconsInGame.forEach(
              (icon) => (allIconCounts[icon] = (allIconCounts[icon] || 0) + 1)
            );
            const anyTripletIcons = Object.keys(allIconCounts).filter(
              (icon) => !excludeIcons.includes(icon) && allIconCounts[icon] >= 3
            );
            if (anyTripletIcons.length > 0) {
              chosenIcon =
                anyTripletIcons[
                  Math.floor(Math.random() * anyTripletIcons.length)
                ];
            } else {
              const availableIconsWithoutExclusion = allIconsInGame.filter(
                (icon) => !excludeIcons.includes(icon)
              );
              if (availableIconsWithoutExclusion.length > 0) {
                chosenIcon =
                  availableIconsWithoutExclusion[
                    Math.floor(
                      Math.random() * availableIconsWithoutExclusion.length
                    )
                  ];
              } else if (allIconsInGame.length > 0) {
                chosenIcon =
                  allIconsInGame[
                    Math.floor(Math.random() * allIconsInGame.length)
                  ];
              } else {
                return null;
              }
            }
          }
        }
        if (chosenIcon) {
          return [
            { icon: chosenIcon, id: Date.now() + 1 },
            { icon: chosenIcon, id: Date.now() + 2 },
            { icon: chosenIcon, id: Date.now() + 3 },
          ];
        } else {
          return null;
        }
      }
      const STACK_RATIO = 5 / 4;
      function calculateResponsiveSizes() {
        const areaW = cardStackArea.offsetWidth;
        const areaH = cardStackArea.offsetHeight;

        /* 若浏览器不认 aspect-ratio 或被外层约束扭曲，这里强制修正高度 */
        const expectedH = areaW * STACK_RATIO;
        // 若为横屏，可适当放大高度
        const isLandscape = window.matchMedia(
          "(orientation: landscape)"
        ).matches;
        const adjustedH = isLandscape ? expectedH * 1.2 : expectedH;
        if (Math.abs(areaH - expectedH) > 1) {
          // 误差 1px 以内忽略
          cardStackArea.style.height = `${expectedH}px`;
        }
        const lv = LEVELS[game.level - 1];
        // Make cards slightly smaller to fit more complex shapes
        const baseCardWidth = areaW / (lv.cols + 3);
        const clampedCardWidth = Math.max(35, Math.min(baseCardWidth, 75));
        const cardAspectRatio = 65 / 85;
        const finalCardW = clampedCardWidth;
        const finalCardH = finalCardW / cardAspectRatio;
        game.cardDimensions = {
          width: finalCardW,
          height: finalCardH,
          fontSize: finalCardW * 0.45,
          borderRadius: finalCardW * 0.15,
          borderWidth: Math.max(2, finalCardW * 0.04),
        };
      }

      // =================================================================================
      // START OF MODIFICATION: Refined heart shape layout logic for centering and consistency.
      // =================================================================================
      //更优雅、可扩展的心形布局
      // 直接替换你现有的 repositionCardsAndLayout(cardsToPlace, levelConfig)
      function repositionCardsAndLayout(cardsToPlace, levelConfig) {
        // ——— 美学/密度/遮挡（亲密距离版） ———
        const HEART_SETTINGS = {
          RING_COUNT_MIN: 4,
          RING_COUNT_MAX: 8,
          RING_INNER_SCALE: 0.52, // 内层更收束
          EDGE_SPACING_FACTOR: 0.88, // 外轮廓更紧致（环上相邻卡片更近）
          GRID_SPACING_X: 0.86, // 内区六角网格更密
          GRID_SPACING_Y: 0.8,
          JITTER_PX: 0.06, // 轻微抖动，保留手工质感
          MIN_DIST_FACTOR: 0.88, // 蓝噪点最小距离（相对卡片宽）
          OVERLAP_TASTE: 0.12, // 轻度遮挡倾向，制造温柔层次
        };

        // 关卡心形整体缩放：L1 稍小，L2 正常
        const currentLevel = levelConfig?.num ?? game?.level ?? 1;
        const LEVEL_HEART_SCALE = {
          1: 0.92, // 第一关“稍微小一点”
          2: 1.0, // 第二关正常
        };
        const heartGlobalScale = LEVEL_HEART_SCALE[currentLevel] ?? 1.0;

        // 1) 场景与卡片尺寸
        const areaW = cardStackArea.offsetWidth;
        const areaH = cardStackArea.offsetHeight;
        calculateResponsiveSizes();
        const cardW = game.cardDimensions.width;
        const cardH = game.cardDimensions.height;

        // 2) 心形参数曲线
        function heartXY(t) {
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = -(
            13 * Math.cos(t) -
            5 * Math.cos(2 * t) -
            2 * Math.cos(3 * t) -
            Math.cos(4 * t)
          );
          return { x, y };
        }

        // 3) 采样基础心形以获边界
        function sampleBaseHeart(res = 720) {
          const pts = [];
          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
          for (let i = 0; i <= res; i++) {
            const t = (i / res) * Math.PI * 2;
            const p = heartXY(t);
            pts.push(p);
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
          }
          return { pts, minX, maxX, minY, maxY };
        }

        const base = sampleBaseHeart(720);
        const baseW = base.maxX - base.minX;
        const baseH = base.maxY - base.minY;

        // 给心形与容器留边距，避免贴边
        const marginX = cardW * 1.4;
        const marginY = cardH * 1.6;

        // 基础缩放，再乘以关卡缩放
        const scalePx =
          Math.min((areaW - marginX) / baseW, (areaH - marginY) / baseH) *
          heartGlobalScale;

        const centerX = areaW / 2;
        const centerY = areaH / 2;

        // 将单位心形映射到容器像素
        function mapToPx(p, s = 1) {
          return {
            x: centerX + p.x * scalePx * s,
            y: centerY + p.y * scalePx * s,
          };
        }

        // 4) 心形曲线等弧长取点（相位支持）
        function evenlySpacedOnHeart(scaleFactor, spacingPx, phase = 0) {
          const dense = [];
          const step = 0.005;
          for (let t = 0; t < Math.PI * 2 + step; t += step) {
            const tt = t + phase;
            const p = heartXY(tt);
            dense.push(mapToPx(p, scaleFactor));
          }
          const pts = [];
          let acc = 0;
          for (let i = 1; i < dense.length; i++) {
            const a = dense[i - 1],
              b = dense[i];
            const d = Math.hypot(b.x - a.x, b.y - a.y);
            acc += d;
            if (acc >= spacingPx) {
              pts.push(b);
              acc = 0;
            }
          }
          return pts;
        }

        // 5) 点在多边形内部（射线法），用于内区填充
        const outlinePx = base.pts.map((p) => mapToPx(p, 1));
        function pointInPolygon(px, py, poly) {
          let inside = false;
          for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
            const xi = poly[i].x,
              yi = poly[i].y;
            const xj = poly[j].x,
              yj = poly[j].y;
            const intersect =
              yi > py !== yj > py &&
              px < ((xj - xi) * (py - yi)) / (yj - yi + 0.00001) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }

        // 6) 六角网格内填充（用于心形内部）
        function hexGridFill(scaleFactor, spacingX, spacingY) {
          const pts = [];
          const innerOutline = base.pts.map((p) => mapToPx(p, scaleFactor));
          let minX = Infinity,
            maxX = -Infinity,
            minY = Infinity,
            maxY = -Infinity;
          innerOutline.forEach((p) => {
            if (p.x < minX) minX = p.x;
            if (p.x > maxX) maxX = p.x;
            if (p.y < minY) minY = p.y;
            if (p.y > maxY) maxY = p.y;
          });
          let row = 0;
          for (let y = minY; y <= maxY; y += spacingY) {
            const offset = row % 2 ? spacingX / 2 : 0;
            for (let x = minX - spacingX; x <= maxX + spacingX; x += spacingX) {
              const px = x + offset,
                py = y;
              if (pointInPolygon(px, py, innerOutline))
                pts.push({ x: px, y: py });
            }
            row++;
          }
          return pts;
        }

        // 7) 自适应环数与容量
        const N = cardsToPlace.length;
        const targetEdgeSpacing = cardW * HEART_SETTINGS.EDGE_SPACING_FACTOR;

        const outerDense = evenlySpacedOnHeart(1.0, targetEdgeSpacing);
        const outerCapacity = outerDense.length;

        const ringCountRaw = Math.round(
          HEART_SETTINGS.RING_COUNT_MIN +
            Math.min(
              1,
              Math.max(0, (N - outerCapacity) / (outerCapacity * 2))
            ) *
              (HEART_SETTINGS.RING_COUNT_MAX - HEART_SETTINGS.RING_COUNT_MIN)
        );
        const ringCount = Math.max(
          HEART_SETTINGS.RING_COUNT_MIN,
          Math.min(HEART_SETTINGS.RING_COUNT_MAX, ringCountRaw)
        );

        const innerScale = HEART_SETTINGS.RING_INNER_SCALE;
        const ringShrink =
          ringCount > 1 ? (1 - innerScale) / (ringCount - 1) : 0;

        // 8) 多环外轮廓（相位错开，产生柔和遮挡）
        const rings = [];
        for (let k = 0; k < ringCount; k++) {
          const extra =
            HEART_SETTINGS.OVERLAP_TASTE * (k / Math.max(1, ringCount - 1));
          const s = Math.max(0.35, 1 - k * ringShrink - extra);
          const phase = (k * Math.PI) / (2.5 + Math.random() * 0.5);
          const pts = evenlySpacedOnHeart(s, targetEdgeSpacing, phase);
          rings.push({ scale: s, points: pts, ringIndex: k });
        }

        // 9) 内区填充
        const gridSpacingX = cardW * HEART_SETTINGS.GRID_SPACING_X;
        const gridSpacingY = cardH * HEART_SETTINGS.GRID_SPACING_Y;
        const innerFillScale = Math.max(innerScale * 0.92, 0.45);
        let innerPts = hexGridFill(innerFillScale, gridSpacingX, gridSpacingY);

        // 10) 汇总候选并蓝噪点筛选（保持最小距离，避免重叠）
        const minDist = cardW * HEART_SETTINGS.MIN_DIST_FACTOR;
        const jitterPx = cardW * HEART_SETTINGS.JITTER_PX;

        const candidates = [];
        rings.forEach((r) => {
          r.points.forEach((p) =>
            candidates.push({ ...p, ringIndex: r.ringIndex, kind: "ring" })
          );
        });
        innerPts.forEach((p) =>
          candidates.push({ ...p, ringIndex: ringCount, kind: "inner" })
        );

        // 容量兜底：不够则追加更内小环与更密网格
        function ensureCapacity(targetCount) {
          let guard = 0;
          while (candidates.length < targetCount && guard < 6) {
            guard++;
            const addRingScale = Math.max(innerFillScale - 0.06, 0.4);
            const added = evenlySpacedOnHeart(
              addRingScale,
              targetEdgeSpacing * 0.95,
              Math.random() * Math.PI
            );
            added.forEach((p) =>
              candidates.push({
                ...p,
                ringIndex: ringCount + guard,
                kind: "ring+",
              })
            );

            const gx = gridSpacingX * 0.94;
            const gy = gridSpacingY * 0.94;
            hexGridFill(innerFillScale * 0.98, gx, gy).forEach((p) => {
              candidates.push({
                ...p,
                ringIndex: ringCount + guard,
                kind: "inner+",
              });
            });
          }
        }
        ensureCapacity(N * 1.2);

        const placed = [];
        const shuffledCandidates = candidates
          .slice()
          .sort(() => Math.random() - 0.5);

        for (const c of shuffledCandidates) {
          if (placed.length >= N) break;
          let ok = true;
          for (let i = 0; i < placed.length; i++) {
            const p = placed[i];
            if (Math.hypot(p.x - c.x, p.y - c.y) < minDist) {
              ok = false;
              break;
            }
          }
          if (ok) {
            const jx = (Math.random() * 2 - 1) * jitterPx;
            const jy = (Math.random() * 2 - 1) * jitterPx;
            placed.push({ x: c.x + jx, y: c.y + jy, ringIndex: c.ringIndex });
          }
        }

        // 放宽距离兜底
        let relaxStep = 0;
        while (placed.length < N && relaxStep < 3) {
          relaxStep++;
          for (const c of shuffledCandidates) {
            if (placed.length >= N) break;
            let ok = true;
            for (let i = 0; i < placed.length; i++) {
              const p = placed[i];
              if (
                Math.hypot(p.x - c.x, p.y - c.y) <
                minDist * (1 - 0.12 * relaxStep)
              ) {
                ok = false;
                break;
              }
            }
            if (ok) placed.push({ x: c.x, y: c.y, ringIndex: c.ringIndex });
          }
        }
        // 最后兜底
        while (placed.length < N) {
          const idx = Math.floor(Math.random() * shuffledCandidates.length);
          const c = shuffledCandidates[idx];
          placed.push({ x: c.x, y: c.y, ringIndex: c.ringIndex });
        }

        // 11) 分配给卡片并输出
        const cards = [...cardsToPlace];
        shuffle(cards); // 使用你已有的 shuffle

        // z顺序：按环层、再按 y（下方略压上方），stack 归一到 0..3
        placed.sort((a, b) => a.ringIndex - b.ringIndex || a.y - b.y);
        let zCounter = 0;
        const out = [];

        for (let i = 0; i < cards.length; i++) {
          const c = cards[i];
          const p = placed[i];
          // 将 ringIndex 线性映射到 0..3，兼容你现有 stack 逻辑
          const stackNorm = Math.min(
            3,
            Math.max(
              0,
              Math.floor((p.ringIndex / Math.max(1, ringCount - 1)) * 3)
            )
          );
          out.push({
            ...c,
            x: Math.round(p.x - cardW / 2),
            y: Math.round(p.y - cardH / 2),
            z: zCounter++,
            stack: stackNorm,
          });
        }

        return out;
      }

      function genLevel(levelIdx) {
        const lv = LEVELS[levelIdx - 1];
        game.score = 0;
        game.targetScore = lv.targetScore;
        game.totalDisplaySetsGenerated = 0;
        game.isCurtainEnabled = true;
        let allIcons = [];
        const requiredUniqueIcons = Math.ceil(lv.total / 3);
        let availableIcons = randArr(CARD_ICONS).slice(
          0,
          Math.min(CARD_ICONS.length, requiredUniqueIcons + 2)
        );
        let iconPool = [];
        for (let i = 0; i < requiredUniqueIcons; i++) {
          for (let j = 0; j < 3; j++) {
            iconPool.push(availableIcons[i % availableIcons.length]);
          }
        }
        while (iconPool.length < lv.total) {
          const remaining = lv.total - iconPool.length;
          if (remaining < 3) {
            for (let i = 0; i < remaining; i++)
              iconPool.push(availableIcons[i % availableIcons.length]);
          } else {
            const iconToAdd =
              availableIcons[Math.floor(Math.random() * availableIcons.length)];
            iconPool.push(iconToAdd, iconToAdd, iconToAdd);
          }
        }
        shuffle(iconPool);
        allIcons = iconPool;
        let cards = [];
        for (let i = 0; i < lv.total; i++) {
          cards.push({ id: i, icon: allIcons[i], matched: false });
        }
        game.cards = cards;
        // Use the new heart-shaped layout function
        game.board = repositionCardsAndLayout(
          cards.map((c) => ({
            ...c,
            covered: false,
            isNapping: false,
          })),
          lv
        );
        game.displayCards = [];
        const usedDisplayIconsForLevel = new Set();
        for (let i = 0; i < INITIAL_DISPLAY_SETS_VISIBLE; i++) {
          const newSet = generateDisplayCardSet(
            Array.from(usedDisplayIconsForLevel)
          );
          if (newSet) {
            game.displayCards.push({
              id: `display-set-${i}`,
              cards: newSet,
              matched: false,
            });
            usedDisplayIconsForLevel.add(newSet[0].icon);
            game.totalDisplaySetsGenerated++;
          }
        }
        return {
          cards: game.cards,
          board: game.board,
          usedIcons: availableIcons.slice(0, Math.ceil(lv.total / 3)),
        };
      }

      /**
       * Checks if a card is clickable by verifying it's not covered by another card.
       * This logic is crucial for the stacking mechanic.
       * @param {Object} card - The card to check.
       * @param {Array} board - The current game board.
       * @returns {boolean} - True if the card is on the top layer and clickable, false otherwise.
       */
      function isCardClickable(card, board) {
        // A card cannot be clicked if it's already matched, being animated, or "napping".
        if (card.matched || card.isFlying || card.isNapping) return false;

        const activeCards = board.filter((c) => !c.matched && !c.isFlying);
        const cardW = game.cardDimensions.width;
        const cardH = game.cardDimensions.height;

        // To be clickable, a card must not be covered. We check this by seeing if the
        // center point of the card is inside the bounding box of any other card
        // that has a higher z-index (is stacked on top).
        const centerX = card.x + cardW / 2;
        const centerY = card.y + cardH / 2;

        for (const otherCard of activeCards) {
          if (card.id === otherCard.id) continue;

          // The core of the "top layer" logic: only cards with a higher z-index can block the current card.
          if (otherCard.z > card.z) {
            const otherLeft = otherCard.x;
            const otherRight = otherCard.x + cardW;
            const otherTop = otherCard.y;
            const otherBottom = otherCard.y + cardH;

            // Check if the center of the current card falls within the bounds of the other card.
            if (
              centerX > otherLeft &&
              centerX < otherRight &&
              centerY > otherTop &&
              centerY < otherBottom
            ) {
              return false; // It's blocked by a card on top.
            }
          }
        }
        return true; // No card is blocking it, so it's on the top layer and clickable.
      }

      // 下一个可用的暂存槽位（队列语义）
      function getNextTempIndex() {
        const used = game.temp.filter((c) => !c.matched).length;
        if (used >= TEMP_LIMIT) return -1;
        return used; // 0..6，从左到右依次进入
      }

      // MODIFIED: clickCard function with robust state checking
      function clickCard(id, isAuto = false) {
        // 如果是玩家手动点击，并且自动收集正在运行，则暂停它
        if (!isAuto && autoCollectActive) {
          autoCollectPaused = true;
          lastManualClickTime = Date.now(); // 记录手动点击时间
          if (autoCollectTimer) clearTimeout(autoCollectTimer);
          showMessage("自动收集已暂停，手动操作中");
          updateAutoCollectStatus();
        }

        let cardData = game.board.find((c) => c.id === id);
        if (
          game.lock ||
          !cardData ||
          cardData.matched ||
          cardData.isFlying ||
          cardData.isNapping ||
          !isCardClickable(cardData, game.board)
        ) {
          if (game.temp.filter((c) => !c.matched).length >= TEMP_LIMIT) {
            showMessage("暂存区已满，无法再放入卡片");
          }
          // 如果是无效点击，但之前是自动收集中，则尝试恢复
          if (isAuto) tryResumeAutoCollect();
          return;
        }

        playClickSound();
        saveStep();

        cardData.matched = true;
        cardData.isFlying = true;
        game.flyingCardCount++;
        game.lock = true; // 锁定游戏直到动画完成

        const clickedCardEl = document.querySelector(
          `#card-stack-area .card[data-id='${id}']`
        );
        if (!clickedCardEl) {
          cardData.matched = false;
          cardData.isFlying = false;
          game.flyingCardCount--;
          game.lock = false;
          if (isAuto) tryResumeAutoCollect();
          return;
        }

        const startRect = clickedCardEl.getBoundingClientRect();
        const flyingCard = document.createElement("div");
        flyingCard.className = "flying-card";
        flyingCard.innerHTML = cardData.icon;
        const gameContainer = document.getElementById("game-container");
        const themeClass = Array.from(gameContainer.classList).find((cls) =>
          cls.startsWith("theme-")
        );
        if (themeClass) flyingCard.classList.add(themeClass);
        document.body.appendChild(flyingCard);
        Object.assign(flyingCard.style, {
          left: `${startRect.left}px`,
          top: `${startRect.top}px`,
          width: `${startRect.width}px`,
          height: `${startRect.height}px`,
          fontSize: `${game.cardDimensions.fontSize}px`,
          borderRadius: `${game.cardDimensions.borderRadius}px`,
          borderWidth: `${game.cardDimensions.borderWidth}px`,
        });
        clickedCardEl.style.visibility = "hidden";
        // 新逻辑——队列：下一个空位（左→右）
        const tempSlots = document.querySelectorAll("#temp-area .temp-slot");
        const endSlotIndex = getNextTempIndex();
        if (endSlotIndex < 0 || endSlotIndex >= tempSlots.length) {
          if (flyingCard.parentNode) flyingCard.remove();
          cardData.matched = false;
          cardData.isFlying = false;
          game.flyingCardCount--;
          clickedCardEl.style.visibility = "visible";
          game.lock = false;
          if (isAuto) tryResumeAutoCollect();
          return;
        }
        const endRect = tempSlots[endSlotIndex].getBoundingClientRect();
        const tempSlotStyle = window.getComputedStyle(tempSlots[endSlotIndex]);
        const flyingCardFinalWidth = parseFloat(tempSlotStyle.width);
        const flyingCardFinalHeight = parseFloat(tempSlotStyle.height);
        const distance = Math.hypot(
          endRect.left - startRect.left,
          endRect.top - startRect.top
        );
        const animationDuration = Math.max(
          200,
          Math.min(500, (distance / FLYING_SPEED_PPS) * 1000)
        );
        flyingCard.style.transition = `all ${animationDuration}ms ease-out`;
        requestAnimationFrame(() => {
          const destLeft =
            endRect.left + (endRect.width - flyingCardFinalWidth) / 2;
          const destTop =
            endRect.top + (endRect.height - flyingCardFinalHeight) / 2;
          flyingCard.style.left = `${destLeft}px`;
          flyingCard.style.top = `${destTop}px`;
          flyingCard.style.transform = `scale(${
            flyingCardFinalWidth / startRect.width
          })`;
        });

        // 动画结束后处理
        setTimeout(() => {
          if (flyingCard.parentNode) flyingCard.remove();
          game.flyingCardCount--;
          delete cardData.isFlying;
          // ↓↓↓ 新增：飞牌计数变化后尝试刷新屏障队列
          AnimBarrier.tryFlush();
          game.temp.push({
            icon: cardData.icon,
            id: cardData.id,
            matched: false,
          });
          game.temp.sort((a, b) => a.icon.localeCompare(b.icon) || a.id - b.id);
          renderTemp();
          renderBoard();
          updateAutoCollectStatus(); // 更新按钮状态

          let iconCnt = {};
          game.temp.forEach((c) => {
            if (!c.matched) iconCnt[c.icon] = (iconCnt[c.icon] || 0) + 1;
          });
          let matchedIcon = Object.keys(iconCnt).find((k) => iconCnt[k] === 3);

          if (matchedIcon) {
            triggerMatchFeedback();
            const toVanishIndexes = [];
            game.temp.forEach((card, i) => {
              if (card.icon === matchedIcon && !card.matched) {
                card.matched = true;
                toVanishIndexes.push(i);
              }
            });
            if (isAuto && autoCollectCount > 0) {
              autoCollectCount--;
              updateAutoCollectStatus();
            }
            let animationsToComplete = toVanishIndexes.length;
            const finishCleanup = () => {
              game.temp = game.temp.filter((c) => !c.matched);
              renderTemp();
              renderBoard();
              game.lock = false;
              checkWin();
              tryResumeAutoCollect();
              // ↓↓↓ 新增：解锁后尝试刷新屏障队列
              AnimBarrier.tryFlush();
            };
            if (animationsToComplete === 0) {
              finishCleanup();
            } else {
              toVanishIndexes.forEach((idx) => {
                const cardEl = tempSlots[idx]?.querySelector(".temp-card");
                if (cardEl) {
                  cardEl.classList.add("vanishing");
                  cardEl.addEventListener(
                    "animationend",
                    () => {
                      animationsToComplete--;
                      if (animationsToComplete === 0) finishCleanup();
                    },
                    { once: true }
                  );
                } else {
                  animationsToComplete--;
                }
              });
              if (animationsToComplete === 0) finishCleanup();
              setTimeout(() => {
                if (animationsToComplete > 0) finishCleanup();
              }, 700);
            }

            // 处理计分展示区的逻辑保持不变
            game.displayCards.forEach((displaySet) => {
              if (
                !displaySet.matched &&
                displaySet.cards[0].icon === matchedIcon
              ) {
                displaySet.matched = true;
                game.score += DISPLAY_CARD_MATCH_SCORE;
                renderProgressAndScore();
                const matchedDisplayGroupEl = document.querySelector(
                  `#display-area .display-group[data-id='${displaySet.id}']`
                );
                if (matchedDisplayGroupEl) {
                  const groupRect =
                    matchedDisplayGroupEl.getBoundingClientRect();
                  const scoreAnimDiv = document.createElement("div");
                  scoreAnimDiv.className = "score-animation";
                  scoreAnimDiv.textContent = `+${DISPLAY_CARD_MATCH_SCORE}`;
                  document.body.appendChild(scoreAnimDiv);
                  scoreAnimDiv.style.left = `${
                    groupRect.left + groupRect.width / 2
                  }px`;
                  scoreAnimDiv.style.top = `${
                    groupRect.top + groupRect.height / 2
                  }px`;
                  scoreAnimDiv.style.transform = "translate(-50%, -50%)";
                  scoreAnimDiv.addEventListener(
                    "animationend",
                    () => scoreAnimDiv.remove(),
                    { once: true }
                  );
                }
                setTimeout(() => {
                  const newSet = generateDisplayCardSet(
                    game.displayCards.map((ds) => ds.cards[0].icon)
                  );
                  if (newSet) {
                    displaySet.cards = newSet;
                    displaySet.matched = false;
                  } else {
                    game.displayCards = game.displayCards.filter(
                      (ds) => ds.id !== displaySet.id
                    );
                  }
                  renderDisplay();
                }, 400);
              }
            });
          } else {
            game.lock = false;
            checkWin();
            tryResumeAutoCollect();
            // ↓↓↓ 新增：解锁后尝试刷新屏障队列
            AnimBarrier.tryFlush();
          }
        }, animationDuration);
      }

      function checkWin() {
        // MODIFIED: Add an early exit if a game end screen is already visible
        const levelFinishScreen = document.getElementById("level-finish");
        const gameOverScreen = document.getElementById("game-over");
        if (
          levelFinishScreen.style.display === "flex" ||
          gameOverScreen.style.display === "flex"
        ) {
          return;
        }

        const allCardsMatched = game.board.every((c) => c.matched);
        const scoreMet = game.score >= game.targetScore;

        if (
          game.temp.filter((c) => !c.matched).length >= TEMP_LIMIT &&
          !allCardsMatched
        ) {
          gameOver("暂存区已超限，游戏失败！");
          return;
        }

        if (allCardsMatched && scoreMet) {
          stopAutoCollect(); // 关卡结束时彻底停止自动收集
          game.ended = true; // ← 标记已经结束
          game.autoCollectEnabled = false; // ← 新增：彻底禁用自动收集
          stopRandomEvents();
          stopCurtainRandomToggle();
          stopDecorationUpdates();
          game.lock = true;
          const elapsedSeconds = (
            (Date.now() - game.levelStartTime) /
            1000
          ).toFixed(1);
          const message = `本关过关用时 ${elapsedSeconds} 秒`;
          const originalYesText = confirmYes.textContent;
          const originalNoDisplay = confirmNo.style.display;
          confirmYes.textContent = "好的";
          confirmNo.style.display = "none";
          showConfirm(message, () => {
            if (game.level === 1) {
              showLevelFinish("恭喜恭喜！第一关通关！");
            } else {
              showLevelFinish("<p> <p>所有关卡全部通关！<br> 🎉 你太棒啦！🎉");
            }
            confirmYes.textContent = originalYesText;
            confirmNo.style.display = originalNoDisplay;
          });
        } else if (allCardsMatched && !scoreMet) {
          game.ended = true; // ← 标记已经结束
          stopAutoCollect(); // 关卡结束时彻底停止自动收集
          gameOver(
            `卡牌已全部消除，但分数未达标！<br>当前分数: ${game.score} / 目标分数: ${game.targetScore}`
          );
        }
        //updateAutoCollectStatus();
      }

      function saveStep() {
        game.stepStack.push({
          board: deepClone(game.board),
          temp: deepClone(game.temp),
          score: game.score,
          displayCards: deepClone(game.displayCards),
          totalDisplaySetsGenerated: game.totalDisplaySetsGenerated,
        });
        if (game.stepStack.length > 20) game.stepStack.shift();
      }

      function undoStep() {
        if (game.stepStack.length > 0) {
          let prev = game.stepStack.pop();
          game.board = deepClone(prev.board);
          game.temp = deepClone(prev.temp);
          game.score = prev.score;
          game.displayCards = deepClone(prev.displayCards);
          game.totalDisplaySetsGenerated = prev.totalDisplaySetsGenerated;
          renderAll();
          showMessage("已撤销");
          updateToolButtons(); // Ensure tool buttons are updated after undo
          updateWigglingCatVisibility();
        } else {
          showMessage("无法撤销更多", "#888");
        }
      }

      function animateCardsInBatches(cards, batchSize = 20, delay = 100) {
        let index = 0;

        function animateBatch() {
          const batch = cards.slice(index, index + batchSize);
          batch.forEach((card) => {
            card.classList.add("swirl-in");
          });
          index += batchSize;
          if (index < cards.length) {
            setTimeout(animateBatch, delay);
          } else {
            // 所有动画完成后，强制刷新游戏状态
            setTimeout(() => {
              // 重新计算卡片位置
              game.board = repositionCardsAndLayout(
                game.board,
                LEVELS[game.level - 1]
              );

              // 清除动画类名，防止干扰点击
              cards.forEach((card) => card.classList.remove("swirl-in"));

              // 强制刷新 DOM
              renderAll();

              game.lock = false;
              showMessage("已洗牌");
            }, 600); // 等待最后一批动画完成
          }
        }

        animateBatch();
      }
      // 辅助函数：分批次为卡片添加 "swirl-in" 动画
      function animateShuffleInBatches(cards, onAnimationEnd) {
        let index = 0;
        const batchSize = 20; // 每批处理20个卡片
        const delay = 100; // 每批之间的延迟

        function animateBatch() {
          const batch = cards.slice(index, index + batchSize);
          batch.forEach((card) => {
            card.classList.add("swirl-in");
            // 为每个卡片添加一次性的动画结束监听器
            card.addEventListener("animationend", onAnimationEnd, {
              once: true,
            });
          });
          index += batchSize;
          if (index < cards.length) {
            setTimeout(animateBatch, delay);
          }
        }
        animateBatch();
      }

      // 新的 shuffleStep 函数，调用上面的辅助函数
      function shuffleStep(isAutoShuffle = false) {
        saveStep();
        game.lock = true;
        AnimBarrier.begin("shuffle");
        const allCards = Array.from(
          document.querySelectorAll("#card-stack-area .card:not(.matched)")
        );
        const visibleCards = allCards.filter(
          (card) => card.offsetParent !== null
        );

        if (visibleCards.length === 0) {
          game.lock = false;
          AnimBarrier.end("shuffle");
          AnimBarrier.tryFlush();
          // 如果是自动洗牌触发的，即时没有卡片也要检查
          if (isAutoShuffle) {
            checkAndShuffleLoop();
          }
          return;
        }

        let animationsToComplete = visibleCards.length;

        const cleanupAfterShuffle = () => {
          game.board = repositionCardsAndLayout(
            game.board,
            LEVELS[game.level - 1]
          );
          renderAll();

          // 只有在非自动洗牌时才显示 "已洗牌"
          if (!isAutoShuffle) {
            showMessage("已洗牌");
          }

          game.lock = false;
          updateWigglingCatVisibility();
          updateAutoCollectStatus();
          AnimBarrier.end("shuffle");
          AnimBarrier.tryFlush();

          // --- 核心修改 ---
          // 如果这次洗牌是自动收集触发的，就调用新的循环检查函数
          if (isAutoShuffle) {
            checkAndShuffleLoop();
          } else {
            // 否则，执行原来的逻辑
            tryResumeAutoCollect();
            if (
              autoCollectActive &&
              !findDisplayAreaTriple() &&
              !findAnyTriple()
            ) {
              stopAutoCollect();
              showMessage("洗牌后无三消，自动收集已停止");
            }
          }
        };

        const handleAnimationEnd = () => {
          animationsToComplete--;
          if (animationsToComplete === 0) {
            cleanupAfterShuffle();
          }
        };

        visibleCards.forEach((card) => card.classList.remove("swirl-in"));
        animateShuffleInBatches(visibleCards, handleAnimationEnd);
      }

      function hintStep() {
        let tempIcons = game.temp.map((c) => c.icon);
        let clickableBoardCards = game.board.filter(
          (c) => !c.matched && isCardClickable(c, game.board)
        );
        let clickableBoardIcons = clickableBoardCards.map((c) => c.icon);
        let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];
        let iconCounts = {};
        allAvailableIcons.forEach(
          (icon) => (iconCounts[icon] = (iconCounts[icon] || 0) + 1)
        );
        // Fixed typo: changed iconCnt to iconCounts
        let targetIcon = Object.keys(iconCounts).find(
          (icon) => iconCounts[icon] >= 3
        );

        // Remove any existing hinted-shake classes before applying new ones
        document
          .querySelectorAll(".hinted-shake")
          .forEach((el) => el.classList.remove("hinted-shake"));

        if (targetIcon) {
          let hintDone = 0;
          const hintedElements = [];

          // Highlight cards in temp area
          for (let i = 0; i < game.temp.length && hintDone < 3; i++) {
            if (game.temp[i].icon === targetIcon && !game.temp[i].matched) {
              const tempCardElement = document.querySelectorAll(
                "#temp-area .temp-slot .temp-card"
              )[i];
              if (tempCardElement) {
                tempCardElement.classList.add("hinted-shake");
                hintedElements.push(tempCardElement);
                hintDone++;
              }
            }
          }

          // Highlight cards on the board
          for (let i = 0; i < clickableBoardCards.length && hintDone < 3; i++) {
            let boardCard = clickableBoardCards[i];
            if (boardCard.icon === targetIcon) {
              let doms = document.querySelector(
                `#card-stack-area .card[data-id='${boardCard.id}']`
              );
              if (doms) {
                doms.classList.add("hinted-shake");
                hintedElements.push(doms);
                hintDone++;
              }
            }
          }

          showMessage("已提示可消除三张");
          // Remove the shake animation after a short delay
          setTimeout(
            () =>
              hintedElements.forEach((el) =>
                el.classList.remove("hinted-shake")
              ),
            2000
          );
        } else {
          showMessage("当前无可三消", "#888");
        }
      }
      reviveBtnGameOver.addEventListener("click", reviveGame);
      function gameOver(msg) {
        stopRandomEvents();
        stopCurtainRandomToggle();
        stopDecorationUpdates();
        stopAutoCollect(); // 确保停止
        stopAutoCollectIdleWatcher();
        game.lock = true;
        document.getElementById("card-stack-area").innerHTML = "";
        document.querySelectorAll("#temp-area .temp-slot").forEach((slot) => {
          slot.innerHTML = "";
        });
        displayArea.innerHTML = "";
        document.getElementById("level-info").textContent = "";
        currentScoreElement.textContent = "0";
        targetScoreElement.textContent = "0";
        document.getElementById("message-bar").textContent = "";
        hideWigglingCats();
        document
          .querySelectorAll(".flying-card")
          .forEach((card) => card.remove());
        game.flyingCardCount = 0;
        const gameOverScreen = document.getElementById("game-over");
        gameOverScreen.style.display = "flex";
        gameOverScreen.querySelector("#game-over-text").innerHTML = msg;
        if (game.toolUses.revive > 0) {
          reviveBtnGameOver.style.display = "inline-block";
        } else {
          reviveBtnGameOver.style.display = "none";
        }
      }

      function reviveGame() {
        if (game.toolUses.revive <= 0) {
          showMessage("没有复活卡了！", "#c0392b");
          return;
        }

        showConfirm(
          "确定要使用1次复活卡吗？这将回到游戏界面并解除打盹卡片。",
          () => {
            game.toolUses.revive--;

            // 撤销最后一步（只pop一次）
            if (game.stepStack.length > 0) {
              game.stepStack.pop();
            }

            // 还原到上一步状态（如果有）
            if (game.stepStack.length > 0) {
              let prev = game.stepStack[game.stepStack.length - 1];
              game.board = deepClone(prev.board);
              game.temp = deepClone(prev.temp);
              game.score = prev.score;
              game.displayCards = deepClone(prev.displayCards);
              game.totalDisplaySetsGenerated = prev.totalDisplaySetsGenerated;
            } else {
              // 如果没有历史步骤，则重开当前关卡
              startGame(game.level);
              showMessage("复活成功！已回到本关初始状态。", "#3e5a2b");
              return;
            }

            // 解除所有 nap 状态
            game.board.forEach((card) => {
              card.isNapping = false;
            });

            document.getElementById("game-over").style.display = "none";
            game.lock = false;
            renderAll();
            showMessage("复活成功！撤销最后一步并唤醒全部卡片。", "#3e5a2b");
            startRandomEvents();
            startCurtainRandomToggle();
            startDecorationUpdates();
          }
        );
      }

      function startGame(level) {
        game.lock = true;
        footer.style.display = "block";
        game.level = level;
        game.levelStartTime = Date.now();
        game.flyingCardCount = 0;
        game.noShuffleCodePromptShown = false;
        let lvData = genLevel(level);
        game.cards = lvData.cards;
        game.board = lvData.board;
        game.usedIcons = lvData.usedIcons;
        game.temp = [];
        game.matched = [];
        game.toolUses.undo = 0;
        game.toolUses.hint = 0;
        game.toolUses.shuffle = 0;
        game.stepStack = [];
        game.isNewLevel = true;
        game.autoCollectEnabled = false;
        autoCollectActive = false;
        renderAll();
        applyTheme(game.level);
        const cardStackArea = document.getElementById("card-stack-area");
        const oldLid = document.getElementById("card-stack-lid");
        if (oldLid) oldLid.remove();
        const lid = document.createElement("div");
        lid.id = "card-stack-lid";
        lid.innerHTML = `
      <div class="lid-text-top">卡片随机生成</div>
      <div class="lid-emoji">📩</div>
      <div class="lid-footer"><small>Coded & Designed by 开元</small></div>
  `;
        cardStackArea.appendChild(lid);
        cardStackArea.classList.add("level-starting");
        setTimeout(() => {
          const cards = cardStackArea.querySelectorAll(".card");
          cards.forEach((card, index) => {
            card.style.visibility = "visible";
            card.classList.add("card-floating-in");
            card.style.animationDelay = `${index * 0.05}s`;
          });
        }, 1000);
        setTimeout(() => {
          cardStackArea.classList.remove("level-starting");
          if (lid.parentNode) {
            lid.remove();
          }
          const cards = cardStackArea.querySelectorAll(".card");
          cards.forEach((card) => {
            card.classList.remove("card-floating-in");
            card.style.animationDelay = "";
          });
          game.lock = false;
          setTimeout(() => {
            // 检查是否仍在游戏状态，防止 gift 被送到无效界面
            const levelFinishVisible =
              document.getElementById("level-finish").style.display === "flex";
            const gameOverVisible =
              document.getElementById("game-over").style.display === "flex";
            if (!levelFinishVisible && !gameOverVisible) {
              eventGiftOffering(); // 🎁送出礼物
            }
          }, 10000); // 10秒后触发
        }, 3500);

        if (game.bgmOn) playBgm(true);
        positionCatWalker();
        updateWigglingCatVisibility();
        startRandomEvents();
        startDecorationUpdates();
        positionCurtain();
        toggleCurtain(false);
        setTimeout(() => {
          toggleCurtain(true);
          startCurtainRandomToggle();
        }, 3200);
      }

      function renderBoard() {
        const area = document.getElementById("card-stack-area");
        const existingCardElements = area.querySelectorAll(".card");

        // Get IDs of cards that should currently be rendered on the board
        // These are cards that are not matched and not currently flying
        const cardsToDisplayInBoard = game.board.filter(
          (c) => !c.matched && !c.isFlying
        );
        const cardsToDisplayInBoardIds = new Set(
          cardsToDisplayInBoard.map((c) => c.id)
        );

        // 1. Remove cards from DOM that should no longer be there
        existingCardElements.forEach((el) => {
          const cardId = parseInt(el.dataset.id, 10);
          if (!cardsToDisplayInBoardIds.has(cardId)) {
            el.remove();
          }
        });

        // 2. Add or update cards that should be on the board
        cardsToDisplayInBoard.sort((a, b) => a.z - b.z); // Ensure correct z-index order for rendering

        cardsToDisplayInBoard.forEach((card) => {
          let el = document.querySelector(
            `#card-stack-area .card[data-id='${card.id}']`
          );
          const clickable = isCardClickable(card, game.board); // Re-evaluate clickability for each card

          if (!el) {
            // Card does not exist in DOM, create it
            el = document.createElement("div");
            el.dataset.id = card.id;
            area.appendChild(el);
          }

          // Update common properties and classes for existing or new elements
          el.className = "card" + (clickable ? "" : " disabled"); // Crucial: Update disabled class
          if (card.isNapping) {
            el.classList.add("napping");
          } else {
            el.classList.remove("napping");
          }

          el.style.left = card.x + "px";
          el.style.top = card.y + "px";
          el.style.zIndex = card.z;
          el.innerHTML = card.icon;
          el.style.width = `${game.cardDimensions.width}px`;
          el.style.height = `${game.cardDimensions.height}px`;
          el.style.fontSize = `${game.cardDimensions.fontSize}px`;
          el.style.borderRadius = `${game.cardDimensions.borderRadius}px`;
          el.style.borderWidth = `${game.cardDimensions.borderWidth}px`;
        });
        game.isNewLevel = false;
        updateAutoCollectStatus();
        if (autoCollectActive && !autoCollectTimer) {
          autoCollectStep(); // 只在没有定时器时启动
        }
      }

      function renderTemp() {
        const tempSlots = document.querySelectorAll("#temp-area .temp-slot");
        const tempArea = document.getElementById("temp-area");
        const tempCardScaleFactor = 0.8;
        const tempCardWidth = game.cardDimensions.width * tempCardScaleFactor;
        const tempCardHeight = game.cardDimensions.height * tempCardScaleFactor;
        const tempCardFontSize =
          game.cardDimensions.fontSize * tempCardScaleFactor;
        const tempCardBorderRadius =
          game.cardDimensions.borderRadius * tempCardScaleFactor;
        const tempCardBorderWidth =
          game.cardDimensions.borderWidth * tempCardScaleFactor;
        tempArea.style.minHeight = `${
          tempCardHeight + tempCardBorderWidth * 2 + 16
        }px`;
        tempSlots.forEach((slot, i) => {
          slot.innerHTML = "";
          slot.style.width = `${tempCardWidth}px`;
          slot.style.height = `${tempCardHeight}px`;
          slot.style.borderRadius = `${tempCardBorderRadius}px`;
          slot.style.borderWidth = `${tempCardBorderWidth}px`;
          slot.style.margin = "0";
          if (i < game.temp.length) {
            const c = game.temp[i];
            let el = document.createElement("div");
            el.className = "temp-card" + (c.matched ? " matched" : "");
            el.innerHTML = c.icon;
            el.style.fontSize = `${tempCardFontSize}px`;
            el.style.borderRadius = `${tempCardBorderRadius}px`;
            el.style.borderWidth = `${tempCardBorderWidth}px`;
            slot.appendChild(el);
          }
        });
        let persistentHeart = document.getElementById("persistent-heart");
        if (game.temp.length === 7) {
          const seventhTempSlot = tempSlots[6];
          if (seventhTempSlot) {
            const mainArea = document.getElementById("main-area");
            const cardStackArea = document.getElementById("card-stack-area");
            const seventhSlotRect = seventhTempSlot.getBoundingClientRect();
            const cardStackRect = cardStackArea.getBoundingClientRect();
            const mainAreaRect = mainArea.getBoundingClientRect();
            const heartVerticalMidpointAbsolute =
              cardStackRect.bottom +
              (seventhSlotRect.top - cardStackRect.bottom) / 2;
            const heartTopRelativeToMainArea =
              heartVerticalMidpointAbsolute - mainAreaRect.top;
            const heartLeftRelativeToMainArea =
              seventhTempSlot.left +
              seventhTempSlot.offsetWidth / 2 -
              mainAreaRect.left;
            if (!persistentHeart) {
              persistentHeart = document.createElement("div");
              persistentHeart.id = "persistent-heart";
              persistentHeart.className = "heart-animation";
              persistentHeart.innerHTML = "💝";
              mainArea.appendChild(persistentHeart);
            }
            persistentHeart.style.left = `${heartLeftRelativeToMainArea}px`;
            persistentHeart.style.top = `${heartTopRelativeToMainArea}px`;
            persistentHeart.style.transform = "translate(-50%, -50%)";
            persistentHeart.style.display = "block";
          }
        } else {
          if (persistentHeart) persistentHeart.style.display = "none";
        }
        updateAutoCollectStatus();
      }

      function renderDisplay() {
        displayArea.innerHTML = "";
        const displayCardWidth = game.cardDimensions.width * 0.7;
        const displayCardHeight = game.cardDimensions.height * 0.7;
        const displayCardFontSize = game.cardDimensions.fontSize * 0.7;
        const displayCardBorderRadius = game.cardDimensions.borderRadius * 0.7;
        const displayCardBorderWidth = game.cardDimensions.borderWidth * 0.7;
        const displayGroupGap = displayCardWidth * 0.1;
        displayArea.style.width = `${cardStackArea.offsetWidth * 0.95}px`;
        displayArea.style.minHeight = `${
          displayCardHeight + displayCardBorderWidth * 2 + 20
        }px`;
        game.displayCards.forEach((displaySet) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "display-group";
          groupDiv.dataset.id = displaySet.id;
          groupDiv.style.gap = `${displayGroupGap}px`;
          displaySet.cards.forEach((card) => {
            const cardDiv = document.createElement("div");
            cardDiv.className =
              "display-card" + (displaySet.matched ? " matched-display" : "");
            cardDiv.innerHTML = card.icon;
            cardDiv.style.width = `${displayCardWidth}px`;
            cardDiv.style.height = `${displayCardHeight}px`;
            cardDiv.style.fontSize = `${displayCardFontSize}px`;
            cardDiv.style.borderRadius = `${displayCardBorderRadius}px`;
            cardDiv.style.borderWidth = `${displayCardBorderWidth}px`;
            groupDiv.appendChild(cardDiv);
          });
          displayArea.appendChild(groupDiv);
        });
      }

      function renderProgressAndScore() {
        levelInfoElement.textContent = `关卡: ${game.level} / 2`;
        currentScoreElement.textContent = game.score;
        targetScoreElement.textContent = game.targetScore;
        updateWigglingCatVisibility();
      }

      function showMessage(msg, color) {
        let bar = document.getElementById("message-bar");
        bar.style.color = color || "#c0392b";
        bar.textContent = msg || "";
        if (msg)
          setTimeout(() => {
            bar.textContent = "";
          }, 2300);
      }

      function hasTripleMatch() {
        let tempIcons = game.temp.filter((c) => !c.matched).map((c) => c.icon);
        let clickableBoardCards = game.board.filter(
          (c) => !c.matched && isCardClickable(c, game.board)
        );
        let clickableBoardIcons = clickableBoardCards.map((c) => c.icon);
        let allAvailableIcons = [...tempIcons, ...clickableBoardIcons];
        let iconCounts = {};
        allAvailableIcons.forEach(
          (icon) => (iconCounts[icon] = (iconCounts[icon] || 0) + 1)
        );
        return Object.values(iconCounts).some((cnt) => cnt >= 3);
      }

      function updateToolButtons() {
        document.getElementById("undo-count").textContent = game.toolUses.undo;
        document.getElementById("hint-count").textContent = game.toolUses.hint;
        document.getElementById("shuffle-count").textContent =
          game.toolUses.shuffle;
        document.getElementById("revive-count").textContent =
          game.toolUses.revive;

        undoBtn.disabled = isLandscape || game.toolUses.undo <= 0;
        undoBtn.title = isLandscape ? "横屏模式下不可用" : "撤销(需兑换码)";
        hintBtn.disabled = game.toolUses.hint <= 0 || !hasTripleMatch(); // 新增三消检测
        shuffleBtn.disabled = game.toolUses.shuffle <= 0;
        reviveBtn.disabled = game.toolUses.revive <= 0;
      }

      function renderAll() {
        renderBoard();
        renderTemp();
        renderDisplay();
        renderProgressAndScore();
        updateToolButtons();
        positionCatWalker();
        updateWigglingCatVisibility();
        positionCurtain();
        toggleCurtain(false);
        updateAutoCollectStatus();
        if (autoCollectActive && !autoCollectTimer) {
          autoCollectStep(); // 只在没有定时器时启动
        }
      }

      function showLevelFinish(msg) {
        stopRandomEvents();
        stopCurtainRandomToggle();
        stopDecorationUpdates();
        stopAutoCollectIdleWatcher();
        playBgm(false);
        if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
        if (outroVideo) {
          outroVideo.pause();
          outroVideo.currentTime = 0;
        }
        level2OutroScreen.style.display = "none";
        skipOutroBtn.style.display = "none";

        const levelFinishScreen = document.getElementById("level-finish");
        levelFinishScreen.style.display = "flex";
        levelFinishTextElement.innerHTML = msg;
        const existingConfetti = levelFinishScreen.querySelector(
          ".confetti-container"
        );
        if (existingConfetti) existingConfetti.remove();
        const confettiContainer = document.createElement("div");
        confettiContainer.className = "confetti-container";
        levelFinishScreen.appendChild(confettiContainer);
        // Monet pastel palette for confetti
        const colors = [
          "#D8EAF5", // mist blue
          "#CBE9E2", // seafoam
          "#F6D7E6", // petal pink
          "#F4E2BD", // warm sand
          "#D5E3C8", // soft green
          "#E9D5F2", // lilac haze
          "#FBE8D3", // apricot veil
          "#C7DBF0", // sky wash
          "#E4F1E6", // light jade
        ];

        for (let i = 0; i < 150; i++) {
          const piece = document.createElement("div");
          piece.className = "confetti-piece";
          piece.style.left = Math.random() * 100 + "vw";
          piece.style.backgroundColor =
            colors[Math.floor(Math.random() * colors.length)];
          const duration = Math.random() * 3 + 4;
          piece.style.animationDuration = `${duration}s`;
          piece.style.animationDelay = `${Math.random() * 5}s`;
          piece.style.transform = `rotate(${Math.random() * 360}deg)`;
          confettiContainer.appendChild(piece);
        }
        nextBtn.style.display = game.level === 1 ? "inline-block" : "none";
        gobangBtn.classList.remove("animated-scale-fade");
        closeGameBtnLevel.classList.remove("animated-scale-fade");
        // 清除旧的定位类（防止残留）
        levelFinishScreen.classList.remove("level2-start-10");
        if (game.level === 1) {
          levelFinishTextElement.style.animation =
            "shake 6s infinite, show-card-property 15s forwards";
          levelFinishTextElement.innerHTML += "<br>下一关后有彩蛋🪅！";
          playerDiv.style.display = "block";
          neteasePlayerDiv.style.display = "none";
          gobangBtn.style.display = "none";
          restartGameBtn.style.display = "none";
          retryBtnLevelFinish.style.display = "inline-block";
          closeGameBtnLevel.onclick = () => handleCloseGame("level");
        } else if (game.level === 2) {
          levelFinishScreen.classList.add("level2-start-10");
          levelFinishTextElement.style.animation =
            "pulse-scale 2s infinite alternate, wave 2s infinite";
          playerDiv.style.display = "none";
          neteasePlayerDiv.style.display = "block";
          gobangBtn.style.display = "inline-block";
          restartGameBtn.style.display = "inline-block";
          retryBtnLevelFinish.style.display = "none";
          gobangBtn.classList.add("animated-scale-fade");
          closeGameBtnLevel.classList.add("animated-scale-fade");
          closeGameBtnLevel.onclick = () => {
            document.getElementById("level-finish").style.display = "none";
            playLevel2Outro();
          };
        }
      }

      function initializeGame() {
        createRiskModal(); // 创建风险提示框
        musicToggleBtn.innerHTML = game.bgmOn ? "🎼" : "🔇";
        updateToolButtons();
      }

      function handleCloseGame(type) {
        showConfirm("确定要关闭游戏吗？", () => {
          window.close();
          setTimeout(() => {
            document.getElementById("game-container").style.display = "none";
            let messageHtml = "";

            if (type === "level") {
              if (game.level === 1) {
                messageHtml = `
                        <p>当前客户端暂不支持自动关闭，</p>
                        <p><small>小提示：可输入"kaiyuan"兑换提示次数。</small></p>
                        <br> 如果想重新开始游戏，请点击<br>
                        <br><button onclick="window.location.href='https://kaiyuanzhuadmin.github.io/cat/'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">重新开始</button>
                    `;
              } else {
                messageHtml = `
                        <p>当前客户端暂不支持自动关闭</p>
                        <p>感谢游玩全部关卡！</p>
                        <br> 如需重开，请点击<br><br>
                        <button onclick="window.location.href='https://kaiyuanzhuadmin.github.io/cat'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">重新开始</button>
                    `;
              }
            } else if (type === "gameover") {
              messageHtml = `
                    <p>当前客户端暂不支持自动关闭</p>
                    <p><small>小提示：可输入"<b>kaiyuan</b>"兑换提示次数。</small></p>
                    <br> 如果想重新开始游戏，请点击<br><br>
                    <button onclick="window.location.href='https://kaiyuanzhuadmin.github.io/cat/'" style="padding: 10px 20px; border: 1px solid #dc2626; background-color: #fef2f2; cursor: pointer; border-radius: 0.375rem;">重新开始</button>
                `;
            }

            document.body.innerHTML = `
                <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh; font-size:1.2em; color:#5d4037; text-align:center; opacity: 1;">
                    ${messageHtml}
                    <br><small class="loading-footer mt-8">超级喵喵 &copy; 2025 | Designed by 开元</small>
                </div>
            `;
          }, 100);
        });
      }

      function showEventMessage(icon, text) {
        eventIconEl.textContent = icon;
        eventTextEl.innerHTML = text;
        eventOverlay.style.display = "flex";
        setTimeout(() => (eventOverlay.style.display = "none"), 3500);
      }

      function eventCatNap() {
        const CATNAP_MIN_DURATION = 2000;
        const CATNAP_MAX_DURATION = 4000;
        const clickableCards = game.board.filter((c) =>
          isCardClickable(c, game.board)
        );
        if (clickableCards.length < 3) return;
        // 打“猫咪事件”屏障
        AnimBarrier.begin("catNap");
        showEventMessage("💤", "猫咪在打盹...<br>有些卡牌暂时拿不到了！");
        game.lock = true;
        const nappingCards = [];
        const centerCard =
          clickableCards[Math.floor(Math.random() * clickableCards.length)];
        nappingCards.push(centerCard);
        const otherCards = game.board.filter(
          (c) => !c.matched && c.id !== centerCard.id
        );
        otherCards.sort(
          (a, b) =>
            Math.hypot(a.x - centerCard.x, a.y - centerCard.y) -
            Math.hypot(b.x - centerCard.x, b.y - centerCard.y)
        );
        nappingCards.push(
          ...otherCards.slice(0, Math.floor(Math.random() * 2) + 2)
        );
        nappingCards.forEach((card) => (card.isNapping = true));
        renderBoard();
        autoCollectPaused = true;
        if (autoCollectTimer) clearTimeout(autoCollectTimer);
        updateAutoCollectStatus(); // ← 添加这一行
        game.lock = false;
        AnimBarrier.tryFlush();
        const nappingDuration = randBetween(
          CATNAP_MIN_DURATION,
          CATNAP_MAX_DURATION
        );
        setTimeout(() => {
          nappingCards.forEach((card) => {
            const boardCard = game.board.find((c) => c.id === card.id);
            if (boardCard) boardCard.isNapping = false;
          });
          renderBoard();
          checkWin();
          autoCollectPaused = false;
          tryResumeAutoCollect();
          // 结束屏障并尝试触发续跑
          AnimBarrier.end("catNap");
          AnimBarrier.tryFlush();
        }, nappingDuration);
      }

      function eventCuriousPaw() {
        let clickableCards = game.board.filter((c) =>
          isCardClickable(c, game.board)
        );
        let unclickableCards = game.board.filter(
          (c) => !c.matched && !isCardClickable(c, game.board)
        );

        if (clickableCards.length === 0 || unclickableCards.length === 0)
          return;

        // Determine how many pairs to swap (1 to 3)
        const swapCount = Math.floor(Math.random() * 3) + 1;
        const actualSwapCount = Math.min(
          swapCount,
          clickableCards.length,
          unclickableCards.length
        );

        if (actualSwapCount === 0) return;
        AnimBarrier.begin("curiousPaw");
        showEventMessage(
          "🐾",
          `好奇的爪子...<br>${actualSwapCount}对可见与不可见卡牌的图标被交换了！`
        );
        game.lock = true;

        const swappedElements = [];

        for (let i = 0; i < actualSwapCount; i++) {
          // Pick a random clickable card
          const clickableIndex = Math.floor(
            Math.random() * clickableCards.length
          );
          const card1 = clickableCards[clickableIndex];

          // Pick a random unclickable card
          const unclickableIndex = Math.floor(
            Math.random() * unclickableCards.length
          );
          const card2 = unclickableCards[unclickableIndex];

          // Swap icons
          if (card1 && card2) {
            [card1.icon, card2.icon] = [card2.icon, card1.icon];
          }

          // Animate the swapped cards
          const card1El = document.querySelector(
            `.card[data-id='${card1.id}']`
          );
          const card2El = document.querySelector(
            `.card[data-id='${card2.id}']`
          );
          if (card1El) swappedElements.push(card1El);
          if (card2El) swappedElements.push(card2El);

          // Remove the swapped cards from the pools to avoid picking them again
          clickableCards.splice(clickableIndex, 1);
          unclickableCards.splice(unclickableIndex, 1);
        }
        swappedElements.forEach((el) => el.classList.add("hinted-shake"));
        setTimeout(() => {
          renderBoard();
          game.lock = false;

          // 结束屏障并尝试触发续跑
          AnimBarrier.end("curiousPaw");
          AnimBarrier.tryFlush();

          // 如果自动收集可运行，空闲后会自然续跑
          tryResumeAutoCollect();
        }, 800);
      }

      function eventGiftOffering() {
        if (autoCollectActive) return;
        const tools = ["undo", "hint", "shuffle", "revive"]; // Added revive to tools list for random event
        const toolNames = {
          undo: "撤销",
          hint: "提示",
          shuffle: "洗牌",
          revive: "复活卡",
        }; // Added revive tool name
        const randomTool = tools[Math.floor(Math.random() * tools.length)];
        game.toolUses[randomTool]++;
        updateToolButtons();
        showEventMessage(
          "🎁",
          `猫咪送来了礼物！<br>获得1次免费<b>${toolNames[randomTool]}</b>！`
        );
      }

      const randomEvents = [
        { name: "catNap", func: eventCatNap, weight: 3 },
        { name: "curiousPaw", func: eventCuriousPaw, weight: 3 },
        { name: "giftOffering", func: eventGiftOffering, weight: 2 },
      ];
      function startRandomEvents() {
        stopRandomEvents(); // Ensure no multiple timers are running
        randomEventTimer = setInterval(() => {
          if (
            game.lock ||
            document.getElementById("level-finish").style.display === "flex" ||
            document.getElementById("game-over").style.display === "flex"
          )
            return;
          const weightedList = [];
          randomEvents.forEach((event) => {
            for (let i = 0; i < event.weight; i++)
              weightedList.push(event.func);
          });
          const randomEventFunc =
            weightedList[Math.floor(Math.random() * weightedList.length)];
          randomEventFunc();
        }, randBetween(20000, 30000));
      }
      function stopRandomEvents() {
        if (randomEventTimer) clearInterval(randomEventTimer);
        randomEventTimer = null;
      }

      function startDecorationUpdates() {
        stopDecorationUpdates();
        const decorations = document.querySelectorAll(".path-decoration");
        if (decorations.length === 0) return;
        decorationInterval = setInterval(() => {
          if (!walkingCat) return;
          const catRect = walkingCat.getBoundingClientRect();
          const catCenterX = catRect.left + catRect.width / 2;
          decorations.forEach((deco) => {
            const decoRect = deco.getBoundingClientRect();
            const decoCenterX = decoRect.left + decoRect.width / 2;
            const distance = Math.abs(catCenterX - decoCenterX);
            if (distance < 50) {
              deco.classList.add("shaking");
            } else {
              deco.classList.remove("shaking");
            }
          });
        }, 100);
      }

      function stopDecorationUpdates() {
        if (decorationInterval) {
          clearInterval(decorationInterval);
          decorationInterval = null;
        }
      }

      function positionCurtain() {
        if (!curtainElement || !displayArea) return;
        const displayRect = displayArea.getBoundingClientRect();
        const mainAreaRect = document
          .getElementById("main-area")
          .getBoundingClientRect();
        curtainElement.style.left = `${displayRect.left - mainAreaRect.left}px`;
        curtainElement.style.top = `${displayRect.top - mainAreaRect.top}px`;
        curtainElement.style.width = `${displayRect.width}px`;
        curtainElement.style.height = `${displayRect.height}px`;
        curtainElement.style.borderRadius =
          window.getComputedStyle(displayArea).borderRadius;
        curtainElement.style.display = "block";
      }

      function toggleCurtain(open) {
        if (!curtainElement) return;
        if (!game.isCurtainEnabled) {
          curtainElement.classList.remove("closed");
          curtainElement.classList.add("open");
          return;
        }
        if (open) {
          curtainElement.classList.remove("closed");
          curtainElement.classList.add("open");
        } else {
          curtainElement.classList.remove("open");
          curtainElement.classList.add("closed");
        }
      }

      function startCurtainRandomToggle() {
        stopCurtainRandomToggle();
        curtainTimer = setInterval(() => {
          if (
            game.lock ||
            !game.isCurtainEnabled ||
            document.getElementById("level-finish").style.display === "flex" ||
            document.getElementById("game-over").style.display === "flex"
          ) {
            toggleCurtain(true);
            return;
          }
          const shouldClose = Math.random() < 0.5;
          if (shouldClose) {
            toggleCurtain(false);
            setTimeout(() => {
              toggleCurtain(true);
            }, 2000);
          } else {
            toggleCurtain(true);
          }
        }, randBetween(20000, 30000));
      }

      function stopCurtainRandomToggle() {
        if (curtainTimer) {
          clearInterval(curtainTimer);
          curtainTimer = null;
        }
      }

      // =================================================================================
      // START OF MODIFICATION: Handle screen rotation by refreshing the layout.
      // =================================================================================
      // (源文件逻辑)
      /* 核心函数 */
      function handleOrientation(e) {
        // 检测从横屏切回竖屏
        if (e.matches === false && isLandscape === true) {
          const container = document.getElementById("game-container");
          container.classList.add("rotate-transition");

          // 等待动画完成后刷新布局
          setTimeout(() => {
            handleRotationRefresh();
            container.classList.remove("rotate-transition");
          }, 700);
        }
        document.body.classList.toggle("landscape", isLandscape);
        isLandscape = e.matches; // true = 横屏
        updateToolButtons(); // 只更新按钮状态即可
        // 可选：横竖切换时，重新布局
        handleRotationRefresh();
      }

      /* 监听一次就够 */
      window
        .matchMedia("(orientation: landscape)")
        .addEventListener("change", handleOrientation);

      function handleRotationRefresh() {
        if (game.lock) return;
        // 旋转后重新计算 layout
        const remainingCards = game.board.filter((c) => !c.matched);
        game.board = repositionCardsAndLayout(
          remainingCards,
          LEVELS[game.level - 1]
        );
        renderAll();
        // Lock the game during refresh
        game.lock = true;
        if (isLandscape) {
          showEventMessage("✨", "发现新大陆，<br>撤销功能被禁用了。");
        }

        game.stepStack = [];

        // After a short delay to allow the screen to resize, re-layout the cards
        setTimeout(() => {
          // Recalculate the layout with the new screen dimensions
          game.board = repositionCardsAndLayout(
            remainingCards,
            LEVELS[game.level - 1]
          );

          // Re-render the entire game state
          renderAll();

          // Unlock the game
          game.lock = false;
        }, 250); // 250ms delay to ensure browser has completed the rotation
      }

      // 最后，找到 DOMContentLoaded 事件监听器，并将里面的 window.addEventListener('resize', ...) 这一行删除或注释掉，
      // 因为屏幕方向的改变已经由上面的 handleOrientation 统一处理了。
      // window.addEventListener('resize', debounce(handleResize, 200)); // <--- 删除这一行
      // =================================================================================
      // END OF MODIFICATION
      // =================================================================================
      function updateAutoCollectStatus() {
        if (!autoCollectBtn) return;
        autoCollectCountEl.textContent = autoCollectCount;

        if (autoCollectActive && !autoCollectPaused) {
          autoCollectBtn.innerHTML = `暂停🪽 (<span id="auto-collect-count">${autoCollectCount}</span>)`;
          autoCollectBtn.disabled = false;
          autoCollectBtn.title = "点击暂停自动收集";
        } else if (autoCollectPaused) {
          autoCollectBtn.innerHTML = `继续🪽 (<span id="auto-collect-count">${autoCollectCount}</span>)`;
          autoCollectBtn.disabled = false;
          autoCollectBtn.title = "点击继续自动收集";
        } else {
          autoCollectBtn.innerHTML = `自动🪽 (<span id="auto-collect-count">${autoCollectCount}</span>)`;
          autoCollectBtn.title = "点击开始自动收集";
          autoCollectBtn.disabled =
            autoCollectCount <= 0 ||
            !(findDisplayAreaTriple() || findAnyTriple());
        }
      }

      updateAutoCollectStatus();
      function findDisplayAreaTriple() {
        if (!game.displayCards) return null;
        for (const set of game.displayCards) {
          if (set.matched) continue;
          const icon = set.cards[0].icon;
          const tempCount = game.temp.filter(
            (c) => !c.matched && c.icon === icon
          ).length;
          const boardCards = game.board.filter(
            (c) =>
              !c.matched && isCardClickable(c, game.board) && c.icon === icon
          );
          const needCount = 3 - tempCount;
          if (needCount > 0 && boardCards.length >= needCount) {
            return boardCards.slice(0, needCount).map((c) => c.id);
          }
        }
        return null;
      }

      function handleDeviceMotion(event) {
        if (game.lock || game.toolUses.shuffle <= 0) return;
        const currentTime = new Date().getTime();
        if (currentTime - lastShakeTime > 1500) {
          const acc = event.accelerationIncludingGravity;
          const threshold = 18;
          if (Math.abs(acc.x) > threshold || Math.abs(acc.y) > threshold) {
            lastShakeTime = currentTime;
            shuffleStep();
            game.toolUses.shuffle--;
            updateToolButtons();
            showMessage("你摇动了手机，自动使用了一次洗牌！", "#3e5a2b");

            if (autoCollectActive && !autoCollectPaused)
              scheduleAutoCollectAfterIdle(); // ← 新增
          }
        }
      }

      // Event Listeners
      resumeBtn.addEventListener("click", resumeGame);
      document.addEventListener("DOMContentLoaded", function () {
        // Prevent copy, paste, and cut
        ["copy", "paste", "cut"].forEach((event) => {
          document.addEventListener(event, (e) => e.preventDefault());
        });

        initializeRealisticLoadingScreen();
        attemptVideoAutoplay();

        if (window.DeviceMotionEvent) {
          window.addEventListener("devicemotion", handleDeviceMotion);
        } else {
          console.log("此设备不支持摇一摇功能。");
        }

        document.addEventListener("visibilitychange", async () => {
          if (document.hidden) {
            pauseGame();
          } else {
            // 回到前台时，仅准备音频，保持暂停框可见，等待玩家点击“继续游戏”
            try {
              await initAudio();
            } catch (e) {}
            // 友好提示（非必须）
            showMessage("已暂停：点击“继续游戏”恢复", "#3e5a2b");
          }
        });
        const feedbackDiv = document.createElement("div");
        feedbackDiv.style.cssText =
          "color: red; font-size: 12px; margin-top: 5px;";
        codeInput.parentNode.insertBefore(feedbackDiv, codeInput.nextSibling);
        codeInput.addEventListener("input", function () {
          const code = codeInput.value.trim();
          feedbackDiv.textContent = "";
          codeInput.style.borderColor = "";
          const codeRegex = /^[\u4e00-\u9fa5a-zA-Z0-9]*$/;
          if (code.length === 7) {
            if (codeRegex.test(code)) {
              feedbackDiv.textContent = "字符数正确";
              feedbackDiv.style.color = "green";
              codeInput.style.borderColor = "green";
              codeBtn.disabled = false;
              codeBtn.click();
            } else {
              feedbackDiv.textContent = "兑换码包含不支持的字符";
              feedbackDiv.style.color = "red";
              codeInput.style.borderColor = "red";
              codeBtn.disabled = true;
            }
          } else if (code.length < 7) {
            feedbackDiv.textContent = `还可输入 ${7 - code.length} 位`;
            feedbackDiv.style.color = "orange";
            codeInput.style.borderColor = "orange";
          } else {
            codeBtn.disabled = true;
          }
        });
        codeBtn.addEventListener("click", function () {
          codeInput.value = "";
          feedbackDiv.textContent = "";
          codeInput.style.borderColor = "";
        });
        codeBtn.disabled = true;
        codeInput.addEventListener("keyup", (e) => {
          if (e.key === "Enter" && !codeBtn.disabled) codeBtn.click();
        });

        // We still call handleResize once to set initial positions, but don't listen for resize events anymore.

        // MODIFIED: Added event delegation for both touch and mouse events
        cardStackArea.addEventListener("click", function (e) {
          const cardEl = e.target.closest(".card:not(.disabled)");
          if (cardEl && cardEl.dataset.id) {
            const cardId = parseInt(cardEl.dataset.id, 10);
            clickCard(cardId);
          }
        });

        cardStackArea.addEventListener(
          "touchstart",
          function (e) {
            e.preventDefault();
            Array.from(e.changedTouches).forEach((touch) => {
              const touchedEl = document.elementFromPoint(
                touch.clientX,
                touch.clientY
              );
              if (touchedEl) {
                const cardEl = touchedEl.closest(".card:not(.disabled)");
                if (cardEl && cardEl.dataset.id) {
                  const cardId = parseInt(cardEl.dataset.id, 10);
                  clickCard(cardId);
                }
              }
            });
          },
          { passive: false }
        );

        skipOutroBtn.addEventListener("click", () => handleCloseGame("level"));
      });

      undoBtn.onclick = function () {
        if (game.toolUses.undo > 0 && game.stepStack.length > 0) {
          undoStep();
          game.toolUses.undo--;
          updateToolButtons();
        } else if (game.toolUses.undo > 0 && game.stepStack.length === 0) {
          showMessage("无法撤销更多", "#888");
        }
      };
      hintBtn.onclick = function () {
        if (game.toolUses.hint > 0) {
          hintStep();
          game.toolUses.hint--;
          updateToolButtons();
        }
      };
      shuffleBtn.onclick = function () {
        if (game.toolUses.shuffle > 0) {
          shuffleStep();
          game.toolUses.shuffle--;
          updateToolButtons();
          if (autoCollectActive && !autoCollectPaused)
            scheduleAutoCollectAfterIdle(); // ← 新增
        }
      };
      reviveBtn.onclick = reviveGame; // Added event listener for revive button in tools bar
      reviveBtnGameOver.onclick = reviveGame; // Added event listener for revive button on game over screen

      restartCurrentLevelBtn.onclick = () =>
        showConfirm("确定要重新开始当前关卡吗？", () => {
          stopRandomEvents();
          stopCurtainRandomToggle();
          stopDecorationUpdates();
          startGame(game.level);
          showMessage("关卡已重新开始！", "#3e5a2b");
        });
      codeBtn.onclick = function () {
        let val = codeInput.value.trim().toLowerCase();
        if (REDEMPTION_CODES[val]) {
          const rewards = REDEMPTION_CODES[val];
          let rewardMsgs = [];

          if (rewards.type === "skip_level") {
            game.board.forEach((card) => (card.matched = true));
            game.score = game.targetScore;
            renderBoard();
            renderProgressAndScore();
            checkWin();
            showMessage(`兑换成功！当前关卡已跳过！`, "#3e5a2b");
          } else if (rewards.type === "curtain_off") {
            game.isCurtainEnabled = false;
            toggleCurtain(true);
            stopCurtainRandomToggle();
            showMessage(`兑换成功！幕布已在本关卡关闭！`, "#3e5a2b");
          } else {
            if (rewards.undo) {
              game.toolUses.undo += rewards.undo;
              rewardMsgs.push(`撤销x${rewards.undo}`);
            }
            if (rewards.hint) {
              game.toolUses.hint += rewards.hint;
              rewardMsgs.push(`提示x${rewards.hint}`);
            }
            if (rewards.shuffle) {
              game.toolUses.shuffle += rewards.shuffle;
              rewardMsgs.push(`洗牌x${rewards.shuffle}`);
            }
            if (rewards.revive) {
              game.toolUses.revive += rewards.revive;
              rewardMsgs.push(`复活卡x${rewards.revive}`);
            }
            if (rewards.autoCollect) {
              autoCollectCount += rewards.autoCollect;
              rewardMsgs.push(`自动收集x${rewards.autoCollect}`);
            }

            if (rewardMsgs.length > 0) {
              showMessage("兑换成功！获得 " + rewardMsgs.join("，"), "#3e5a2b");
            }
          }
          updateToolButtons();
          updateAutoCollectStatus();
        } else {
          showMessage("兑换码错误", "#c0392b");
        }
        codeInput.value = "";
      };
      musicToggleBtn.onclick = function () {
        game.bgmOn = !game.bgmOn;
        this.innerHTML = game.bgmOn ? "🎼" : "🔇";
        playBgm(game.bgmOn);
      };
      startBtn.onclick = function () {
        document.getElementById("start-screen").style.display = "none";
        initAudio();
        startGame(1);
      };
      nextBtn.onclick = function () {
        document.getElementById("level-finish").style.display = "none";
        startGame(2);
      };
      retryBtnLevelFinish.onclick = function () {
        document.getElementById("level-finish").style.display = "none";
        startGame(game.level);
      };
      retryBtnGameOver.onclick = function () {
        document.getElementById("game-over").style.display = "none";
        startGame(game.level);
      };
      gobangBtn.onclick = () =>
        window.open("http://Kaiyuanzhuadmin.GitHub.io/kaiyuan", "_blank");
      restartGameBtn.onclick = () =>
        (window.location.href = "https://kaiyuanzhuadmin.github.io/cat/");
      closeGameBtnLevel.onclick = () => handleCloseGame("level");
      closeGameBtnGameOver.onclick = () => handleCloseGame("gameover");

      function initializeRealisticLoadingScreen() {
        const loadingScreen = document.getElementById("loading-screen");
        const progressBar = document.getElementById("progress-bar");
        const loadingText = document.getElementById("loading-text");
        const LOAD_TIMEOUT = 5000;
        const assetsToLoad = [
          { type: "image", src: "me.png", name: "图标" },
          { type: "image", src: "mao3.webp", name: "加载背景" },
          { type: "image", src: "mao1.webp", name: "通关背景" },
          { type: "image", src: "mao.webp", name: "开始背景" },
          { type: "image", src: "cat1.webp", name: "游戏背景" },
          { type: "video", src: "aimao.mp4", name: "开始动画" },
          { type: "video", src: "mao2.mp4", name: "彩蛋视频" },
          { type: "image", src: "mao2.webp", name: "彩蛋图片" },
          { type: "audio", src: "kaa.mp3", name: "点击音效" },
          { type: "audio", src: "Sukidakara.mp3", name: "背景音乐" },
          { type: "image", src: "run.gif", name: "跑动猫咪GIF" }, // Added run.gif to preload list
        ];
        let assetsLoaded = 0;
        const totalAssets = assetsToLoad.length;
        const updateProgress = () => {
          assetsLoaded++;
          const progress = (assetsLoaded / totalAssets) * 100;
          progressBar.style.width = progress + "%";
          if (assetsLoaded === totalAssets) {
            loadingText.textContent = "完成!";
            setTimeout(() => {
              loadingScreen.style.opacity = "0";
              loadingScreen.addEventListener(
                "transitionend",
                () => {
                  loadingScreen.style.display = "none";
                  document.title = "超级喵喵";
                  initializeGame();
                },
                { once: true }
              );
            }, 400);
          } else {
            loadNextAsset();
          }
        };
        const loadAsset = (asset) => {
          return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
              reject(new Error(`Timeout loading ${asset.src}`));
            }, LOAD_TIMEOUT);
            const successHandler = () => {
              clearTimeout(timeoutId);
              resolve();
            };
            const errorHandler = () => {
              clearTimeout(timeoutId);
              reject(new Error(`Failed to load ${asset.src}`));
            };
            switch (asset.type) {
              case "image":
                const img = new Image();
                img.onload = successHandler;
                img.onerror = errorHandler;
                img.src = asset.src;
                break;
              case "audio":
                fetch(asset.src)
                  .then((response) => {
                    if (!response.ok)
                      throw new Error(`HTTP error! status: ${response.status}`);
                    return response.blob();
                  })
                  .then(() => successHandler())
                  .catch(errorHandler);
                break;
              case "video":
                const video = document.createElement("video");
                video.addEventListener("canplaythrough", successHandler, {
                  once: true,
                });
                video.onerror = errorHandler;
                video.src = asset.src;
                video.load();
                break;
            }
          });
        };
        const loadNextAsset = async () => {
          if (assetsLoaded >= totalAssets) return;
          const asset = assetsToLoad[assetsLoaded];
          loadingText.textContent = `正在加载 ${asset.name}... (${
            assetsLoaded + 1
          }/${totalAssets})`;
          try {
            await loadAsset(asset);
          } catch (error) {
            console.error(error.message);
          } finally {
            updateProgress();
          }
        };
        loadNextAsset();
      }

      function attemptVideoAutoplay() {
        const video = document.getElementById("start-screen-video");
        if (!video) return;
        const playPromise = video.play();
        if (playPromise !== undefined) {
          playPromise.catch((error) => {
            console.log(
              "Video direct play failed, waiting for user interaction.",
              error
            );
            document.body.addEventListener(
              "touchstart",
              function onFirstTouch() {
                video
                  .play()
                  .catch((e) =>
                    console.error("Video playback failed after touch:", e)
                  );
                document.body.removeEventListener("touchstart", onFirstTouch);
              },
              { once: true }
            );
          });
        }
        if (
          typeof WeixinJSBridge == "object" &&
          typeof WeixinJSBridge.invoke == "function"
        ) {
          WeixinJSBridge.invoke("getNetworkType", {}, (e) =>
            video
              .play()
              .catch((err) =>
                console.error("Video playback failed in WeixinJSBridge:", err)
              )
          );
        } else {
          document.addEventListener(
            "WeixinJSBridgeReady",
            () =>
              WeixinJSBridge.invoke("getNetworkType", {}, (e) =>
                WeixinJSBridge.invoke("getNetworkType", {}, (e) =>
                  video
                    .play()
                    .catch((err) =>
                      console.error(
                        "Video playback failed on WeixinJSBridgeReady:",
                        err
                      )
                    )
                )
              ),
            false
          );
        }
      }

      function positionCatWalker() {
        const displayArea = document.getElementById("display-area");
        const catPath = document.getElementById("cat-path");
        const mainArea = document.getElementById("main-area");
        if (!displayArea || !catPath || !mainArea) return;
        const displayAreaBottomRelativeToMainArea =
          displayArea.offsetTop + displayArea.offsetHeight;
        // Adjust catPath top to align the cat GIF correctly above the display area
        // The GIF is 50px tall, and its top is at -30px relative to catPath. So its bottom is at 20px relative to catPath.
        // We want the bottom of the cat to be slightly above the display area.
        // Let's assume cat's bottom should be at displayAreaBottomRelativeToMainArea + 5px
        // catPath.top = (displayAreaBottomRelativeToMainArea + 5px) - (50px - 30px) = displayAreaBottomRelativeToMainArea - 15px
        catPath.style.top = `${displayAreaBottomRelativeToMainArea - 15}px`;
        catPath.style.width = `${mainArea.offsetWidth}px`;
      }

      function positionWigglingCat(wigglingCatEl, slotIndex) {
        const tempSlots = document.querySelectorAll("#temp-area .temp-slot");
        const cardStackArea = document.getElementById("card-stack-area");
        const mainArea = document.getElementById("main-area");
        if (
          !wigglingCatEl ||
          tempSlots.length === 0 ||
          !cardStackArea ||
          !mainArea ||
          slotIndex < 0 ||
          slotIndex >= tempSlots.length
        ) {
          if (wigglingCatEl) wigglingCatEl.style.display = "none";
          return;
        }
        const targetTempSlot = tempSlots[slotIndex];
        const cardStackRect = cardStackArea.getBoundingClientRect();
        const targetTempSlotRect = targetTempSlot.getBoundingClientRect();
        const mainAreaRect = mainArea.getBoundingClientRect();
        const gapMidpointAbsolute =
          cardStackRect.bottom +
          (targetTempSlotRect.top - cardStackRect.bottom) / 2;
        const topRelativeToMainArea = gapMidpointAbsolute - mainAreaRect.top;
        const leftRelativeToMainArea =
          targetTempSlotRect.left +
          targetTempSlot.offsetWidth / 2 -
          mainAreaRect.left;
        wigglingCatEl.style.top = `${
          topRelativeToMainArea - wigglingCatEl.offsetHeight / 2
        }px`;
        wigglingCatEl.style.left = `${leftRelativeToMainArea}px`;
        wigglingCatEl.style.display = "block";
      }

      function hideWigglingCats() {
        wigglingCat1.style.display = "none";
        wigglingCat4.style.display = "none";
        wigglingCat7.style.display = "none";
      }

      function updateWigglingCatVisibility() {
        if (game.score >= game.targetScore) {
          positionWigglingCat(wigglingCat1, 0);
          positionWigglingCat(wigglingCat4, 3);
          positionWigglingCat(wigglingCat7, 6);
        } else {
          hideWigglingCats();
        }
      }

      function playLevel2Outro() {
        game.lock = true;
        playBgm(false);
        level2OutroScreen.style.display = "flex";
        outroLoadingText.style.display = "block";
        skipOutroBtn.style.display = "block";
        outroVideo.style.display = "none";
        outroImage.style.display = "none";
        const finalCloseAction = () => handleCloseGame("level");
        outroVideoTimeout = setTimeout(() => {
          outroVideo.style.display = "none";
          outroImage.style.display = "block";
          outroLoadingText.textContent = "视频无法播放，显示图片...";
          setTimeout(finalCloseAction, 3000);
        }, 7000);
        outroVideo.load();
        const playPromise = outroVideo.play();
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              outroVideo.style.display = "block";
              outroLoadingText.style.display = "none";
              if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
            })
            .catch((error) => {
              outroVideo.style.display = "none";
              outroImage.style.display = "block";
              outroLoadingText.textContent = "视频无法播放，显示图片...";
              if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
              setTimeout(finalCloseAction, 3000);
            });
        }
        outroVideo.onended = () => {
          if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
          finalCloseAction();
        };
        outroVideo.onerror = (e) => {
          if (outroVideoTimeout) clearTimeout(outroVideoTimeout);
          outroVideo.style.display = "none";
          outroImage.style.display = "block";
          outroLoadingText.textContent = "视频加载失败，显示图片...";
          setTimeout(finalCloseAction, 3000);
        };
      }

      function startAutoCollectIdleWatcher() {
        if (autoCollectIdleWatcher) return; // 防止重复启动
        autoCollectIdleWatcher = setInterval(() => {
          if (autoCollectPaused && autoCollectActive) {
            const now = Date.now();
            if (now - lastManualClickTime > 1000) {
              autoCollectPaused = false;
              showMessage("自动收集已恢复");
              showBlinkingCat(); // ← 添加这一行
              autoCollectStep();
              updateAutoCollectStatus();
            }
          }
        }, 1000);
      }
      function stopAutoCollectIdleWatcher() {
        if (autoCollectIdleWatcher) {
          clearInterval(autoCollectIdleWatcher);
          autoCollectIdleWatcher = null;
        }
      }

      function autoCollectStep() {
        if (autoCollectTimer) clearTimeout(autoCollectTimer);
        updateAutoCollectStatus();

        if (!autoCollectActive || autoCollectPaused) return;
        if (game.lock || game.flyingCardCount > 0 || AnimBarrier.count > 0) {
          scheduleAutoCollectAfterIdle();
          return;
        }
        if (autoCollectCount <= 0) {
          showMessage("自动收集次数用尽");
          stopAutoCollect();
          return;
        }

        const currentTempCount = game.temp.filter((c) => !c.matched).length;
        const safeThreshold = TEMP_LIMIT - 2;

        // 工具函数：统计 temp 与可点击牌
        const tempCounts = (() => {
          const map = {};
          game.temp.forEach((c) => {
            if (!c.matched) map[c.icon] = (map[c.icon] || 0) + 1;
          });
          return map;
        })();
        const clickableBoardCards = game.board.filter(
          (c) => !c.matched && isCardClickable(c, game.board)
        );
        const boardIconMap = (() => {
          const map = {};
          clickableBoardCards.forEach((c) => {
            (map[c.icon] = map[c.icon] || []).push(c);
          });
          return map;
        })();
        const spaceLeft = TEMP_LIMIT - currentTempCount;

        // 智能可行性检查：是否存在“在容量限制内能完成的三消路径”
        const hasCapacityFeasibleTriple = (() => {
          const icons = new Set([
            ...Object.keys(tempCounts),
            ...Object.keys(boardIconMap),
          ]);
          for (const icon of icons) {
            const t = tempCounts[icon] || 0;
            const b = (boardIconMap[icon] || []).length;
            const need = Math.max(0, 3 - t);
            if (need > 0 && b >= need && need <= spaceLeft) return true;
          }
          return false;
        })();

        // 若在容量限制内完全无法组成任何三消：直接自动洗牌或提示兑换
        if (!hasCapacityFeasibleTriple) {
          attemptAutoShuffleOrPrompt();
          return;
        }

        // 1️⃣ 优先级最高：立即三消（temp 已有 2 张 → 只需点 1 张），且不超容量
        const tryImmediateTriple = () => {
          for (const [icon, count] of Object.entries(tempCounts)) {
            if (count === 2 && spaceLeft >= 1) {
              const board = boardIconMap[icon] || [];
              if (board.length > 0) {
                const id = board[0].id;
                setTimeout(() => clickCard(id, true), 0);
                return true;
              }
            }
          }
          return false;
        };
        if (tryImmediateTriple()) return;

        // 2️⃣ 其次：展示区的三消（展示区图标 + temp + 可点击牌），且不超容量
        const tryDisplayTriple = () => {
          for (const set of game.displayCards) {
            if (set.matched) continue;
            const icon = set.cards[0].icon;
            const t = tempCounts[icon] || 0;
            const need = 3 - t;
            if (need <= 0) continue;
            const picks = (boardIconMap[icon] || []).slice(0, need);
            if (picks.length === need && need <= spaceLeft) {
              picks.forEach((c, i) =>
                setTimeout(() => clickCard(c.id, true), i * 300)
              );
              return true;
            }
          }
          return false;
        };
        if (tryDisplayTriple()) return;

        // 3️⃣ 最后：其他任意三消组合（temp + board），且不超容量
        const tryGenericTriple = () => {
          const icons = new Set([
            ...Object.keys(tempCounts),
            ...Object.keys(boardIconMap),
          ]);
          for (const icon of icons) {
            const t = tempCounts[icon] || 0;
            const need = 3 - t;
            if (need <= 0) continue;
            const picks = (boardIconMap[icon] || []).slice(0, need);
            if (picks.length === need && need <= spaceLeft) {
              picks.forEach((c, i) =>
                setTimeout(() => clickCard(c.id, true), i * 300)
              );
              return true;
            }
          }
          return false;
        };
        if (tryGenericTriple()) return;

        // ⏩ 三消均失败：自动洗牌或提示兑换
        attemptAutoShuffleOrPrompt();
        return;

        // 下面逻辑通常不会走到（上面 return），保留以兼容需要时的兜底

        // NEW ⏩（优先级低于所有三消）：空位充足时的“安全试点击”
        // - 条件：spaceLeft ≥ 3
        // - 目的：在不逼近容量上限的前提下加速推进局面
        if (spaceLeft >= 3) {
          const safeProbe = clickableBoardCards.find(
            (card) => !willAddCardFail(card)
          );
          if (safeProbe) {
            clickCard(safeProbe.id, true);
            return;
          }
        }

        // 4️⃣ 保留原逻辑：如果接近满，只允许执行能立即三消的操作；否则停止以保留两个空位
        if (currentTempCount >= safeThreshold) {
          const reIcons = new Set([
            ...Object.keys(tempCounts),
            ...Object.keys(boardIconMap),
          ]);
          for (const icon of reIcons) {
            const t = tempCounts[icon] || 0;
            const need = 3 - t;
            if (need <= 0) continue;
            const picks = (boardIconMap[icon] || []).slice(0, need);
            if (picks.length === need && need <= spaceLeft) {
              picks.forEach((c, i) =>
                setTimeout(() => clickCard(c.id, true), i * 300)
              );
              return;
            }
          }
          // 若仍无三消，最后再尝试洗牌或提示
          attemptAutoShuffleOrPrompt();
          return;
        }

        // 5️⃣ 其他逻辑保留：若仍无三消，尝试“安全的任意点击”（不会导致失败）
        const safeNextMove = clickableBoardCards.find(
          (card) => !willAddCardFail(card)
        );
        if (safeNextMove) {
          clickCard(safeNextMove.id, true);
          return;
        }

        // 无任何安全操作：再尝试洗牌或提示
        attemptAutoShuffleOrPrompt();
      }
      // 查找display-area优先三消（可用temp区卡片补足，返回需点击的board卡id数组）
      function findAnyTriple() {
        let tempCounts = {};
        game.temp.forEach((c) => {
          if (!c.matched) tempCounts[c.icon] = (tempCounts[c.icon] || 0) + 1;
        });

        let boardIcons = {};
        game.board.forEach((c) => {
          if (!c.matched && isCardClickable(c, game.board)) {
            if (!boardIcons[c.icon]) boardIcons[c.icon] = [];
            boardIcons[c.icon].push(c.id);
          }
        });

        for (const [icon, ids] of Object.entries(boardIcons)) {
          const tempCount = tempCounts[icon] || 0;
          const needCount = 3 - tempCount;
          if (needCount > 0 && ids.length >= needCount) {
            return ids.slice(0, needCount);
          }
        }
        return null;
      }

      // 按钮监听
      autoCollectBtn.onclick = toggleAutoCollect;
      function tryResumeAutoCollect() {
        if (autoCollectActive && !autoCollectPaused) {
          if (autoCollectTimer) clearTimeout(autoCollectTimer);
          // 改为屏障空闲后续跑，避免被动画状态抢跑
          autoCollectTimer = setTimeout(() => {
            scheduleAutoCollectAfterIdle();
          }, 450); // 在两次自动收集动作之间增加450毫秒的间隔
          updateAutoCollectStatus();
        }
      }
      // 在确认框之后添加新的风险提示框
      function createRiskModal() {
        const modal = document.createElement("div");
        modal.id = "risk-modal";
        modal.className = "modal-overlay";
        modal.innerHTML = `
    <div class="modal-content" style="background: #fff3f3; border-color: #dc2626;">
      <p id="risk-msg" style="color: #991b1b;"></p>
      <div class="modal-buttons">
        <button id="risk-confirm" style="background: #fee2e2; border-color: #991b1b; color: #991b1b;">我知道了</button>
      </div>
    </div>
  `;
        document.body.appendChild(modal);

        // 添加点击事件监听
        document
          .getElementById("risk-confirm")
          .addEventListener("click", hideRiskModal);
      }

      // 显示风险提示框
      function showRiskModal(msg, type = "risk") {
        const modal = document.getElementById("risk-modal");
        if (!modal) {
          createRiskModal();
        }

        const modalContent = modal.querySelector(".modal-content");
        // 根据不同类型设置不同的样式
        switch (type) {
          case "risk":
            modalContent.style.background = "#fff3f3";
            modalContent.style.borderColor = "#dc2626";
            break;
          case "info":
            modalContent.style.background = "#f0f9ff";
            modalContent.style.borderColor = "#3b82f6";
            break;
          case "warning":
            modalContent.style.background = "#fefce8";
            modalContent.style.borderColor = "#ca8a04";
            break;
        }
        modalContent.setAttribute("data-type", type);
        document.getElementById("risk-msg").innerHTML = msg;
        modal.style.display = "flex";

        // 添加震动效果
        if (navigator.vibrate && type === "risk") {
          navigator.vibrate(100);
        }
      }
      // 隐藏风险提示框
      function hideRiskModal() {
        const modal = document.getElementById("risk-modal");
        if (modal) {
          modal.style.display = "none";
        }
      }

      function showBlinkingCat() {
        const cat = document.getElementById("blinking-cat");
        if (!cat) return;

        cat.textContent = "😺";
        cat.style.animation = "blink-cat 2s ease-in-out";
        cat.style.opacity = "1";

        setTimeout(() => {
          cat.style.opacity = "0";
          cat.style.animation = "";
          cat.textContent = "";
        }, 2000);
      }
      // 统一管理“忙闲状态”，当所有动画/锁/飞牌都空闲时，统一触发续跑回调
      const AnimBarrier = {
        count: 0,
        tags: new Map(),
        queue: [],
        scheduled: false,

        begin(tag = "unknown") {
          this.count++;
          this.tags.set(tag, (this.tags.get(tag) || 0) + 1);
        },

        end(tag = "unknown") {
          const now = (this.tags.get(tag) || 0) - 1;
          if (now <= 0) this.tags.delete(tag);
          else this.tags.set(tag, now);
          this.count = Math.max(0, this.count - 1);
          this.tryFlush();
        },

        onIdle(cb) {
          if (this.isIdle()) cb();
          else this.queue.push(cb);
        },

        isIdle() {
          // 将 lock / flying 一并视作屏障
          const busy = this.count > 0 || game.flyingCardCount > 0 || game.lock;
          return !busy;
        },

        tryFlush() {
          if (!this.isIdle()) return;
          if (this.scheduled) return;
          this.scheduled = true;
          setTimeout(() => {
            this.scheduled = false;
            if (!this.isIdle()) return;
            const cbs = this.queue.splice(0);
            cbs.forEach((cb) => {
              try {
                cb();
              } catch (e) {
                console.error(e);
              }
            });
          }, 0);
        },
      };

      // 统一的“空闲后再续跑自动收集”
      function scheduleAutoCollectAfterIdle() {
        AnimBarrier.onIdle(() => {
          if (autoCollectActive && !autoCollectPaused) autoCollectStep();
        });
      }
      function applyTheme(level) {
        const container = document.getElementById("game-container");
        const bodyEl = document.body; // 获取body元素

        // 移除旧的class
        container.classList.remove("theme-dali-rose", "theme-renaissance");
        bodyEl.classList.remove("bg-level-1", "bg-level-2");

        if (level === 1) {
          bodyEl.classList.remove("bg-default");
          container.classList.add("theme-dali-rose");
          bodyEl.classList.add("bg-level-1"); // 应用第一关背景
        } else if (level === 2) {
          container.classList.add("theme-renaissance");
          bodyEl.classList.add("bg-level-2"); // 应用第二关背景
        }
      }
      function checkAndShuffleLoop() {
        // 检查洗牌后是否出现了可三消的组合
        if (hasTripleMatch()) {
          // 如果有，则显示成功信息，并安排自动收集继续执行
          showMessage("洗牌成功，发现可消除组合！", "#3e5a2b");
          scheduleAutoCollectAfterIdle();
        } else {
          // 如果仍然没有可三消的组合，则再次尝试自动洗牌
          // attemptAutoShuffleOrPrompt 函数会处理洗牌次数的消耗和用尽后的情况
          showMessage("洗牌后仍无三消，再次尝试...", "#ca8a04");
          // 增加一个小延迟，避免循环过快导致视觉问题或浏览器卡顿
          setTimeout(() => {
            attemptAutoShuffleOrPrompt();
          }, 200);
        }
      }
      function attemptAutoShuffleOrPrompt() {
        if (game.toolUses.shuffle > 0) {
          game.toolUses.shuffle--;
          updateToolButtons();
          showMessage("无三消，自动洗牌一次", "#3e5a2b");

          setTimeout(() => {
            // 调用 shuffleStep 时，传入 true 来标记这是自动洗牌
            shuffleStep(true);
          }, 100);
        } else {
          if (!game.noShuffleCodePromptShown) {
            game.noShuffleCodePromptShown = true;
            showRiskModal(
              "当前无可消除，且洗牌次数已用尽。<br>输入兑换码可获取洗牌次数。<br>如：haogege，或者去问他。",
              "info"
            );
            setTimeout(() => {
              try {
                codeInput && codeInput.focus();
              } catch (e) {}
            }, 80);
          }
          stopAutoCollect();
          updateAutoCollectStatus();
          return;
        }
      }
      function pauseGame() {
        console.log("游戏已暂停。浏览器可能会挂起音频。");
        // 检查游戏是否处于可暂停的状态
        const startScreenVisible =
          document.getElementById("start-screen").style.display !== "none";
        const levelFinishVisible =
          document.getElementById("level-finish").style.display === "flex";
        const gameOverVisible =
          document.getElementById("game-over").style.display === "flex";

        if (
          game.isPaused ||
          startScreenVisible ||
          levelFinishVisible ||
          gameOverVisible
        ) {
          return; // 如果游戏已暂停或在不可暂停的界面，则不执行任何操作
        }

        game.isPaused = true;
        playBgm(false); // 暂停背景音乐
        stopRandomEvents();
        stopCurtainRandomToggle();
        stopDecorationUpdates();
        stopAutoCollect();
        stopAutoCollectIdleWatcher();

        // 显示暂停界面，并确保立即应用样式
        pauseScreen.style.display = "flex";
        // 强制浏览器立即重绘，以确保暂停框在页面卸载前显示
        // 这通常通过读取一个会触发回流的属性来实现
        pauseScreen.offsetHeight;
      }

      /**
       * 恢复游戏，隐藏暂停界面并重启所有计时器。
       */
      async function resumeGame() {
        console.log("正在恢复游戏...");
        if (!game.isPaused) return;

        game.isPaused = false;
        pauseScreen.style.display = "none";

        // --- 核心修改：强制关闭并重置音频 ---
        console.log("正在强制重置点击音效...");
        // 1. 如果存在一个活跃的 AudioContext，就关闭它
        if (audioContext && audioContext.state !== "closed") {
          await audioContext.close();
          console.log("旧的 AudioContext 已关闭。");
        }
        // 2. 清空相关变量，确保 initAudio 会执行完整的重新加载流程
        audioContext = null;
        clickSoundBuffer = null;
        clickAudioFailed = false; // 同时重置失败状态
        // --- 修改结束 ---

        // 在用户交互后重新初始化音频，并等待其完成
        await initAudio();
        console.log("音频系统已重新加载并准备就绪。");
        
        if (game.bgmOn) {
          playBgm(true);
        }

        // 重启各种游戏事件计时器
        startRandomEvents();
        startCurtainRandomToggle();
        startDecorationUpdates();
        tryResumeAutoCollect(); // 尝试恢复自动收集（如果之前是开启的）
      }
    </script>
  </body>
</html>

